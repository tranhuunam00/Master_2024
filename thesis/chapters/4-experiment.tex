Trong phần này, tác giả trình bày nhưng kết quả đã đạt được dựa trên các cơ sở
lý thuyết trong hai chương đã trình bày phần trước. Kết quả sẽ được trình bày
đúng theo trình tự mục tiêu của luận văn: Đầu tiên là kết quả nghiên cứu, phát
triển phần cứng. Thứ hai, kết quả đánh giá dữ liệu cảm biến bằng học máy. Cuối
cùng là kết quả triển khai trên biên.

\section{Hệ thống thu thập, lưu trữ}

Hình~\ref{fig:mach} là kết quả mạch đã hoàn thiện. Mạch đã được nhóm kiểm tra
hoạt đồng đúng theo yêu cầu các thành phần theo như thiết kế. Nạp bootloader và
tiến hành nạp code cho vi điều khiển qua USB.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/mach.png}
    \caption{Mạch hoàn chỉnh}
    \label{fig:mach}
\end{figure}

Ngoài cách cấp nguồn trực tiếp thông qua USB, tác giả còn gắn thêm viên pin
lipo có dải điện áp trung bình là 3.7 V và tối thiểu là 3V có kích thước là 20
mm * 20 mm * 5 mm tại mạch sau của mạch để thuận lợi hơn trong quá trình lấy
mẫu.

Song song với việc phát triển phần cứng, phần mềm cũng được hoàn thành với đầy
đủ các tính năng như yêu cầu trước đó đưa ra bao gồm cả ứng dụng di dộng và máy
chủ đám mây. Dựa trên phản hồi từ nhóm nghiên cứu, tư vấn khoa học của Thầy
PGS.TS. Mai Anh Tuấn, tư vấn y khoa của Thầy GS.TS. Dương Quý Sỹ, ứng dụng được
thiết kế với tiêu chí giao diện thân thiện, thao tác đơn giản và tính năng tập
trung vào mục tiêu thử nghiệm.

Sau khi cài đặt, người dùng có thể đăng nhập hoặc đăng ký tài khoản thông qua
giao diện như được thể hiện trong Hình~\ref{appAuth}. Với người dùng mới, quá
trình đăng ký yêu cầu xác thực địa chỉ email nhằm đảm bảo bảo mật và hỗ trợ
tính năng khôi phục tài khoản. Hình~\ref{appsleep} minh họa giao diện của các
chức năng, Chatbot hỗ trợ người dùng trong quá trình sàng lọc nguy cơ ngưng thở
khi ngủ và cung cấp thông tin về chất lượng giấc ngủ.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\linewidth]{images/appsleep.png}
    \caption{Giao diện chức năng chatbot và bộ câu hỏi tầm soát}
    \label{appsleep}
\end{figure}

Hình ~\ref{listble} thể hiện danh sách BLE có thể kết nối và dịch vụ kết nối
với phần cứng đã được nhắc tới bên trên. Khi người chọn vào BLE có tên là
MASTER\_2025\_BLE ứng dụng di động xuất thêm màn hình chọn cảm biến thu thập.
Đây cũng có thể coi là bước chọn đúng UUID của dịch cụ GATT đã được cấu hình
sẵn ở phần cứng.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\linewidth]{images/appAuth.png}
    \caption{Giao diện chức năng đăng ký và đăng nhập}
    \label{appAuth}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.4\textwidth]{images/ketqua_capquyen.jpg}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.4\textwidth]{images/ketqua_scan.jpg}
    \end{subfigure}
    \caption{Màn hình yêu cầu quyền truy cập Bluetooth và danh sách thiết bị đang hoạt động}
    \label{fig:ketqua_scan}
\end{figure}

Khi chọn đọc giá trị cảm biến, ứng dụng di động sẽ tự động truy cập vào đặc
tính trong dịch vụ. Hình~\ref{ketqua_bieudoxyz} minh họa giao diện hiển thị giá
trị cảm biến theo thời gian thực và Hình~\ref{ketqua_mongo} thể hiện giá trị
cảm biến đã được lưu vào cơ sở dữ liệu. Ngoài ra, dữ liệu về tư thế hiện tại và
số lượng tư thế ngủ được tính toán dựa vào suy luận kết quả mô hình đã huấn
luyện trên máy chủ trung tâm.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\linewidth]{images/ketqua_bieudoxyz.jpg}
    \caption{Màn hình hiển thị dữ liệu gia tốc ba trục với hoàng là giá trị thời gian, trục tung là giá trị cảm biến gấp lên 10 lần }
    \label{ketqua_bieudoxyz}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\linewidth]{images/ketqua_mongo.png}
    \caption{Dữ liệu cảm biến gia tốc được lưu trong cơ sở dữ liệu}
    \label{ketqua_mongo}
\end{figure}

\newpage

\section{Thu thập và gắn nhãn dữ liệu}

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/4position.png}}
    \caption{Mô phỏng thực nghiệm thực tế}
    \label{4Position}
\end{figure}

Trong phần này, tác giả trình bày chi tiết phương pháp thu thập dữ liệu, các
kịch bản thực nghiệm, cũng như quy trình xử lý và trích xuất đặc trưng để phục
vụ cho việc huấn luyện các mô hình học máy trong bài toán nhận diện tư thế ngủ.

Tổng cộng 25 tình nguyện viên đã được tuyển chọn tham gia vào quá trình thu
thập dữ liệu, với độ tuổi dao động từ 10 đến 60, trong đó độ tuổi phổ biến là
24. Nhóm tình nguyện viên bao gồm cả nam và nữ, được lựa chọn với tiêu chí đa
dạng về giới tính và độ tuổi nhằm tăng tính đại diện và khách quan cho bộ dữ
liệu.

Trong kịch bản đầu tiên (gọi là \textbf{thu thập có giám sát}), mỗi tình nguyện
viên được hướng dẫn gắn thiết bị cảm biến vào vùng cổ bằng băng keo y tế hai
mặt 3M, sau đó đăng nhập vào ứng dụng di động với tài khoản cá nhân đã đăng ký.
Dưới sự giám sát trực tiếp của tác giả, mỗi người tham gia sẽ lần lượt thực
hiện các tư thế ngủ cơ bản (nằm ngửa, nằm sấp, nghiêng trái, nghiêng phải)
trong thời gian tối thiểu 2 phút cho mỗi tư thế Hình~\ref{4Position}. Mỗi tư
thế được lặp lại ít nhất hai lần để đảm bảo tính lặp lại và ổn định của tín
hiệu. Sau khi xác minh rằng dữ liệu cảm biến đã được lưu trữ đầy đủ trên hệ
thống (kiểm tra trên MongoDB và giao diện ứng dụng), quá trình thu thập dữ liệu
từ một tình nguyện viên được xem là hoàn tất.

Bên cạnh đó, để mô phỏng điều kiện thực tế khi sử dụng thiết bị trong sinh hoạt
ban đêm, tác giả đã tự thực hiện kịch bản thứ hai (\textbf{thu thập trong giấc
    ngủ tự nhiên}). Trong kịch bản này, thiết bị được gắn vào cổ trước khi đi ngủ
và ghi nhận dữ liệu liên tục trong suốt một đêm. Song song đó, một camera cố
định được lắp đặt phía trên giường để ghi hình toàn bộ quá trình ngủ, từ đó hỗ
trợ gán nhãn chính xác theo thời gian. Dữ liệu trong giai đoạn này được xử lý
và đồng bộ thủ công giữa tín hiệu cảm biến và video để loại bỏ các đoạn có
chuyển động hoặc sai lệch nhãn.

Mặc dù phương pháp thu thập trong môi trường tự nhiên sát với điều kiện sử dụng
thực tế, nhưng đòi hỏi nhiều công sức xử lý hậu kỳ và khó kiểm soát chất lượng
dữ liệu đầu vào. Theo ý kiến tư vấn từ các chuyên gia trong lĩnh vực y học giấc
ngủ, phương pháp thu thập có giám sát (phương pháp 1) vẫn được ưu tiên do khả
năng kiểm soát tốt, đảm bảo dữ liệu cân bằng giữa các tư thế, đồng thời vẫn duy
trì được mức độ tương thích cao với điều kiện thực tế khi triển khai ứng dụng
theo dõi tại nhà.

Sau quá trình thu thập, bộ dữ liệu huấn luyện bao gồm tổng cộng \textbf{158.750
    mẫu} hợp lệ sau khi đã lọc nhiễu và loại bỏ các phiên ghi nhận không đạt yêu
cầu của 25 tình nguyện viên. Dữ liệu kiểm thử được loại bỏ các hoạt động không
thuộc tư thế ngủ và gắn nhãn dựa trên camera. Kết quả là bộ dữ liệu kiểm thử
gồm \textbf{64.258 mẫu}.

Tất cả dữ liệu thu thập từ các tình nguyện viên và tác giả đều được xuất ra
định dạng \texttt{CSV}, bao gồm thông tin thời gian (timestamp), giá trị cảm
biến trên ba trục $x$, $y$, $z$, và nhãn tư thế tương ứng (nếu có). Dữ liệu này
được sử dụng làm đầu vào cho quá trình trích xuất đặc trưng và huấn luyện mô
hình học máy.

\section{Phân loại tư thế ngủ bằng học máy}

\subsection{Phân tích dữ liệu}
Sau khi hoàn thành quá trình thu thập dữ liệu của hai kịch bản, tác giả tiến
hành phân tích các giá trị cảm biến của ba trục. Đâu tiên phân tích độ cân bằng
dữ liệu như Hình~\ref{fig:ana_balance}.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_balance_train.png}
        \label{fig:ana_balance_train}
        \caption{tập huấn luyện}

    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_balance_test.png}
        \label{fig:ana_balance_test}
        \caption{tập kiểm thử}
    \end{subfigure}
    \caption{Biểu đồ phân bố các nhãn thu được}
    \label{fig:ana_balance}
\end{figure}

Hình~\ref{fig:ana_balance} cho thấy phân bố dữ liệu của tập huấn luyện tương
đối cân bằng. Còn đối với tập kiểm thử, tư thế nằm ngửa và nghiêng trái chiếm
đa số. Qua đó, cho thấy sự phản ánh dữ liệu đúng như dự kiến của tác giả. Với
bộ huấn luyện, các nhãn sẽ giữ ở mức cân bằng để tránh tình trạng quá khớp. Còn
ở tập kiểm thử, các nhãn phản ánh đúng sinh lý của cá nhân khi ngủ, sẽ thường
có những tư thế nổi bật hẳn về số lượng do thói quen.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_distribute_train.png}
        \label{fig:ana_distribute_train}
        \caption{tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_distribute_test.png}
        \label{fig:ana_distribute_test}
        \caption{tập kiểm thử}
    \end{subfigure}
    \caption{Biểu đồ phân bố dữ liệu 3 trục theo các tư thế ngủ}
    \label{fig:ana_distribute}
\end{figure}

Hình~\ref{fig:ana_distribute} (a) trình bày phân tích chi tiết phân bố tín hiệu
cảm biến theo ba trục gia tốc ứng với bốn tư thế ngủ cơ bản của tập huấn luyện
thu từ 25 tình nguyện viên. Ở trục $x$, các phân bố tương đối biệt lập, giữa
hai tư thế nằm ngửa và nằm sấp, cũng như giữa nghiêng trái và nghiêng phải.
Điều này cho thấy trục $x$ có khả năng phân biệt tư thế tốt. Trục $y$ thể hiện
mức độ tương đồng giữa các tư thế, dẫn đến khả năng tách biệt thấp và ít giá
trị trong việc xác định tư thế ngủ. Đối với trục $z$, có thể quan sát được sự
phân tách rõ ràng giữa tư thế nằm nghiêng và các tư thế dọc (nằm ngửa và nằm
sấp), chứng tỏ vai trò quan trọng của trục $z$ trong phân loại tư thế. Còn đối
với Hình~\ref{fig:ana_distribute} (b), các phân bố về trung bình cũng tương
đồng với tập huấn luyện cho thấy sự phản ánh đúng phương pháp lấy mẫu mang tính
đúng đắn. Tuy nhiên, giải phân phối của tập kiểm thử tương đối rộng, nguyên
nhân được suy đoán là do các tín hiệu nhiễu chưa được sàng lọc kĩ ở bước làm
sạch dữ liệu và gắn nhãn. Đây là cũng trường hợp không hiếm gặp trong khi ngủ
thực tế cả đêm, con người cí thể có các hoạt động khác như là đi vệ sinh hay là
uống nước. Đây cũng là thách thức tác giả cần giải quyết phát hiện đang nằm ngủ
hay đang không nằm.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/ana_distribute_z.png}}
    \caption{Phân bố giá trị trục x của 2 tập dữ liệu}
    \label{ana_distribute_z}
\end{figure}

Hình~\ref{ana_distribute_z} chỉ ra phân bố giá trị trục z của hai tập dữ liệu:
huấn luyện (xanh) và kiểm thử (cam). Cho thầy, mật độ đỉnh ở hai tập dữ liệu
khá tương đồng. Điều này cũng được chính minh ở phần trên. Tuy nhiên, có một số
điểm khác biệt tại giá trị -0.5 của tập kiểm thử. Giá trị này rơi chủ yếu vào
tư thế nằm nghiêng trái và nắm sập. Từ đây, tác giả phỏng đoán sẽ có nhầm lẫn
trong suy luận giữa 2 tư thế này tại tập kiểm thử.

\subsection{Xử lý và trích xuất đặc trưng}

Dữ liệu cảm biến thu thập được trước tiên được xử lý khử nhiễu bằng phương pháp
hiệu chỉnh điểm gốc, bằng cách lấy hiệu giữa giá trị hiện tại và giá trị tham
chiếu ban đầu trên ba trục $x$, $y$, và $z$. Sau đó, tín hiệu được chia thành
các cửa sổ thời gian có độ dài 2 giây, với mức chồng lấn 50\% giữa các cửa sổ.
Chỉ những cửa sổ dữ liệu có nhãn nhất quán trong toàn bộ thời gian mới được giữ
lại để huấn luyện mô hình. Các cửa sổ chứa nhãn không đồng nhất (nhiều hơn một
nhãn) hoặc có biểu hiện chuyển động bất thường sẽ bị loại bỏ khỏi quá trình xử
lý tiếp theo.

\begin{table}[htbp]
    \caption{Các đặc trưng thống kê và tín hiệu được sử dụng trong phân loại tư thế ngủ}
    \label{tab:features}
    \begin{center}
        \renewcommand{\arraystretch}{1.5}
        \begin{tabular}{|l|p{9.5cm}|}
            \hline
            \textbf{Đặc trưng}            & \textbf{Mô tả / Công thức}                                         \\
            \hline
            Giá trị trung bình            & $\mu_s = \frac{1}{n} \sum_{i=1}^{n} S_i$                           \\
            \hline
            Độ lệch chuẩn                 & $\sigma_s = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (S_i - \mu_s)^2}$     \\
            \hline
            Độ lệch tuyệt đối trung bình  & $\text{AAD} = \frac{1}{n} \sum_{i=1}^{n} |S_i - \mu_s|$            \\
            \hline
            Giá trị nhỏ nhất              & $\min(s) = \min(S_1, S_2, \ldots, S_n)$                            \\
            \hline
            Giá trị lớn nhất              & $\max(s) = \max(S_1, S_2, \ldots, S_n)$                            \\
            \hline
            Hiệu số lớn nhất - nhỏ nhất   & $\max(s) - \min(s)$                                                \\
            \hline
            Trung vị                      & $\text{Median}(s) = \text{median}(S_1, S_2, \ldots, S_n)$          \\
            \hline
            Độ lệch tuyệt đối trung vị    & $\text{MAD} = \frac{1}{n} \sum_{i=1}^{n} |S_i - \text{Median}(s)|$ \\
            \hline
            Khoảng tứ phân vị             & $IQR = \text{percentile}(75) - \text{percentile}(25)$              \\
            \hline
            Số giá trị âm                 & $\#(S_i < 0)$                                                      \\
            \hline
            Số giá trị dương              & $\#(S_i > 0)$                                                      \\
            \hline
            Số giá trị lớn hơn trung bình & $\#(S_i > \mu_s)$                                                  \\
            \hline
            Số đỉnh (local maxima)        & Số lượng điểm cực đại cục bộ trong chuỗi tín hiệu                  \\
            \hline
            Độ lệch (Skewness)            & $\frac{1}{n \sigma_s^3} \sum_{i=1}^{n} (S_i - \mu_s)^3$            \\
            \hline
            Độ nhọn (Kurtosis)            & $\frac{1}{n \sigma_s^4} \sum_{i=1}^{n} (S_i - \mu_s)^4$            \\
            \hline
            Năng lượng tín hiệu           & $\sum_{i=1}^{n} S_i^2$                                             \\
            \hline
            Gia tốc tổng hợp trung bình   & $\frac{1}{n} \sum_{i=1}^{n} \sqrt{x_i^2 + y_i^2 + z_i^2}$          \\
            \hline
            Tổng độ lớn tín hiệu (SMA)    & $\frac{1}{n} \sum_{i=1}^{n} (|x_i| + |y_i| + |z_i|)$               \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\subsubsection{Đặc trưng miền thời gian (T1)}\label{AA}

Dữ liệu cảm biến gia tốc là dữ liệu chuỗi thời gian, do đó các đặc trưng miền
thời gian đóng vai trò rất quan trọng trong nhận diện tư thế ngủ. Trong nghiên
cứu này, tác giả trích xuất tổng cộng 40 đặc trưng thống kê cho mỗi cửa sổ dữ
liệu, trên cả ba trục $x$, $y$, $z$. Các đặc trưng bao gồm giá trị trung bình,
độ lệch chuẩn, độ lệch tuyệt đối trung bình, giá trị lớn nhất, nhỏ nhất, hiệu
số lớn-nhỏ nhất, trung vị, độ lệch tuyệt đối trung vị, khoảng tứ phân vị, số
lượng giá trị âm/dương, số lượng giá trị lớn hơn trung bình, số đỉnh tín hiệu,
độ lệch, độ nhọn, năng lượng tín hiệu, gia tốc tổng hợp và tổng độ lớn tín
hiệu. Các đặc trưng này được lựa chọn dựa trên tính dễ tính toán, hiệu quả phân
tách tư thế và khả năng triển khai trên vi điều khiển.

\subsubsection{Đặc trưng miền tần số (F1)}\label{AA}

Để khai thác thông tin trong miền tần số, tác giả sử dụng Biến đổi Fourier Nhanh (FFT) để chuyển đổi dữ liệu từ miền thời gian sang miền tần số. Từ các cửa sổ tín hiệu sau biến đổi, 29 đặc trưng thống kê được tính toán, bao gồm các đặc trưng tương tự như trong miền thời gian: trung bình, độ lệch chuẩn, độ lệch tuyệt đối, giá trị cực đại – cực tiểu, trung vị, khoảng tứ phân vị, số đỉnh, độ lệch, độ nhọn, năng lượng tín hiệu,... Ngoài ra, hai đặc trưng kết hợp là gia tốc tổng hợp trung bình và tổng độ lớn tín hiệu (SMA) cũng được duy trì trong miền tần số để phục vụ so sánh với miền thời gian.

Việc sử dụng đồng thời các đặc trưng từ cả hai miền thời gian và tần số giúp
tăng khả năng mô tả đặc trưng cho mô hình học máy, từ đó nâng cao hiệu quả phân
loại tư thế ngủ trong các điều kiện khác nhau.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/ana_feature_time.png}}
    \caption{Phân bố của đặc trưng trung bình, độ lệnh chuẩn và năng lượng trên miền thời gian của tập huấn luyện}
    \label{ana_feature_time}
\end{figure}

Hình~\ref{ana_feature_time} đưa ra những ý nghĩa của ba đặc trưng miền thời
gian. Các đặc trưng trung bình và năng lượng của 2 trục x và z cho phân bố mật
độ tách biệt để phân bật nhóm tư thế nghiêng trái - nghiêng phải và ngửa - sấp.
Đối bối trục y, theo đánh giá các phân bộ sẽ đa số tập trung thành cũng giống
như đặc trưng độ lệnh chuẩn trên miền thời gian và các hai giá trị đặc trưng
trên miền tần số Hình~\ref{ana_feature_fft}. Qua phân tích trên, tác giả càng
tin tưởng về luận điểm rằng với tư thế ngủ, các đặc trưng miền thời gian sẽ có
nhiều ý nghĩa hơn và trong đó cũng sẽ có những nhóm thực sự nổi bật để có thể
phân loại tư thế ngủ.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/ana_feature_fft.png}}
    \caption{Phân bố của đặc trưng trung bình, độ lệnh chuẩn trên miền tần số của tập huấn luyện}
    \label{ana_feature_fft}
\end{figure}
\subsection{Lựa chọn tham số}
Sau khi xác định được 69 đặc trưng cả miền thời gian và tần số, tác giả sẽ chạy
qua các vòng lặp với các dải tham số cài đặt sẵn với 5 mô hình đã lựa chọn LR,
RF, SVM, GB và ANN như Bảng~\ref{tab:model_results}.
\begin{table}[htbp]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \setlength{\tabcolsep}{5pt}
    \caption{Kết quả lựa chọn tham số cho các mô hình học máy}
    \label{tab:model_results}
    \small
    \begin{tabular}{|l|p{1cm}|p{1cm}|p{7cm}|p{1.5cm}|p{1.5cm}|}
        \hline
        \textbf{Mô hình}                                                                                                                         & \textbf{Số tổ hợp} & \textbf{Lần thử} & \textbf{Tham số tối ưu} & \textbf{Xác thực chéo} & \textbf{Độ chính xác} \\
        \hline
        \textbf{RF}                                                                                                                              & 288                & 864              &
        \raggedright\ttfamily n\_estimators=20, max\_depth=10, min\_samples\_split=2, min\_samples\_leaf=1, max\_features='sqrt', bootstrap=True &
        \textbf{98.82}                                                                                                                           & \textbf{99.45}                                                                                                   \\
        \hline
        \textbf{LR}                                                                                                                              & 54                 & 162              &
        \raggedright\ttfamily C=5, max\_iter=10, penalty='l2', solver='newton-cg'                                                                &
        96.55                                                                                                                                    & 96.30                                                                                                            \\
        \hline
        \textbf{SVM}                                                                                                                             & 216                & 648              &
        \raggedright\ttfamily C=1, kernel='linear', degree=2, gamma='scale', decision\_function\_shape='ovo'                                     &
        96.62                                                                                                                                    & 94.06                                                                                                            \\
        \hline
        \textbf{GB}                                                                                                                              & 216                & 648              &
        \raggedright\ttfamily n\_estimators=10, learning\_rate=0.1, max\_depth=4, max\_features='sqrt', subsample=0.8                            &
        \textbf{97.51}                                                                                                                           & \textbf{99.51}                                                                                                   \\
        \hline
        \textbf{NN}                                                                                                                              & 32                 & 96               &
        \raggedright\ttfamily neurons\_1=8, neurons\_2=8, learning\_rate=0.01, batch\_size=16, epochs=20                                         &
        98.01                                                                                                                                    & 95.83                                                                                                            \\
        \hline
    \end{tabular}
\end{table}

Bảng~\ref{tab:model_results} cho thấy mô hình RF và GB được đánh giá về mặt độ
chính xác là ổn định nhất cả quá trình xác thực chéo và tập kiểm tra. Hai mô
hình SVM và LR có độ chính xác thấp nhất trong 5 mô hình nhưng vẫn cho độ chính
xác > 94\%. Mô hình NN được xây dựng không thông qua 69 đặc trưng mà dùng trực
tiếp giá trị gia tốc thô với cửa số 10 mẫu (30 giá trị x, y, z) để huấn luyện
cho kết quả ấn tượng đối với tập huấn luyện nhưng bị suy giảm so với tập kiểm
tra. Hình~\ref{fig:ml_confuse} cũng chỉ ra rằng, đối với mô hình NN, hai tư thế
nghiêng phải và ngửa đang bị suy luận sai. Việc này cũng được tác giả phân tích
biểu đồ phân bố đối với trục z bên trên. Ngoài ra, SVM có những sự nhầm lẫn ở
hai tư thế là nghiêng trái và nghiêng phải.

Bên cạnh đó, tác giả cũng phân tích thêm các đặc trưng ảnh hưởng như thế nào
đến các mô hình có tham số tốt nhất (không có ANN vì lý do ANN không dùng 69
đặc trưng) Hình~\ref{fig:ml_shap}. Đúng với nhận định từ trước, các tính năng
miền thời gian chiếm nhiều ý nghĩa lên mô hình đặc biệt là đặc trưng được trích
xuất từ hai trục x, y và các đặc trưng tổng hợp từ 3 trục. Đặc trưng miền tần
số đa phần đứng vị trí cuối cho thấy không có nhiều ý nghĩa đối với các tham số
đã chọn.

Hình~\ref{fig:ml_shap} (a) và (d) khá tương đồng về mặt ý nghĩa của các đặc
trên lên mô hình RF và GB. Đây cũng thể xem là do 2 mô hình đều có cơ chế xây
dựng dựa trên các cây quyết định. Hình~\ref{fig:ml_shap} (b) chỉ ra LR thì lại
ưu tiên hơn các đặc trưng được tổng hợp từ ba trục. Còn đối với SVM
Hình~\ref{fig:ml_shap} (b), đã xác định rõ các véc-tơ hỗ trợ nên đang tính các
tính năng còn lại đều có giá trị 0.

Ngoài ra, tác giả cũng nhận thấy có 15 đặc trưng luôn xuất hiên vị trí đầu của
tất cả các mô hình bao gồm: "z\_median","z\_mean","x\_mean","x\_energy",
"z\_pos\_count", "z\_neg\_count","x\_median", 'z\_energy', 'avg\_result\_accl',
'x\_neg\_count', 'z\_std', 'x\_pos\_count',"y\_energy","y\_mean","sma",
'y\_median'.

Để hiểu sâu hơn về ý nghĩa các đặc trưng này, tác giả xây dựng 8 kịch bản để đánh giá.
Việc này không chỉ có ý nghĩa về mặt phân tích đặc trưng và còn muốn làm rõ hơn về mặt kích thước mô hình để phù hợp triển khai lên biên.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_rf.png}
        \label{fig:ml_confuse_rf}
        \caption{RF}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_lr.png}
        \label{fig:ml_confuse_lr}
        \caption{LR}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_nn.png}
        \label{fig:ml_confuse_nn}
        \caption{NN}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_svm.png}
        \label{fig:ml_confuse_svm}
        \caption{SVM}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_gb.png}
        \label{fig:ml_confuse_gb}
        \caption{GB}
    \end{subfigure}
    \caption{Ma trận nhầm lẫn của các mô hình học máy}
    \caption*{\textit{Ghi chú:} Nhãn 0 – tư thế ngửa; 1 – nghiêng phải; 2 – nghiêng trái; 3 – sấp.}
    \label{fig:ml_confuse}

\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.6\textwidth]{images/ml_shap_rf.png}
        \label{fig:ml_shap_rf}
        \caption{RF}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/ml_shap_lr.png}
        \label{fig:ml_shap_lr}
        \caption{LR}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/ml_shap_svm.png}
        \label{fig:ml_shap_svm}
        \caption{SVM}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.6\textwidth]{images/ml_shap_gb.png}
        \label{fig:ml_shap_gb}
        \caption{GB}
    \end{subfigure}
    \caption{Ý nghĩa của các đặc trưng lên mô hình}
    \label{fig:ml_shap}

\end{figure}

\newpage

\subsection{Kịch bản kiểm thử}

Lựa chọn đặc trưng là một bước quan trọng trong quá trình xây dựng mô hình học
máy, giúp giảm chiều dữ liệu, cải thiện hiệu quả huấn luyện, rút ngắn thời gian
tính toán và hạn chế hiện tượng quá khớp. Nguyên lý chung là các đặc trưng hiệu
quả phải có mối tương quan cao với mục tiêu là phát hiện tư thế ngủ.

Phân tích ma trận tương quan (Hình~\ref{fig:correlation}) đã cho thấy một số
cặp đặc trưng có mức tương quan rất cao, điển hình như $x_{\mathrm{std}}$ và
$x_{\mathrm{aad}}$ ($r = 0.98$), hay $y_{\mathrm{std}}$ và $y_{\mathrm{aad}}$
($r = 0.68$). Điều này gợi ý rằng có thể loại bỏ một phần các đặc trưng trùng
lặp nhằm giảm độ phức tạp mô hình mà vẫn giữ được thông tin cốt lõi.

Kết hợp với phân tích ở phần trên tác giả chọn lựa được 8 kịch bản bao gồm thay
đổi 3 thông số chính là: độ dài cửa sổ - độ phủ, đặc trưng miền và số lượng đặc
trưng Bảng~\ref{tab:scenarios}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\linewidth]{images/correlation.png}
    \caption{Ma trận tương quan giữa các đặc trưng trích xuất.}
    \label{fig:correlation}
\end{figure}

\begin{table}[htbp]
    \caption{Các kịch bản lựa chọn và sử dụng đặc trưng trong nghiên cứu}
    \label{tab:scenarios}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{Kịch bản} & \textbf{Mô tả}                                                                                                \\
            \hline
            1                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với toàn bộ đặc trưng.                                                      \\
            \hline
            2                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với toàn bộ đặc trưng trong miền thời gian.                                 \\
            \hline
            3                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với toàn bộ đặc trưng trong miền tần số.                                    \\
            \hline
            4                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với đặc trưng miền thời gian, loại bỏ các đặc trưng có tương quan $>$ 95\%. \\
            \hline
            5                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với 15 đặc trưng quan trọng nhất theo giá trị đứng đầu.                     \\
            \hline
            6                 & Dùng cửa sổ 30 mẫu (50\% độ phủ), với 15 đặc trưng đứng đầu.                                                  \\
            \hline
            7                 & Dùng cửa sổ 10 mẫu (50\% độ phủ), với 15 đặc trưng đứng đầu.                                                  \\
            \hline
            8                 & Dùng cửa sổ 20 mẫu (25\% độ phủ), với 15 đặc trưng đứng đầu.                                                  \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\newpage

\subsection{Đánh giá kết quả}
Sau khi xác định các kịch bản, tác giả tiến hành huấn luyện trên cũng một máy
tính và đưa ra kết quả về độ chính xác Hình~\ref{kq_8kb2}.

Cho thấy, kịch bản 3 (màu đỏ) là toàn bộ các đặc trưng trên miền tần số hoàn
toàn không phù hợp để phân loại tư thế ngủ. Điều này cũng được chứng minh tại ở
phần trên. Các mô hình RF và GB luôn cho cho độ chính xác cao nhất và ổn định
nhất ở toàn bộ các bộ dữ liệu huấn luyện. Các kịch bản 5, 6, 7, 8 đựa trên chỉ
15 đặc trưng có vị trí đầu hầu như không thay đổi độ chính xác nhiều. Điều này
cho thấy, việc lựa chọn này phù hợp đối với bài toán tư thế ngủ. Trong kịch bản
6, có độ chính xác cao nhất lên tới 99.84\% đối với mô hình GB với bộ dữ liệu
cửa sổ 30 mẫu. Kịch bản 7 có kết quả ấn tượng nhất. Trong đó, độ chính xác các
mô hình đều được cải thiện rõ rệt ngay cả mô hình LR và SVM. Điều này thực sự
có ý nghĩa vì độ rộng cửa sổ có ảnh hưởng trực tiếp đến việc tính toán, thời
gian phản hồi kết quả trên biên. Với NN như đánh giá trong phần lựa chọn tham
số, khả năng tự trích xuất tính năng từ chỉ 2 lớp ẩn cũng đã cho kết quả đến
98\%, nhưng giảm nhẹ ở tập kiểm tra 95.5\%.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/kq_8kb2.png}}
    \caption{Kết quả độ chính xác của 8 kịch bản}
    \label{kq_8kb2}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_rf_val.png}
        \label{fig:kq_kb7_rf_val}
        \caption{RF trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_rf_test.png}
        \label{fig:kq_kb7_rf_test}
        \caption{RF trên tập kiểm thử}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_val.png}
        \label{fig:kq_kb7_lr_val}
        \caption{SVM trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_test.png}
        \label{fig:kq_kb7_lr_test}
        \caption{SVM trên tập kiểm thử}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_svm_val.png}
        \label{fig:kq_kb7_svm_val}
        \caption{GB trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_gb_test.png}
        \label{fig:kq_kb7_gb_test}
        \caption{GB trên tập kiểm thử}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_val.png}
        \label{fig:kq_kb7_lr_val}
        \caption{LR trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_test.png}
        \label{fig:kq_kb7_lr_test}
        \caption{LR trên tập kiểm thử}
    \end{subfigure}
    \caption{Ma trận nhầm lẫn trong kịch bản 8}
    \label{fig:kq_kb7_confuse}

\end{figure}

Hình~\ref{fig:kq_kb7_confuse} minh họa ma trận nhầm lẫn giữa các mô hình. Qua
đó cho thấy việc sử dụng các đặc trưng vị trí đầu cho kết quả thật sự hiệu quả.
Đây cũng là điểm mới luận văn tìm ra để triển khai bài toán phân loại tư thế
ngủ lên biên.

\section{Triển khai trên vi điều khiển nhúng}

Sau khi hoàn tất quá trình huấn luyện và đánh giá trên máy tính, bước tiếp theo
của nghiên cứu là kiểm chứng khả năng triển khai mô hình trong môi trường thực
tế sử dụng vi điều khiển nhúng. Mục tiêu khoa học ở giai đoạn này không chỉ
dừng ở việc “chạy được” mô hình trên phần cứng hạn chế, mà còn nhằm làm sáng tỏ
mối quan hệ đánh đổi giữa hiệu năng thuật toán và giới hạn tài nguyên của hệ
thống nhúng.

Cụ thể, nghiên cứu tiến hành triển khai song song hai mô hình: mạng nơ-ron nông
(Neural Network – NN) với khả năng biểu diễn phi tuyến mạnh mẽ, và hồi quy
logistic (Logistic Regression – LR) với cấu trúc tuyến tính cực kỳ gọn nhẹ. NN
được kỳ vọng duy trì độ chính xác cao trong phân loại tư thế ngủ, trong khi LR
đóng vai trò như một đối chứng quan trọng, minh chứng cho khả năng đạt được sự
cân bằng tối ưu giữa độ chính xác vừa đủ và mức tiêu thụ tài nguyên tối thiểu.

Điều này cho thấy trong bối cảnh phần cứng hạn chế, giá trị khoa học không nằm ở việc đạt độ chính xác tuyệt đối trong điều kiện lý tưởng, mà ở khả năng thiết kế một mô hình “đủ tốt” nhưng có thể vận hành bền vững trên chip. Chính sự đánh đổi này khẳng định nguyên lý cốt lõi của TinyML: hy sinh một phần nhỏ về độ chính xác để đổi lấy tính khả thi, hiệu quả năng lượng và độ tin cậy trong môi trường thực.

Kết quả cũng cho thấy sự song hành giữa hai mô hình được lựa chọn. Mạng nơ-ron
(NN) duy trì độ chính xác cao nhưng tiêu tốn nhiều tài nguyên, trong khi hồi
quy logistic (LR) có dung lượng siêu nhỏ, tốc độ suy luận nhanh, và vẫn giữ mức
chính xác tiệm cận. Việc triển khai song song cả NN và LR trên chip vì vậy
không chỉ mang ý nghĩa kiểm chứng kỹ thuật, mà còn cung cấp bằng chứng khoa học
cho thấy ranh giới cân bằng giữa “độ chính xác tối đa” và “khả năng ứng dụng
thực tế” trong hệ thống nhúng y sinh.

\subsection{Quy trình triển khai mô hình}

Dựa trên các kết quả phân tích và đánh giá ở giai đoạn~1, tác giả quyết định
bước sang giai đoạn~2 với mục tiêu triển khai thực tế trên phần cứng nhúng. Như
đã trình bày, hai mô hình được lựa chọn cho thử nghiệm là \textbf{Neural
    Network (NN)} và \textbf{Logistic Regression (LR)}, bởi chúng đáp ứng tốt yêu
cầu về tính gọn nhẹ và khả năng triển khai trên vi điều khiển.

Quy trình triển khai bao gồm các bước sau:
\begin{enumerate}
    \item \textbf{Xác định vi điều khiển mục tiêu}: lựa chọn nền tảng phần cứng phù hợp với giới hạn bộ nhớ và khả năng tính toán.
    \item \textbf{Thu thập lại dữ liệu trực tiếp trên vi điều khiển}: đảm bảo dữ liệu phản ánh đúng điều kiện hoạt động của phần cứng thực tế, tránh sai lệch do khác biệt môi trường so với giai đoạn mô phỏng.
    \item \textbf{Huấn luyện lại mô hình}: sử dụng bộ dữ liệu thu thập mới để tinh chỉnh và tái huấn luyện, nhằm tối ưu hóa mô hình cho nền tảng phần cứng được chọn.
    \item \textbf{Chuyển đổi mô hình sang mã C/C++}: áp dụng các công cụ biên dịch và chuyển đổi chuyên dụng để xuất mô hình dưới dạng mã nguồn có thể nhúng trực tiếp.
    \item \textbf{Triển khai trên chip}: nạp mã nguồn vào vi điều khiển, bộ lọc, kiểm tra khả năng suy luận và hiệu năng thời gian thực.
\end{enumerate}

Vi điều khiển được lựa chọn là \textbf{Arduino Nano 33 BLE Sense}, sử dụng chip
\texttt{nRF52840} (ARM Cortex-M4F, 64~MHz), 1~MB flash và 256~KB RAM. Bo mạch
này cũng tích hợp sẵn cảm biến gia tốc, rất phù hợp để xây dựng hệ thống nhận
diện tư thế ngủ hoàn chỉnh và hoạt động độc lập.

Qua nhiều lần triển khai thực nghiệm trực tiếp trên vi điều khiển, tác giả đã
rút ra một kết luận quan trọng: việc \textbf{giảm số lượng mẫu huấn luyện} kết
hợp với \textbf{rút gọn tập đặc trưng} mang lại hiệu quả rõ rệt trong việc tối
ưu mô hình cho môi trường nhúng. Cụ thể, các mô hình sau khi được tinh giản có
\emph{kích thước tệp nhỏ hơn}, \emph{mức sử dụng bộ nhớ giảm đáng kể}, và
\emph{thời gian suy luận nhanh hơn}, nhưng độ chính xác chỉ suy giảm ở mức rất
nhỏ và hoàn toàn nằm trong ngưỡng chấp nhận được đối với ứng dụng thực tế. Điều
này chứng tỏ rằng, trong bối cảnh triển khai Edge AI, sự đánh đổi giữa số lượng
đặc trưng và hiệu năng mô hình có thể được cân bằng một cách hợp lý, từ đó vừa
đảm bảo tính khả thi trên phần cứng hạn chế, vừa duy trì độ tin cậy trong dự
đoán.

Đặc biệt, ở \textbf{bước 2 của quy trình}, tác giả đã tiến hành \emph{thu thập lại 10.430 mẫu dữ liệu}
trực tiếp từ thiết bị \textbf{Arduino Nano 33 BLE Sense}.
Khác với bộ dữ liệu mô phỏng trên máy tính, tập dữ liệu này phản ánh sát thực tế điều kiện hoạt động của phần cứng,
bao gồm cả đặc điểm nhiễu, độ trễ và sai số phép đo.
Nhờ vậy, việc huấn luyện lại mô hình trên tập dữ liệu thực nghiệm giúp tăng tính tương thích giữa mô hình và nền tảng nhúng,
giảm thiểu nguy cơ sai lệch do khoảng cách giữa môi trường mô phỏng và môi trường thực thi.

Trong quá trình triển khai thực tế, tác giả tiến hành hai hướng tiếp cận riêng
biệt tương ứng với hai mô hình đã được lựa chọn từ giai đoạn~1:
\textbf{Logistic Regression (LR)} và \textbf{Neural Network (NN)}.

\begin{itemize}
    \item \textbf{Đối với LR:} sau khi huấn luyện lại mô hình trên tập dữ liệu thu thập từ Arduino Nano 33,
          toàn bộ tham số bao gồm trọng số, hệ số bias và giá trị chuẩn hoá (min, max, scale)
          được xuất trực tiếp sang mã C/C++. Cách tiếp cận này cho phép mô hình LR
          được biểu diễn dưới dạng các mảng hằng số \texttt{const float[]} trong chương trình Arduino,
          từ đó vi điều khiển có thể tính toán đầu ra bằng phép nhân ma trận và cộng bias đơn giản.
          Việc xuất mô hình theo phương thức này đảm bảo kích thước file rất nhỏ (chỉ vài kilobyte)
          và suy luận có thể thực hiện nhanh chóng mà không phụ thuộc vào thư viện học máy phức tạp.

    \item \textbf{Đối với NN:} mô hình được thiết kế với hai lớp ẩn (8 và 4 nơ-ron),
          sử dụng hàm kích hoạt ReLU và lớp đầu ra Softmax. Sau khi huấn luyện,
          mô hình được chuyển đổi sang định dạng \textbf{TensorFlow Lite (TFLite)} bằng công cụ \texttt{TFLiteConverter}.
          File nhị phân \texttt{.tflite} sau đó được ánh xạ sang mã C thông qua tiện ích \texttt{xxd -i},
          tạo thành một mảng byte \texttt{const unsigned char[]} để nạp trực tiếp vào bộ nhớ của vi điều khiển.
          Cách tiếp cận này cho phép duy trì toàn bộ cấu trúc của mạng nơ-ron,
          đồng thời tận dụng khả năng tối ưu hoá suy luận của TensorFlow Lite trên nền tảng nhúng.
\end{itemize}

Sự khác biệt giữa hai phương pháp này phản ánh bản chất của từng mô hình: LR
dựa trên phương trình tuyến tính với đặc trưng đã trích xuất, nên việc chuyển
đổi tham số sang C/C++ là tối ưu và gọn nhẹ nhất. Ngược lại, NN có cấu trúc phi
tuyến và nhiều lớp, do đó cần sử dụng định dạng TFLite để đóng gói toàn bộ mô
hình dưới dạng nhị phân, vừa đảm bảo tính toàn vẹn, vừa khai thác được khả năng
tối ưu hoá suy luận trên chip.

Qua đó, luận án đã thiết lập được hai quy trình triển khai hoàn chỉnh: (i) LR
với mô hình tuyến tính tối giản, phù hợp với các hệ thống nhúng cực kỳ hạn chế
tài nguyên; (ii) NN với mô hình phi tuyến phức tạp hơn, tận dụng TFLite để cân
bằng giữa độ chính xác và tốc độ suy luận.

Trong bước triển khai thực tế, mô hình Logistic Regression (LR) được ánh xạ
trực tiếp sang mã C/C++ thông qua ba thành phần chính: (i) tệp \texttt{model.h}
lưu trữ toàn bộ tham số huấn luyện (trọng số, hệ số bias, giá trị chuẩn hoá);
(ii) tệp \texttt{predict.h} định nghĩa cơ chế suy luận bằng phép tính tuyến
tính kết hợp Softmax; và (iii) chương trình chính điều khiển cảm biến, trích
xuất đặc trưng, chuẩn hoá và gọi hàm dự đoán. Cách tổ chức này giúp mô hình
hoạt động độc lập hoàn toàn trên vi điều khiển mà không cần bất kỳ thư viện học
máy ngoài nào.

Thực nghiệm cho thấy toàn bộ quá trình suy luận được thực hiện chỉ với các phép
toán cơ bản (\emph{cộng, nhân, căn bậc hai, hàm mũ}), tiêu tốn rất ít tài
nguyên tính toán và đạt thời gian xử lý ở mức micro giây cho mỗi cửa sổ dữ
liệu. Điều này khẳng định tính phù hợp của LR trong bối cảnh triển khai trên
thiết bị nhúng có bộ nhớ và công suất xử lý hạn chế.

Từ góc độ khoa học, việc triển khai LR theo cách này minh chứng rằng một mô
hình học máy có thể được rút gọn thành tập tham số tĩnh và tái hiện chính xác
trên chip, đồng thời duy trì độ chính xác ở mức chấp nhận được cho ứng dụng
giám sát sức khoẻ thời gian thực. Chiến lược \textbf{tối giản mô hình} này là
minh chứng rõ rệt cho tính khả thi của Edge AI: đảm bảo độ trễ thấp, tính riêng
tư dữ liệu và khả năng vận hành bền vững trong môi trường hạn chế tài nguyên.

Khác với LR, mô hình Neural Network (NN) được triển khai trên chip thông qua
định dạng \textbf{TensorFlow Lite Micro (TFLM)}. Sau khi huấn luyện, mô hình
Keras được chuyển đổi sang tệp nhị phân \texttt{.tflite} và sau đó nhúng trực
tiếp vào chương trình Arduino dưới dạng mảng byte (\texttt{const unsigned char
    model[]}). Việc này cho phép vi điều khiển thực thi suy luận với sự hỗ trợ của
thư viện TFLM, vốn đã được tối ưu hóa cho các hệ thống nhúng có bộ nhớ giới
hạn.

Trong chương trình triển khai, bộ gia tốc của Arduino Nano 33 BLE Sense cung
cấp dữ liệu ba trục $(x, y, z)$ liên tục. Tiếp đó dữ liệu được chuẩn hóa để bảo
đảm sự tương thích với dải giá trị đầu vào mà mô hình đã được huấn luyện.

Khối \texttt{MicroInterpreter} trong TFLM chịu trách nhiệm phân bổ bộ nhớ, thực
thi các toán tử (Dense, ReLU, Softmax), và trả về xác suất dự đoán cho từng lớp
tư thế (\emph{ngửa, nghiêng trái, nghiêng phải, sấp}). Kết quả cuối cùng được
xác định bằng cách chọn lớp có xác suất cao nhất.

Ý nghĩa khoa học của phương thức triển khai này nằm ở chỗ:
thay vì trích xuất đặc trưng thủ công như với LR, NN có khả năng \textbf{học trực tiếp từ dữ liệu thô},
từ đó giảm thiểu sự phụ thuộc vào các bước tiền xử lý.
Mặc dù chi phí tính toán cao hơn,
NN có ưu thế trong việc nắm bắt quan hệ phi tuyến
phức tạp giữa các tín hiệu.

Như vậy, hai mô hình LR và NN phản ánh hai chiến lược bổ sung cho nhau: LR tối
giản, phù hợp khi ưu tiên tốc độ và tài nguyên, trong khi NN khai thác tối đa
dữ liệu thô nhờ khả năng biểu diễn phi tuyến, phù hợp cho các ứng dụng đòi hỏi
độ chính xác cao và tính khái quát.

\subsection{Đánh giá hiệu suất và tài nguyên}

Các thí nghiệm được tiến hành trên vi điều khiển nRF52840 và được so sánh trong
điều kiện triển khai thực tế. Ngoài ra, để đảm bảo tính khách quan và khả năng
tái lập, toàn bộ quá trình huấn luyện mô hình, biên dịch chương trình và nạp
xuống vi điều khiển được thực hiện trên một máy tính xách tay có cấu hình phần
cứng như sau:

\begin{itemize}
    \item \textbf{Bộ xử lý (CPU):} Intel(R) Core(TM) Ultra 5 226V, tốc độ xung nhịp $2.10$~GHz.
    \item \textbf{Bộ nhớ trong (RAM):} $16.0$~GB DDR5, tốc độ $8533$~MT/s.
    \item \textbf{Ổ lưu trữ (Storage):} SSD dung lượng $954$~GB (trong đó đã sử dụng $188$~GB).
    \item \textbf{Card đồ họa (GPU):} Intel(R) Arc(TM) 130V, dung lượng bộ nhớ đồ hoạ $8$~GB (VRAM khả dụng $128$~MB cho hệ thống).
\end{itemize}

Việc mô tả chi tiết môi trường phần cứng nhằm giúp đảm bảo tính minh bạch, đồng
thời cung cấp thông tin tham chiếu để các nghiên cứu sau có thể so sánh hoặc
tái hiện kết quả. Trong bối cảnh học máy nhúng, hiệu năng biên dịch và tốc độ
nạp chương trình phụ thuộc không chỉ vào kiến trúc của vi điều khiển mà còn
chịu ảnh hưởng từ cấu hình máy tính host, do đó việc báo cáo chi tiết hệ thống
thử nghiệm là cần thiết.

Bảng \ref{tab:comparison_full} trình bày sự so sánh chi tiết giữa Logistic
Regression (LR) và Neural Network (NN) khi triển khai trên vi điều khiển
nRF52840. Ngoài các tiêu chí về dung lượng bộ nhớ và độ phức tạp, kết quả thực
nghiệm còn chỉ ra sự khác biệt rất lớn về \textbf{hiệu năng suy luận}. Cụ thể,
mô hình LR đạt thời gian xử lý trung bình $501~\mu s$ trên mỗi mẫu, trong khi
NN mất tới $8000~\mu s$, tức là chậm hơn khoảng $16$ lần. Đây là một yếu tố
quan trọng, đặc biệt trong các ứng dụng \textit{real-time} nơi độ trễ (latency)
quyết định khả năng đáp ứng của hệ thống.

\begin{table}[H]
    \centering
    \caption{So sánh hiệu năng Logistic Regression và Neural Network trên nRF52840}
    \label{tab:comparison_full}
    \begin{tabular}{|l|p{5cm}|p{6cm}|}
        \hline
        \textbf{Tiêu chí}        & \textbf{Logistic Regression (LR)} & \textbf{Neural Network (NN)}                  \\ \hline
        Dung lượng Flash sử dụng & 115,208 bytes (11\%)              & 363,520 bytes (36\%)                          \\ \hline
        Dung lượng RAM sử dụng   & 46,632 bytes (17\%)               & 60,672 bytes (23\%)                           \\ \hline
        Thời gian upload         & 4.9 s (29 pages)                  & 15 s (89 pages)                               \\ \hline
        Độ phức tạp mô hình      & Thấp (1 lớp tuyến tính)           & Trung bình -- cao (nhiều lớp fully connected) \\ \hline
        Sức mạnh biểu diễn       & Hạn chế (chỉ quan hệ tuyến tính)  & Cao (biểu diễn quan hệ phi tuyến)             \\ \hline
        Ổn định trên MCU         & Ổn định                           & Ổn định                                       \\ \hline
        Thời gian suy luận       & 501~$\mu s$                       & 8000~$\mu s$                                  \\ \hline
    \end{tabular}
\end{table}

Kết quả cho thấy LR có ưu thế vượt trội về tốc độ và mức tiêu thụ tài nguyên,
điều này khiến LR đặc biệt thích hợp cho các hệ thống nhúng giới hạn phần cứng
và yêu cầu phản hồi tức thời (ví dụ: phân loại tư thế ngủ). Tuy nhiên, NN lại
có khả năng khai thác tốt hơn các quan hệ phi tuyến giữa dữ liệu cảm biến, giúp
tăng độ chính xác trong các bài toán phức tạp như nhận diện chuyển động liên
tục hoặc phân loại đa trạng thái.

Điểm mấu chốt ở đây là \textbf{sự đánh đổi giữa tốc độ và khả năng biểu diễn}: LR nhanh và nhẹ, nhưng hạn chế về năng lực mô hình; trong khi NN tiêu tốn nhiều tài nguyên hơn, song mang lại độ chính xác cao và khả năng tổng quát hóa mạnh mẽ. Do đó, việc lựa chọn mô hình không mang tính tuyệt đối, mà cần được cân nhắc dựa trên mục tiêu ứng dụng: \textit{ưu tiên thời gian thực và tiết kiệm năng lượng} (chọn LR) hoặc \textit{ưu tiên độ chính xác và khả năng mở rộng} (chọn NN).

\subsection*{Hướng phát triển tương lai}
Trong tương lai, hệ thống có thể được mở rộng theo hướng \textbf{tích hợp đa
    cảm biến} (multi-sensor fusion), thay vì chỉ dựa trên gia tốc kế đơn lẻ. Cụ
thể, việc bổ sung thêm các cảm biến như \textit{cảm biến nhịp tim (PPG/ECG),
    cảm biến SpO$_2$, cảm biến hô hấp (respiratory effort), hoặc microphone áp suất
    âm thanh} sẽ cung cấp nhiều kênh dữ liệu sinh lý hơn, từ đó hỗ trợ phân tích
toàn diện về chất lượng giấc ngủ.

Mục tiêu xa hơn là hướng tới \textbf{bài toán phát hiện sớm và theo dõi ngưng
    thở tắc nghẽn khi ngủ (Obstructive Sleep Apnea – OSA)}. Đặc trưng của OSA không
chỉ thể hiện qua tư thế ngủ, mà còn gắn liền với các tín hiệu sinh lý như giảm
oxy máu, sự thay đổi nhịp tim, và các chu kỳ hô hấp bất thường. Việc kết hợp dữ
liệu tư thế ngủ với các chỉ số sinh lý học quan trọng có thể cho phép mô hình
nhận diện các giai đoạn ngưng thở hoặc thở nông, vốn là dấu hiệu lâm sàng đặc
trưng của OSA.

Hướng nghiên cứu này cũng mở ra những thách thức về \textbf{tối ưu hoá mô hình}
để đảm bảo hệ thống vẫn vận hành được trên phần cứng nhúng giới hạn tài nguyên.
Điều này đòi hỏi chiến lược như \textit{quantization, pruning, knowledge
    distillation}, hoặc thậm chí triển khai các kiến trúc chuyên biệt như
\textit{TinyCNN} hay \textit{RNN nhẹ} nhằm xử lý dữ liệu chuỗi thời gian đa
kênh. Do đó, nghiên cứu trong giai đoạn tiếp theo không chỉ tập trung vào độ
chính xác mô hình, mà còn cần chú trọng đến khả năng triển khai thực tiễn trong
môi trường chăm sóc sức khỏe từ xa (telehealth) và thiết bị đeo thông minh
(wearable devices).