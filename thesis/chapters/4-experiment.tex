Trong phần này, tác giả trình bày nhưng kết quả đã đạt được dựa trên các cơ sở
lý thuyết trong hai chương đã trình bày phần trước. Kết quả sẽ được trình bày
đúng theo trình tự mục tiêu của luận văn: Đầu tiên là kết quả nghiên cứu, phát
triển phần cứng. Thứ hai, kết quả đánh giá dữ liệu cảm biến bằng học máy. Cuối
cùng là kết quả triển khai trên biên.

\section{Hệ thống thu thập, lưu trữ}

Hình~\ref{fig:mach} là kết quả mạch đã hoàn thiện. Mạch đã được nhóm kiểm tra
hoạt đồng đúng theo yêu cầu các thành phần theo như thiết kế. Nạp bootloader và
tiến hành nạp code cho vi điều khiển qua USB.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/mach.png}
    \caption{Mạch hoàn chỉnh}
    \label{fig:mach}
\end{figure}

Ngoài cách cấp nguồn trực tiếp thông qua USB, tác giả còn gắn thêm viên pin
lipo có dải điện áp trung bình là 3.7 V và tối thiểu là 3V có kích thước là 20
mm * 20 mm * 5 mm tại mạch sau của mạch để thuận lợi hơn trong quá trình lấy
mẫu.

Song song với việc phát triển phần cứng, phần mềm cũng được hoàn thành với đầy
đủ các tính năng như yêu cầu trước đó đưa ra bao gồm cả ứng dụng di dộng và máy
chủ đám mây. Dựa trên phản hồi từ nhóm nghiên cứu, tư vấn khoa học của Thầy
PGS.TS. Mai Anh Tuấn, tư vấn y khoa của Thầy GS.TS. Dương Quý Sỹ, ứng dụng được
thiết kế với tiêu chí giao diện thân thiện, thao tác đơn giản và tính năng tập
trung vào mục tiêu thử nghiệm.

Sau khi cài đặt, người dùng có thể đăng nhập hoặc đăng ký tài khoản thông qua
giao diện như được thể hiện trong Hình~\ref{appAuth}. Với người dùng mới, quá
trình đăng ký yêu cầu xác thực địa chỉ email nhằm đảm bảo bảo mật và hỗ trợ
tính năng khôi phục tài khoản. Hình~\ref{appsleep} minh họa giao diện của các
chức năng, Chatbot hỗ trợ người dùng trong quá trình sàng lọc nguy cơ ngưng thở
khi ngủ và cung cấp thông tin về chất lượng giấc ngủ.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/appsleep.png}
    \caption{Giao diện chức năng chatbot và bộ câu hỏi tầm soát}
    \label{appsleep}
\end{figure}

Hình ~\ref{listble} thể hiện danh sách BLE có thể kết nối và dịch vụ kết nối
với phần cứng đã được nhắc tới bên trên. Khi người chọn vào BLE có tên là
MASTER\_2025\_BLE ứng dụng di động xuất thêm màn hình chọn cảm biến thu thập.
Đây cũng có thể coi là bước chọn đúng UUID của dịch cụ GATT đã được cấu hình
sẵn ở phần cứng.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/appAuth.png}
    \caption{Giao diện chức năng đăng ký và đăng nhập}
    \label{appAuth}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.4\textwidth]{images/ketqua_capquyen.jpg}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.4\textwidth]{images/ketqua_scan.jpg}
    \end{subfigure}
    \caption{Màn hình yêu cầu quyền truy cập Bluetooth và danh sách thiết bị đang hoạt động}
    \label{fig:ketqua_scan}
\end{figure}

Khi chọn đọc giá trị cảm biến, ứng dụng di động sẽ tự động truy cập vào đặc
tính trong dịch vụ. Hình~\ref{ketqua_bieudoxyz} minh họa giao diện hiển thị giá
trị cảm biến theo thời gian thực và Hình~\ref{ketqua_mongo} thể hiện giá trị
cảm biến đã được lưu vào cơ sở dữ liệu. Ngoài ra, dữ liệu về tư thế hiện tại và
số lượng tư thế ngủ được tính toán dựa vào suy luận kết quả mô hình đã huấn
luyện trên máy chủ trung tâm.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\linewidth]{images/ketqua_bieudoxyz.jpg}
    \caption{Màn hình hiển thị dữ liệu gia tốc ba trục với hoàng là giá trị thời gian, trục tung là giá trị cảm biến gấp lên 10 lần }
    \label{ketqua_bieudoxyz}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/ketqua_mongo.png}
    \caption{Dữ liệu cảm biến gia tốc được lưu trong cơ sở dữ liệu}
    \label{ketqua_mongo}
\end{figure}

\newpage

\section{Thu thập và gắn nhãn dữ liệu}

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/4position.png}}
    \caption{Mô phỏng thực nghiệm thực tế}
    \label{4Position}
\end{figure}

Trong phần này, tác giả trình bày chi tiết phương pháp thu thập dữ liệu, các
kịch bản thực nghiệm, cũng như quy trình xử lý và trích xuất đặc trưng để phục
vụ cho việc huấn luyện các mô hình học máy trong bài toán nhận diện tư thế ngủ.

Tổng cộng 25 tình nguyện viên đã được tuyển chọn tham gia vào quá trình thu
thập dữ liệu, với độ tuổi dao động từ 10 đến 60, trong đó độ tuổi phổ biến là
24. Nhóm tình nguyện viên bao gồm cả nam và nữ, được lựa chọn với tiêu chí đa
dạng về giới tính và độ tuổi nhằm tăng tính đại diện và khách quan cho bộ dữ
liệu.

Trong kịch bản đầu tiên (gọi là \textbf{thu thập có giám sát}), mỗi tình nguyện
viên được hướng dẫn gắn thiết bị cảm biến vào vùng cổ bằng băng keo y tế hai
mặt 3M, sau đó đăng nhập vào ứng dụng di động với tài khoản cá nhân đã đăng ký.
Dưới sự giám sát trực tiếp của tác giả, mỗi người tham gia sẽ lần lượt thực
hiện các tư thế ngủ cơ bản (nằm ngửa, nằm sấp, nghiêng trái, nghiêng phải)
trong thời gian tối thiểu 2 phút cho mỗi tư thế Hình~\ref{4Position}. Mỗi tư
thế được lặp lại ít nhất hai lần để đảm bảo tính lặp lại và ổn định của tín
hiệu. Sau khi xác minh rằng dữ liệu cảm biến đã được lưu trữ đầy đủ trên hệ
thống (kiểm tra trên MongoDB và giao diện ứng dụng), quá trình thu thập dữ liệu
từ một tình nguyện viên được xem là hoàn tất.

Bên cạnh đó, để mô phỏng điều kiện thực tế khi sử dụng thiết bị trong sinh hoạt
ban đêm, tác giả đã tự thực hiện kịch bản thứ hai (\textbf{thu thập trong giấc
    ngủ tự nhiên}). Trong kịch bản này, thiết bị được gắn vào cổ trước khi đi ngủ
và ghi nhận dữ liệu liên tục trong suốt một đêm. Song song đó, một camera cố
định được lắp đặt phía trên giường để ghi hình toàn bộ quá trình ngủ, từ đó hỗ
trợ gán nhãn chính xác theo thời gian. Dữ liệu trong giai đoạn này được xử lý
và đồng bộ thủ công giữa tín hiệu cảm biến và video để loại bỏ các đoạn có
chuyển động hoặc sai lệch nhãn.

Mặc dù phương pháp thu thập trong môi trường tự nhiên sát với điều kiện sử dụng
thực tế, nhưng đòi hỏi nhiều công sức xử lý hậu kỳ và khó kiểm soát chất lượng
dữ liệu đầu vào. Theo ý kiến tư vấn từ các chuyên gia trong lĩnh vực y học giấc
ngủ, phương pháp thu thập có giám sát (phương pháp 1) vẫn được ưu tiên do khả
năng kiểm soát tốt, đảm bảo dữ liệu cân bằng giữa các tư thế, đồng thời vẫn duy
trì được mức độ tương thích cao với điều kiện thực tế khi triển khai ứng dụng
theo dõi tại nhà.

Sau quá trình thu thập, bộ dữ liệu huấn luyện bao gồm tổng cộng \textbf{158.750
    mẫu} hợp lệ sau khi đã lọc nhiễu và loại bỏ các phiên ghi nhận không đạt yêu
cầu của 25 tình nguyện viên. Dữ liệu kiểm thử được loại bỏ các hoạt động không
thuộc tư thế ngủ và gắn nhãn dựa trên camera. Kết quả là bộ dữ liệu kiểm thử
gồm \textbf{64.258 mẫu}.

Tất cả dữ liệu thu thập từ các tình nguyện viên và tác giả đều được xuất ra
định dạng \texttt{CSV}, bao gồm thông tin thời gian (timestamp), giá trị cảm
biến trên ba trục $x$, $y$, $z$, và nhãn tư thế tương ứng (nếu có). Dữ liệu này
được sử dụng làm đầu vào cho quá trình trích xuất đặc trưng và huấn luyện mô
hình học máy.

\section{Phân loại tư thế ngủ bằng học máy}

\subsection{Phân tích dữ liệu}
Sau khi hoàn thành quá trình thu thập dữ liệu của hai kịch bản, tác giả tiến
hành phân tích các giá trị cảm biến của ba trục. Đâu tiên phân tích độ cân bằng
dữ liệu như Hình~\ref{fig:ana_balance}.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_balance_train.png}
        \label{fig:ana_balance_train}
        \caption{tập huấn luyện}

    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_balance_test.png}
        \label{fig:ana_balance_test}
        \caption{tập kiểm thử}
    \end{subfigure}
    \caption{Biểu đồ phân bố các nhãn thu được}
    \label{fig:ana_balance}
\end{figure}

Hình~\ref{fig:ana_balance} cho thấy phân bố dữ liệu của tập huấn luyện tương
đối cân bằng. Còn đối với tập kiểm thử, tư thế nằm ngửa và nghiêng trái chiếm
đa số. Qua đó, cho thấy sự phản ánh dữ liệu đúng như dự kiến của tác giả. Với
bộ huấn luyện, các nhãn sẽ giữ ở mức cân bằng để tránh tình trạng quá khớp. Còn
ở tập kiểm thử, các nhãn phản ánh đúng sinh lý của cá nhân khi ngủ, sẽ thường
có những tư thế nổi bật hẳn về số lượng do thói quen.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_distribute_train.png}
        \label{fig:ana_distribute_train}
        \caption{tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/ana_distribute_test.png}
        \label{fig:ana_distribute_test}
        \caption{tập kiểm thử}
    \end{subfigure}
    \caption{Biểu đồ phân bố dữ liệu 3 trục theo các tư thế ngủ}
    \label{fig:ana_distribute}
\end{figure}

Hình~\ref{fig:ana_distribute} (a) trình bày phân tích chi tiết phân bố tín hiệu
cảm biến theo ba trục gia tốc ứng với bốn tư thế ngủ cơ bản của tập huấn luyện
thu từ 25 tình nguyện viên. Ở trục $x$, các phân bố tương đối biệt lập, giữa
hai tư thế nằm ngửa và nằm sấp, cũng như giữa nghiêng trái và nghiêng phải.
Điều này cho thấy trục $x$ có khả năng phân biệt tư thế tốt. Trục $y$ thể hiện
mức độ tương đồng giữa các tư thế, dẫn đến khả năng tách biệt thấp và ít giá
trị trong việc xác định tư thế ngủ. Đối với trục $z$, có thể quan sát được sự
phân tách rõ ràng giữa tư thế nằm nghiêng và các tư thế dọc (nằm ngửa và nằm
sấp), chứng tỏ vai trò quan trọng của trục $z$ trong phân loại tư thế. Còn đối
với Hình~\ref{fig:ana_distribute} (b), các phân bố về trung bình cũng tương
đồng với tập huấn luyện cho thấy sự phản ánh đúng phương pháp lấy mẫu mang tính
đúng đắn. Tuy nhiên, giải phân phối của tập kiểm thử tương đối rộng, nguyên
nhân được suy đoán là do các tín hiệu nhiễu chưa được sàng lọc kĩ ở bước làm
sạch dữ liệu và gắn nhãn. Đây là cũng trường hợp không hiếm gặp trong khi ngủ
thực tế cả đêm, con người cí thể có các hoạt động khác như là đi vệ sinh hay là
uống nước. Đây cũng là thách thức tác giả cần giải quyết phát hiện đang nằm ngủ
hay đang không nằm.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/ana_distribute_z.png}}
    \caption{Phân bố giá trị trục x của 2 tập dữ liệu}
    \label{ana_distribute_z}
\end{figure}

Hình~\ref{ana_distribute_z} chỉ ra phân bố giá trị trục z của hai tập dữ liệu:
huấn luyện (xanh) và kiểm thử (cam). Cho thầy, mật độ đỉnh ở hai tập dữ liệu
khá tương đồng. Điều này cũng được chính minh ở phần trên. Tuy nhiên, có một số
điểm khác biệt tại giá trị -0.5 của tập kiểm thử. Giá trị này rơi chủ yếu vào
tư thế nằm nghiêng trái và nắm sập. Từ đây, tác giả phỏng đoán sẽ có nhầm lẫn
trong suy luận giữa 2 tư thế này tại tập kiểm thử.

\subsection{Xử lý và trích xuất đặc trưng}

Dữ liệu cảm biến thu thập được trước tiên được xử lý khử nhiễu bằng phương pháp
hiệu chỉnh điểm gốc, bằng cách lấy hiệu giữa giá trị hiện tại và giá trị tham
chiếu ban đầu trên ba trục $x$, $y$, và $z$. Sau đó, tín hiệu được chia thành
các cửa sổ thời gian có độ dài 2 giây, với mức chồng lấn 50\% giữa các cửa sổ.
Chỉ những cửa sổ dữ liệu có nhãn nhất quán trong toàn bộ thời gian mới được giữ
lại để huấn luyện mô hình. Các cửa sổ chứa nhãn không đồng nhất (nhiều hơn một
nhãn) hoặc có biểu hiện chuyển động bất thường sẽ bị loại bỏ khỏi quá trình xử
lý tiếp theo.

\begin{table}[htbp]
    \caption{Các đặc trưng thống kê và tín hiệu được sử dụng trong phân loại tư thế ngủ}
    \label{tab:features}
    \begin{center}
        \renewcommand{\arraystretch}{1.5}
        \begin{tabular}{|l|p{9.5cm}|}
            \hline
            \textbf{Đặc trưng}            & \textbf{Mô tả / Công thức}                                         \\
            \hline
            Giá trị trung bình            & $\mu_s = \frac{1}{n} \sum_{i=1}^{n} S_i$                           \\
            \hline
            Độ lệch chuẩn                 & $\sigma_s = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (S_i - \mu_s)^2}$     \\
            \hline
            Độ lệch tuyệt đối trung bình  & $\text{AAD} = \frac{1}{n} \sum_{i=1}^{n} |S_i - \mu_s|$            \\
            \hline
            Giá trị nhỏ nhất              & $\min(s) = \min(S_1, S_2, \ldots, S_n)$                            \\
            \hline
            Giá trị lớn nhất              & $\max(s) = \max(S_1, S_2, \ldots, S_n)$                            \\
            \hline
            Hiệu số lớn nhất - nhỏ nhất   & $\max(s) - \min(s)$                                                \\
            \hline
            Trung vị                      & $\text{Median}(s) = \text{median}(S_1, S_2, \ldots, S_n)$          \\
            \hline
            Độ lệch tuyệt đối trung vị    & $\text{MAD} = \frac{1}{n} \sum_{i=1}^{n} |S_i - \text{Median}(s)|$ \\
            \hline
            Khoảng tứ phân vị             & $IQR = \text{percentile}(75) - \text{percentile}(25)$              \\
            \hline
            Số giá trị âm                 & $\#(S_i < 0)$                                                      \\
            \hline
            Số giá trị dương              & $\#(S_i > 0)$                                                      \\
            \hline
            Số giá trị lớn hơn trung bình & $\#(S_i > \mu_s)$                                                  \\
            \hline
            Số đỉnh (local maxima)        & Số lượng điểm cực đại cục bộ trong chuỗi tín hiệu                  \\
            \hline
            Độ lệch (Skewness)            & $\frac{1}{n \sigma_s^3} \sum_{i=1}^{n} (S_i - \mu_s)^3$            \\
            \hline
            Độ nhọn (Kurtosis)            & $\frac{1}{n \sigma_s^4} \sum_{i=1}^{n} (S_i - \mu_s)^4$            \\
            \hline
            Năng lượng tín hiệu           & $\sum_{i=1}^{n} S_i^2$                                             \\
            \hline
            Gia tốc tổng hợp trung bình   & $\frac{1}{n} \sum_{i=1}^{n} \sqrt{x_i^2 + y_i^2 + z_i^2}$          \\
            \hline
            Tổng độ lớn tín hiệu (SMA)    & $\frac{1}{n} \sum_{i=1}^{n} (|x_i| + |y_i| + |z_i|)$               \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\subsubsection{Đặc trưng miền thời gian (T1)}\label{AA}

Dữ liệu cảm biến gia tốc là dữ liệu chuỗi thời gian, do đó các đặc trưng miền
thời gian đóng vai trò rất quan trọng trong nhận diện tư thế ngủ. Trong nghiên
cứu này, tác giả trích xuất tổng cộng 40 đặc trưng thống kê cho mỗi cửa sổ dữ
liệu, trên cả ba trục $x$, $y$, $z$. Các đặc trưng bao gồm giá trị trung bình,
độ lệch chuẩn, độ lệch tuyệt đối trung bình, giá trị lớn nhất, nhỏ nhất, hiệu
số lớn-nhỏ nhất, trung vị, độ lệch tuyệt đối trung vị, khoảng tứ phân vị, số
lượng giá trị âm/dương, số lượng giá trị lớn hơn trung bình, số đỉnh tín hiệu,
độ lệch, độ nhọn, năng lượng tín hiệu, gia tốc tổng hợp và tổng độ lớn tín
hiệu. Các đặc trưng này được lựa chọn dựa trên tính dễ tính toán, hiệu quả phân
tách tư thế và khả năng triển khai trên vi điều khiển.

\subsubsection{Đặc trưng miền tần số (F1)}\label{AA}

Để khai thác thông tin trong miền tần số, tác giả sử dụng Biến đổi Fourier Nhanh (FFT) để chuyển đổi dữ liệu từ miền thời gian sang miền tần số. Từ các cửa sổ tín hiệu sau biến đổi, 29 đặc trưng thống kê được tính toán, bao gồm các đặc trưng tương tự như trong miền thời gian: trung bình, độ lệch chuẩn, độ lệch tuyệt đối, giá trị cực đại - cực tiểu, trung vị, khoảng tứ phân vị, số đỉnh, độ lệch, độ nhọn, năng lượng tín hiệu,... Ngoài ra, hai đặc trưng kết hợp là gia tốc tổng hợp trung bình và tổng độ lớn tín hiệu (SMA) cũng được duy trì trong miền tần số để phục vụ so sánh với miền thời gian.

Việc sử dụng đồng thời các đặc trưng từ cả hai miền thời gian và tần số giúp
tăng khả năng mô tả đặc trưng cho mô hình học máy, từ đó nâng cao hiệu quả phân
loại tư thế ngủ trong các điều kiện khác nhau.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/ana_feature_time.png}}
    \caption{Phân bố của đặc trưng trung bình, độ lệnh chuẩn và năng lượng trên miền thời gian của tập huấn luyện}
    \label{ana_feature_time}
\end{figure}

Hình~\ref{ana_feature_time} đưa ra những ý nghĩa của ba đặc trưng miền thời
gian. Các đặc trưng trung bình và năng lượng của 2 trục x và z cho phân bố mật
độ tách biệt để phân bật nhóm tư thế nghiêng trái - nghiêng phải và ngửa - sấp.
Đối bối trục y, theo đánh giá các phân bộ sẽ đa số tập trung thành cũng giống
như đặc trưng độ lệnh chuẩn trên miền thời gian và các hai giá trị đặc trưng
trên miền tần số Hình~\ref{ana_feature_fft}. Qua phân tích trên, tác giả càng
tin tưởng về luận điểm rằng với tư thế ngủ, các đặc trưng miền thời gian sẽ có
nhiều ý nghĩa hơn và trong đó cũng sẽ có những nhóm thực sự nổi bật để có thể
phân loại tư thế ngủ.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.8\linewidth]{images/ana_feature_fft.png}}
    \caption{Phân bố của đặc trưng trung bình, độ lệnh chuẩn trên miền tần số của tập huấn luyện}
    \label{ana_feature_fft}
\end{figure}
\subsection{Lựa chọn tham số}
Sau khi xác định được 69 đặc trưng cả miền thời gian và tần số, tác giả sẽ chạy
qua các vòng lặp với các dải tham số cài đặt sẵn với 5 mô hình đã lựa chọn LR,
RF, SVM, GB và ANN như Bảng~\ref{tab:model_results}.
\begin{table}[htbp]
    \centering
    \renewcommand{\arraystretch}{1.3}
    \setlength{\tabcolsep}{5pt}
    \caption{Kết quả lựa chọn tham số cho các mô hình học máy}
    \label{tab:model_results}
    \small
    \begin{tabular}{|l|p{1cm}|p{1cm}|p{7cm}|p{1.5cm}|p{1.5cm}|}
        \hline
        \textbf{Mô hình}                                                                                                                         & \textbf{Số tổ hợp} & \textbf{Lần thử} & \textbf{Tham số tối ưu} & \textbf{Xác thực chéo} & \textbf{Độ chính xác} \\
        \hline
        \textbf{RF}                                                                                                                              & 288                & 864              &
        \raggedright\ttfamily n\_estimators=20, max\_depth=10, min\_samples\_split=2, min\_samples\_leaf=1, max\_features='sqrt', bootstrap=True &
        \textbf{98.82}                                                                                                                           & \textbf{99.45}                                                                                                   \\
        \hline
        \textbf{LR}                                                                                                                              & 54                 & 162              &
        \raggedright\ttfamily C=5, max\_iter=10, penalty='l2', solver='newton-cg'                                                                &
        96.55                                                                                                                                    & 96.30                                                                                                            \\
        \hline
        \textbf{SVM}                                                                                                                             & 216                & 648              &
        \raggedright\ttfamily C=1, kernel='linear', degree=2, gamma='scale', decision\_function\_shape='ovo'                                     &
        96.62                                                                                                                                    & 94.06                                                                                                            \\
        \hline
        \textbf{GB}                                                                                                                              & 216                & 648              &
        \raggedright\ttfamily n\_estimators=10, learning\_rate=0.1, max\_depth=4, max\_features='sqrt', subsample=0.8                            &
        \textbf{97.51}                                                                                                                           & \textbf{99.51}                                                                                                   \\
        \hline
        \textbf{NN}                                                                                                                              & 32                 & 96               &
        \raggedright\ttfamily neurons\_1=8, neurons\_2=8, learning\_rate=0.01, batch\_size=16, epochs=20                                         &
        98.01                                                                                                                                    & 95.83                                                                                                            \\
        \hline
    \end{tabular}
\end{table}

Bảng~\ref{tab:model_results} cho thấy mô hình RF và GB được đánh giá về mặt độ
chính xác là ổn định nhất cả quá trình xác thực chéo và tập kiểm tra. Hai mô
hình SVM và LR có độ chính xác thấp nhất trong 5 mô hình nhưng vẫn cho độ chính
xác > 94\%. Mô hình NN được xây dựng không thông qua 69 đặc trưng mà dùng trực
tiếp giá trị gia tốc thô với cửa số 10 mẫu (30 giá trị x, y, z) để huấn luyện
cho kết quả ấn tượng đối với tập huấn luyện nhưng bị suy giảm so với tập kiểm
tra. Hình~\ref{fig:ml_confuse} cũng chỉ ra rằng, đối với mô hình NN, hai tư thế
nghiêng phải và ngửa đang bị suy luận sai. Việc này cũng được tác giả phân tích
biểu đồ phân bố đối với trục z bên trên. Ngoài ra, SVM có những sự nhầm lẫn ở
hai tư thế là nghiêng trái và nghiêng phải.

Bên cạnh đó, tác giả cũng phân tích thêm các đặc trưng ảnh hưởng như thế nào
đến các mô hình có tham số tốt nhất (không có ANN vì lý do ANN không dùng 69
đặc trưng) Hình~\ref{fig:ml_shap}. Đúng với nhận định từ trước, các tính năng
miền thời gian chiếm nhiều ý nghĩa lên mô hình đặc biệt là đặc trưng được trích
xuất từ hai trục x, y và các đặc trưng tổng hợp từ 3 trục. Đặc trưng miền tần
số đa phần đứng vị trí cuối cho thấy không có nhiều ý nghĩa đối với các tham số
đã chọn.

Hình~\ref{fig:ml_shap} (a) và (d) khá tương đồng về mặt ý nghĩa của các đặc
trên lên mô hình RF và GB. Đây cũng thể xem là do 2 mô hình đều có cơ chế xây
dựng dựa trên các cây quyết định. Hình~\ref{fig:ml_shap} (b) chỉ ra LR thì lại
ưu tiên hơn các đặc trưng được tổng hợp từ ba trục. Còn đối với SVM
Hình~\ref{fig:ml_shap} (b), đã xác định rõ các véc-tơ hỗ trợ nên đang tính các
tính năng còn lại đều có giá trị 0.

Ngoài ra, tác giả cũng nhận thấy có 15 đặc trưng luôn xuất hiên vị trí đầu của
tất cả các mô hình bao gồm: "z\_median","z\_mean","x\_mean","x\_energy",
"z\_pos\_count", "z\_neg\_count","x\_median", 'z\_energy', 'avg\_result\_accl',
'x\_neg\_count', 'z\_std', 'x\_pos\_count',"y\_energy","y\_mean","sma",
'y\_median'.

Để hiểu sâu hơn về ý nghĩa các đặc trưng này, tác giả xây dựng 8 kịch bản để đánh giá.
Việc này không chỉ có ý nghĩa về mặt phân tích đặc trưng và còn muốn làm rõ hơn về mặt kích thước mô hình để phù hợp triển khai lên biên.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_rf.png}
        \label{fig:ml_confuse_rf}
        \caption{RF}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_lr.png}
        \label{fig:ml_confuse_lr}
        \caption{LR}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_nn.png}
        \label{fig:ml_confuse_nn}
        \caption{NN}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_svm.png}
        \label{fig:ml_confuse_svm}
        \caption{SVM}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/ml_confuse_gb.png}
        \label{fig:ml_confuse_gb}
        \caption{GB}
    \end{subfigure}
    \caption{Ma trận nhầm lẫn của các mô hình học máy}
    \caption*{\textit{Ghi chú:} Nhãn 0 - tư thế ngửa; 1 - nghiêng phải; 2 - nghiêng trái; 3 - sấp.}
    \label{fig:ml_confuse}

\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.6\textwidth]{images/ml_shap_rf.png}
        \label{fig:ml_shap_rf}
        \caption{RF}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/ml_shap_lr.png}
        \label{fig:ml_shap_lr}
        \caption{LR}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/ml_shap_svm.png}
        \label{fig:ml_shap_svm}
        \caption{SVM}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.6\textwidth]{images/ml_shap_gb.png}
        \label{fig:ml_shap_gb}
        \caption{GB}
    \end{subfigure}
    \caption{Ý nghĩa của các đặc trưng lên mô hình}
    \label{fig:ml_shap}

\end{figure}

\newpage

\subsection{Kịch bản kiểm thử}

Lựa chọn đặc trưng là một bước quan trọng trong quá trình xây dựng mô hình học
máy, giúp giảm chiều dữ liệu, cải thiện hiệu quả huấn luyện, rút ngắn thời gian
tính toán và hạn chế hiện tượng quá khớp. Nguyên lý chung là các đặc trưng hiệu
quả phải có mối tương quan cao với mục tiêu là phát hiện tư thế ngủ.

Phân tích ma trận tương quan (Hình~\ref{fig:correlation}) đã cho thấy một số
cặp đặc trưng có mức tương quan rất cao, điển hình như $x_{\mathrm{std}}$ và
$x_{\mathrm{aad}}$ ($r = 0.98$), hay $y_{\mathrm{std}}$ và $y_{\mathrm{aad}}$
($r = 0.68$). Điều này gợi ý rằng có thể loại bỏ một phần các đặc trưng trùng
lặp nhằm giảm độ phức tạp mô hình mà vẫn giữ được thông tin cốt lõi.

Kết hợp với phân tích ở phần trên tác giả chọn lựa được 8 kịch bản bao gồm thay
đổi 3 thông số chính là: độ dài cửa sổ - độ phủ, đặc trưng miền và số lượng đặc
trưng Bảng~\ref{tab:scenarios}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\linewidth]{images/correlation.png}
    \caption{Ma trận tương quan giữa các đặc trưng trích xuất.}
    \label{fig:correlation}
\end{figure}

\begin{table}[htbp]
    \caption{Các kịch bản lựa chọn và sử dụng đặc trưng trong nghiên cứu}
    \label{tab:scenarios}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{Kịch bản} & \textbf{Mô tả}                                                                                                \\
            \hline
            1                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với toàn bộ đặc trưng.                                                      \\
            \hline
            2                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với toàn bộ đặc trưng trong miền thời gian.                                 \\
            \hline
            3                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với toàn bộ đặc trưng trong miền tần số.                                    \\
            \hline
            4                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với đặc trưng miền thời gian, loại bỏ các đặc trưng có tương quan $>$ 95\%. \\
            \hline
            5                 & Dùng cửa sổ 20 mẫu (50\% độ phủ), với 15 đặc trưng quan trọng nhất theo giá trị đứng đầu.                     \\
            \hline
            6                 & Dùng cửa sổ 30 mẫu (50\% độ phủ), với 15 đặc trưng đứng đầu.                                                  \\
            \hline
            7                 & Dùng cửa sổ 10 mẫu (50\% độ phủ), với 15 đặc trưng đứng đầu.                                                  \\
            \hline
            8                 & Dùng cửa sổ 20 mẫu (25\% độ phủ), với 15 đặc trưng đứng đầu.                                                  \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

\newpage

\subsection{Đánh giá kết quả}
Sau khi xác định các kịch bản, tác giả tiến hành huấn luyện trên cũng một máy
tính và đưa ra kết quả về độ chính xác Hình~\ref{kq_8kb}.

Cho thấy, kịch bản 3 (màu đỏ) là toàn bộ các đặc trưng trên miền tần số hoàn
toàn không phù hợp để phân loại tư thế ngủ. Điều này cũng được chứng minh tại ở
phần trên. Các mô hình RF và GB luôn cho cho độ chính xác cao nhất và ổn định
nhất ở toàn bộ các bộ dữ liệu huấn luyện. Các kịch bản 5, 6, 7, 8 đựa trên chỉ
15 đặc trưng có vị trí đầu hầu như không thay đổi độ chính xác nhiều. Điều này
cho thấy, việc lựa chọn này phù hợp đối với bài toán tư thế ngủ. Trong kịch bản
6, có độ chính xác cao nhất lên tới 99.84\% đối với mô hình GB với bộ dữ liệu
cửa sổ 30 mẫu. Kịch bản 7 có kết quả ấn tượng nhất. Trong đó, độ chính xác các
mô hình đều được cải thiện rõ rệt ngay cả mô hình LR và SVM. Điều này thực sự
có ý nghĩa vì độ rộng cửa sổ có ảnh hưởng trực tiếp đến việc tính toán, thời
gian phản hồi kết quả trên biên. Với NN như đánh giá trong phần lựa chọn tham
số, khả năng tự trích xuất tính năng từ chỉ 2 lớp ẩn cũng đã cho kết quả đến
98\%, nhưng giảm nhẹ ở tập kiểm tra 95.5\%.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=1\linewidth]{images/kq_8kb.png}}
    \caption{Kết quả độ chính xác của 8 kịch bản}
    \label{kq_8kb}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_rf_val.png}
        \label{fig:kq_kb7_rf_val}
        \caption{RF trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_rf_test.png}
        \label{fig:kq_kb7_rf_test}
        \caption{RF trên tập kiểm thử}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_val.png}
        \label{fig:kq_kb7_lr_val}
        \caption{SVM trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_test.png}
        \label{fig:kq_kb7_lr_test}
        \caption{SVM trên tập kiểm thử}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_svm_val.png}
        \label{fig:kq_kb7_svm_val}
        \caption{GB trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_gb_test.png}
        \label{fig:kq_kb7_gb_test}
        \caption{GB trên tập kiểm thử}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_val.png}
        \label{fig:kq_kb7_lr_val}
        \caption{LR trên tập huấn luyện}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/kq_kb7_lr_test.png}
        \label{fig:kq_kb7_lr_test}
        \caption{LR trên tập kiểm thử}
    \end{subfigure}
    \caption{Ma trận nhầm lẫn trong kịch bản 8}
    \label{fig:kq_kb7_confuse}

\end{figure}

Hình~\ref{fig:kq_kb7_confuse} minh họa ma trận nhầm lẫn giữa các mô hình. Qua
đó cho thấy việc sử dụng các đặc trưng vị trí đầu cho kết quả thật sự hiệu quả.
Đây cũng là điểm mới luận văn tìm ra để triển khai bài toán phân loại tư thế
ngủ lên biên.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=1\linewidth]{images/kq_8kb_wei.png}}
    \caption{Kết quả kết thước mô hình của 8 kịch bản (đơn vị: kb)}
    \label{kq_8kb_wei}
\end{figure}

Hình~\ref{kq_8kb_wei} cho cái nhìn toàn diện về kích thước mô hình của 8 kịch
bản. Đầu tiên dễ nhận thấy là ở kịch bản 3, hai mô hình RF và SVM không hội tụ
được với bộ tham số đã tìm ra dẫn đến kích thước mô hình tăng vọt. Mô hình GB
có kích thước hầu như không thay đổi với tất cả kịch bản, nhưng luôn nằm trong
nhóm lớn nhất. Ở các kịch bản 5, 6, 7, 8 cũng thể hiện rõ giảm số lượng đặc
trưng không nhiều ý nghĩa xuống cũng đồng thời giảm được kích thước mô hình
nhưng độ chính xác hẫu như vẫn giữ nguyên. Dễ dàng nhìn thấy kịch bản thứ nhất
dùng tất cả các tính năng và kịch bản 7, tất cả kích thước mô hình ít nhất giảm
đi 2 lần, riêng SVM đạt tới 10 lần cho thấy việc lựa chọn đúng đặc trưng thực
sự có ý nghĩa mặt tính toán. Riêng đối với mô hình NN, do chỉ đánh giá với 1
kịch bản nhưng cũng cho thấy tiềm năng mạnh mẽ khi chỉ với kích thước 31.94 kb
đã cho độ chính xác ở tập huấn luyện lên tới 98\%.

Tất cả những đánh giá trên, tác giả quyết định lựa chọn đại diện 2 mô hình là
LR - truyền thống và ANN - học sâu để tiến hình thử nghiệm triển khai trên
biên. Lựa chọn LR mà không phải 3 mô hình còn lại có lý do đầu tiên là kích
thước ổn định, nhỏ nhất và có độ chính xác lên tới 97\%. Việc này sẽ phù hợp
với phần cứng của nhóm. Còn NN, lý do tác giả muốn kiểm tra cả học sâu học động
hiệu quả hay không trên môi trường tại biên. Ngoài ra, trong tương lại ngoài
phân loại tư thế ngủ, phần cứng của nhóm còn phải gánh thêm những bài toán khác
với kích thước mô hình, kích thước dữ liệu đầu vào cho mô hình lớn hơn rất
nhiều lần như tín hiệu audio. Vậy nên LR sẽ giúp san sẻ tài nguyên phân cứng,
NN sẽ làm tiền đề để phát triển mô hình cho bài toán khác tại biên.

\begin{figure}[htbp]
    \centerline{\includegraphics[width=1\linewidth]{images/kq_influence.png}}
    \caption{Mức độ ảnh hưởng của số lượng mẫu đến độ chính xác mô hình LR}
    \label{kq_influence}
\end{figure}

Ngoài ra, tác giả còn phân tích thêm mức độ ảnh hưởng của số lượng mẫu đến mô
hình Hình~\ref{kq_influence}. Biều đồ cho thấy, đường cong độ chính xác tăng
vọt từ khi bắt đầu đến ngưỡng khoảng 2000 mẫu dữ liệu. Sau đó, đường có xu
hướng đi ngang. Từ biểu đồ này phần nào cũng xác định được số lượng mẫu tác giả
thu thập từ 25 tình nguyện viên đã đủ đối với bài toán phân loại tư thế ngủ.
Ngoài ra, nó còn cho thấy tiềm năng để giảm tiếp kích thước mô hình bằng cách
giảm số lượng mẫu huấn luyện.

\section{Triển khai mô hình lên phần cứng}

Trong phần này, tác giả sẽ trình bày kết quả đạt được khi triển khai hai mô
hình đã chọn lên phần cứng của nhóm.

\section{Chuyển đổi mô hình}

Đầu tiên, tác giả sẽ chuẩn hóa từ mô hình trên máy chủ trung tâm thành định dạng mô hình trên vi điều khiển.
Đối với mô hình LR, sau khi mô hình LR được huấn luyện và hiệu chỉnh,
toàn bộ tham số của mô hình (bao gồm trọng số và hệ số chệch)
cùng với thông số chuẩn hoá (scaler) được lưu trữ lại bằng thư viện Joblib
\footnote{\textit{Joblib} là một thư viện trong Python, được thiết kế tối ưu cho việc tuần tự hoá  và lưu trữ các đối tượng dữ liệu lớn như mô hình học máy, tham số, và bộ chuẩn hoá}.
Cơ chế này sử dụng để trích xuất toàn bộ tham số huấn luyện
(bao gồm ma trận trọng số, vector bias, và các giá trị cực tiểu -
cực đại của scaler) dưới dạng hằng số ngôn ngữ C.

Sau khi mô hình ANN được huấn luyện, việc chuyển đổi mô hình sang định dạng
triển khai thực tế trên thiết bị biên trở thành một bước bắt buộc. Mô hình này
ở định dạng mặc định (.h5) chứa nhiều thành phần không cần thiết cho quá trình
suy luận. Hơn nữa, các định dạng này yêu cầu môi trường Python
\footnote{\textit{Python} là một ngôn ngữ lập trình bậc cao, mã nguồn mở, hỗ
    trợ mạnh mẽ cho các ứng dụng khoa học dữ liệu, trí tuệ nhân tạo và học máy} và
thư viện TensorFlow\footnote{\textit{TensorFlow} là thư viện mã nguồn mở do
    Google phát triển, hỗ trợ xây dựng và huấn luyện các mô hình học sâu. Trong
    nghiên cứu này, TensorFlow được sử dụng để huấn luyện mô hình mạng nơ-ron nhân
    tạo và chuyển đổi sang định dạng \texttt{.tflite} để triển khai trên vi điều
    khiển.} - vốn không khả thi đối với các nền tảng vi điều khiển có giới hạn tài
nguyên nghiêm ngặt về bộ nhớ (RAM = 256 KB) và bộ nhớ lưu trữ (Flash = 1 MB).

Sau khi, mô hình ANN được huấn luyện và hiệu chỉnh. Sau đó, mô hình được chuyển
đổi sang định dạng \textbf{TensorFlow Lite (TFLite)} bằng thư viện
\texttt{TFLiteConverter}, giúp nén và tối ưu mô hình cho thiết bị nhúng.

Thư viện TFLiteConverter cung cấp nhiều thuộc tính điều chỉnh quan trọng ảnh
hưởng trực tiếp đến chất lượng suy luận cũng như khả năng thu gọn mô hình. Các
thuộc tính như optimizations cho phép lựa chọn các chiến lược tối ưu hóa toàn
cục; representative\_dataset đóng vai trò thiết yếu trong lượng tử hóa số
nguyên; Thư viện cũng cung cấp tùy chọn các phép toán tùy chỉnh, loại bỏ
metadata; Phương thức trung tâm của lớp là convert(), nơi toàn bộ đồ thị
TensorFlow được ánh xạ sang mô hình TFLite dưới dạng chuỗi byte.

Trong phạm vi luận văn này, kích thước mô hình mạng nơ-ron nhân tạo (ANN) sau
huấn luyện chỉ vào khoảng 35~kB, cho thấy chưa cần áp dụng các kỹ thuật tối ưu
hóa mạnh như cắt tỉa trọng số hay lượng tử hóa từ định dạng \texttt{float32}
xuống \texttt{float8}. Vì vậy, tác giả chỉ sử dụng TFLiteConverter với mục tiêu
loại bỏ những thành phần không thiết yếu, qua đó bảo đảm mô hình giữ nguyên độ
chính xác trong khi vẫn đáp ứng yêu cầu triển khai trên thiết bị biên.

Mô hình sau chuyển đổi được lưu thành tệp nhị phân \texttt{position.tflite},
đồng thời kích thước được kiểm tra để đánh giá khả năng lưu trữ trên vi điều
khiển. Cuối cùng, tệp này được chuyển đổi sang dạng mảng nhị phân
(\texttt{position\_model.h}). Toàn bộ quy trình này nhằm tối ưu mô hình và giúp
hệ thống thực hiện suy luận trực tiếp trên vi điều khiển ARM Cortex-M4.

\section{Triển khai tại biên}

Trong bước triển khai thực tế, mô hình Logistic Regression (LR) được ánh xạ
trực tiếp sang mã C/C++ thông qua ba thành phần chính: (i) tệp \texttt{model.h}
lưu trữ toàn bộ tham số huấn luyện (trọng số, hệ số bias, giá trị chuẩn hoá);
(ii) tệp \texttt{predict.h} định nghĩa cơ chế suy luận bằng phép tính tuyến
tính kết hợp Softmax; và (iii) chương trình chính điều khiển cảm biến, trích
xuất đặc trưng, chuẩn hoá và gọi hàm dự đoán. Cách tổ chức này giúp mô hình
hoạt động độc lập hoàn toàn trên vi điều khiển mà không cần bất kỳ thư viện học
máy ngoài nào.

Thực nghiệm cho thấy toàn bộ quá trình suy luận được thực hiện chỉ với các phép
toán cơ bản (\emph{cộng, nhân, căn bậc hai, hàm mũ}), tiêu tốn rất ít tài
nguyên tính toán và đạt thời gian xử lý ở mức micro giây cho mỗi cửa sổ dữ
liệu. Điều này khẳng định tính phù hợp của LR trong bối cảnh triển khai trên
thiết bị nhúng có bộ nhớ và công suất xử lý hạn chế.

Từ góc độ khoa học, việc triển khai LR theo cách này minh chứng rằng một mô
hình học máy có thể được rút gọn thành tập tham số tĩnh và tái hiện chính xác
trên chip, đồng thời duy trì độ chính xác ở mức chấp nhận được cho ứng dụng
giám sát sức khoẻ thời gian thực. Chiến lược \textbf{tối giản mô hình} này là
minh chứng rõ rệt cho tính khả thi của Edge AI: đảm bảo độ trễ thấp, tính riêng
tư dữ liệu và khả năng vận hành bền vững trong môi trường hạn chế tài nguyên.

Khác với LR, mô hình Neural Network (NN) được triển khai trên chip thông qua
định dạng \textbf{TensorFlow Lite Micro (TFLM)}. Khối \texttt{MicroInterpreter}
trong TFLM chịu trách nhiệm đọc mô hình, thực thi các toán tử (Dense, ReLU,
Softmax), và trả về xác suất dự đoán cho từng lớp tư thế. Kết quả cuối cùng
được xác định bằng cách chọn lớp có xác suất cao nhất.

Ý nghĩa khoa học của phương thức triển khai này nằm ở chỗ:
thay vì trích xuất đặc trưng thủ công như với LR, NN có khả năng học trực tiếp từ dữ liệu thô,
từ đó giảm thiểu sự phụ thuộc vào các bước tiền xử lý.
Mặc dù chi phí tính toán cao hơn,
NN có ưu thế trong việc nắm bắt quan hệ phi tuyến
phức tạp giữa các tín hiệu.

Như vậy, hai mô hình LR và NN phản ánh hai chiến lược bổ sung cho nhau: LR tối
giản, phù hợp khi ưu tiên tốc độ và tài nguyên, trong khi NN khai thác tối đa
dữ liệu thô nhờ khả năng biểu diễn phi tuyến, phù hợp cho các ứng dụng đòi hỏi
độ chính xác cao và tính khái quát.

\subsection{Đánh giá hiệu suất và tài nguyên}

Các thí nghiệm được tiến hành trên vi điều khiển nRF52840 và được so sánh trong
điều kiện triển khai thực tế. Ngoài ra, để đảm bảo tính khách quan và khả năng
tái lập, toàn bộ quá trình huấn luyện mô hình, biên dịch chương trình và nạp
xuống vi điều khiển được thực hiện trên một máy tính xách tay có cấu hình phần
cứng như sau:

\begin{itemize}
    \item \textbf{Bộ xử lý:} Intel(R) Core(TM) Ultra 5 226V, tốc độ xung nhịp $2.10$~GHz.
    \item \textbf{Bộ nhớ trong:} $16.0$~GB DDR5, tốc độ $8533$~MT/s.
    \item \textbf{Ổ lưu trữ:} SSD dung lượng $954$~GB (trong đó đã sử dụng $188$~GB).
    \item \textbf{Card đồ họa:} Intel(R) Arc(TM) 130V, dung lượng bộ nhớ đồ hoạ $8$~GB (VRAM khả dụng $128$~MB cho hệ thống).
\end{itemize}

Việc mô tả chi tiết môi trường phần cứng nhằm giúp đảm bảo tính minh bạch, đồng
thời cung cấp thông tin tham chiếu để các nghiên cứu sau có thể so sánh hoặc
tái hiện kết quả. Trong bối cảnh học máy nhúng, hiệu năng biên dịch và tốc độ
nạp chương trình phụ thuộc không chỉ vào kiến trúc của vi điều khiển mà còn
chịu ảnh hưởng từ cấu hình máy tính host, do đó việc báo cáo chi tiết hệ thống
thử nghiệm là cần thiết.

Bảng \ref{tab:comparison_full} trình bày sự so sánh chi tiết hai mô hình khi
triển khai trên vi điều khiển nRF52840. Ngoài các tiêu chí về dung lượng bộ nhớ
và độ phức tạp, kết quả thực nghiệm còn chỉ ra sự khác biệt rất lớn về
\textbf{hiệu năng suy luận}. Cụ thể, mô hình LR đạt thời gian xử lý trung bình
$501~\mu s$ trên mỗi mẫu, trong khi NN mất tới $8000~\mu s$, tức là chậm hơn
khoảng $16$ lần. Đây là một yếu tố quan trọng, đặc biệt trong các ứng dụng thời
gian thực nơi độ trễ (latency) quyết định khả năng đáp ứng của hệ thống.

\begin{table}[H]
    \centering
    \caption{So sánh hiệu năng LR và ANN trên nRF52840}
    \label{tab:comparison_full}
    \begin{tabular}{|l|p{5cm}|p{6cm}|}
        \hline
        \textbf{Tiêu chí}        & \textbf{Logistic Regression (LR)} & \textbf{Neural Network (NN)} \\ \hline
        Dung lượng Flash sử dụng & 115,208 bytes (11\%)              & 363,520 bytes (36\%)         \\ \hline
        Dung lượng RAM sử dụng   & 46,632 bytes (17\%)               & 60,672 bytes (23\%)          \\ \hline
        Thời gian upload         & 4.9 s (29 pages)                  & 15 s (89 pages)              \\ \hline
        Thời gian suy luận       & 501~$\mu s$                       & 8000~$\mu s$                 \\ \hline
        Kích thước mô hình       & 2.9~kb                            & 23~kb                        \\ \hline

    \end{tabular}
\end{table}

Kết quả cho thấy LR có ưu thế vượt trội về tốc độ và mức tiêu thụ tài nguyên,
điều này khiến LR đặc biệt thích hợp cho các hệ thống nhúng giới hạn phần cứng
và yêu cầu phản hồi tức thời (ví dụ: phân loại tư thế ngủ). Tuy nhiên, NN lại
có khả năng khai thác tốt hơn các quan hệ phi tuyến giữa dữ liệu cảm biến, giúp
tăng độ chính xác trong các bài toán phức tạp như nhận diện chuyển động liên
tục hoặc phân loại đa trạng thái.

Điểm mấu chốt ở đây là \textbf{sự đánh đổi giữa tốc độ và khả năng biểu diễn}:
LR nhanh và nhẹ, nhưng hạn chế về năng lực mô hình;
trong khi NN tiêu tốn nhiều tài nguyên hơn, song mang
lại độ chính xác cao và khả năng tổng quát hóa mạnh mẽ.
Do đó, việc lựa chọn mô hình không mang tính tuyệt đối,
mà cần được cân nhắc dựa trên mục tiêu ứng dụng:
\textit{ưu tiên thời gian thực và tiết kiệm năng lượng} (chọn LR) hoặc
\textit{ưu tiên độ chính xác và khả năng mở rộng} (chọn NN).

Để đánh giá độ chính xác của 2 mô hình đã triển khai trên biên, tác giả thiết kế mô
hình để truyền toàn bộ dữ liệu tập kiểm
tra vào phần cứng và nhận lại giá trị suy luận.
Quy trình đánh giá mô hình trên vi điều khiển được tổ chức theo hai nhánh
chính: luồng xử lý trên MCU và luồng kiểm thử trên máy tính. Phía máy tính chịu
trách nhiệm tải dữ liệu gia tốc trong tệp CSV, tạo các cửa sổ trượt kích thước xác định,
và lần lượt truyền từng giá trị
(x,y,z) của mỗi cửa sổ xuống MCU thông qua giao tiếp Serial. Mỗi khi MCU nhận đủ
N mẫu, thiết bị thực thi toàn bộ pipeline suy luận gồm trích xuất 15 đặc trưng,
chuẩn hoá các đặc trưng theo min-max, và đưa vào mô hình đã được chuyển đổi
sang định dạng TFLite. Kết quả phân lớp được trả về máy tính dưới dạng một số
nguyên đại diện cho tư thế ngủ.

Trên máy tính, mỗi dự đoán nhận được được so sánh với nhãn gốc của cửa sổ tương
ứng để tính toán độ chính xác tổng thể, đồng thời xây dựng ma trận nhầm lẫn và
bộ chỉ số đánh giá như precision, recall và F1-score. Cách tiếp cận này cho
phép mô phỏng chính xác điều kiện triển khai thực tế trên phần cứng, từ đó kiểm
định mức độ ổn định của mô hình sau khi chuyển đổi và tích hợp vào vi điều
khiển ARM Cortex-M4.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[node distance=1.7cm,>=stealth,thick]

        \tikzstyle{block}=[rectangle,draw,rounded corners,
        align=center,
        minimum width=4cm,
        minimum height=1.1cm]

        % PC column
        \node[block] (pc1) {Đọc dữ liệu CSV};
        \node[block,below of=pc1] (pc2) {Tạo cửa số\\(window size, step)};
        \node[block,below of=pc2] (pc3) {Gửi từng mẫu\\$x,y,z$ qua Serial};
        \node[block,below of=pc3] (pc4) {Nhận dự đoán từ phần cứng};
        \node[block,below of=pc4] (pc5) {So sánh với nhãn gốc};
        \node[block,below of=pc5] (pc6) {Tính accuracy\\và confusion matrix};

        % MCU column
        \node[block,right=6cm of pc2] (mcu1) {Nhận dữ liệu $x,y,z$};
        \node[block,below of=mcu1] (mcu2) {Lưu vào bộ đệm\\(đúng kích thước cửa sổ)};
        \node[block,below of=mcu2] (mcu3) {Trích xuất 15 đặc trưng};
        \node[block,below of=mcu3] (mcu4) {Chuẩn hoá đặc trưng};
        \node[block,below of=mcu4] (mcu5) {Suy luận bằng\\mô hình TFLite};
        \node[block,below of=mcu5] (mcu6) {Gửi nhãn dự đoán về PC};

        % Arrows PC
        \draw[->] (pc1) -- (pc2);
        \draw[->] (pc2) -- (pc3);
        \draw[->] (pc4) -- (pc5);
        \draw[->] (pc5) -- (pc6);

        % Arrow from PC to MCU
        \draw[->] (pc3.east) -- ++(1.0,0) |- (mcu1.west);

        % MCU internal arrows
        \draw[->] (mcu1) -- (mcu2);
        \draw[->] (mcu2) -- (mcu3);
        \draw[->] (mcu3) -- (mcu4);
        \draw[->] (mcu4) -- (mcu5);
        \draw[->] (mcu5) -- (mcu6);

        % Arrow from MCU back to PC
        \draw[->] (mcu6.west) -| ++(-1.0,0) |- (pc4.east);

    \end{tikzpicture}
    \caption{Quy trình đánh giá mô hình trên MCU và đối chiếu kết quả trên PC.}
\end{figure}

\begin{table}[ht]
    \centering
    \caption{So sánh kết quả mô hình trên tập thử Python và khi triển khai trên MCU}
    \begin{tabular}{lcc}
        \hline
        \textbf{Mục đánh giá} & \textbf{Python Benchmark}   & \textbf{MCU thực nghiệm} \\
        \hline
        Tổng số cửa sổ        & 12\,749                     & 12\,749                  \\[4pt]

        Accuracy              & \textbf{0.9758}             & \textbf{0.8973}          \\[6pt]

        Ma trận nhầm lẫn      & $\begin{bmatrix}
                                         5495 & 190  & 86   & 4   \\
                                         0    & 1618 & 0    & 0   \\
                                         18   & 0    & 4852 & 0   \\
                                         0    & 0    & 11   & 475
                                     \end{bmatrix}$ &
        $\begin{bmatrix}
                 4950 & 215  & 606  & 4 \\
                 0    & 1618 & 0    & 0 \\
                 0    & 0    & 4870 & 0 \\
                 0    & 0    & 484  & 2
             \end{bmatrix}$                                                        \\[14pt]

        Precision (1-4)       & 1.00, 0.89, 0.98, 0.99      & 1.00, 0.88, 0.82, 0.33   \\[6pt]

        Recall (1-4)          & 0.95, 1.00, 1.00, 0.98      & 0.86, 1.00, 1.00, 0.00   \\[6pt]

        F1-score (1-4)        & 0.97, 0.94, 0.99, 0.98      & 0.92, 0.94, 0.90, 0.01   \\ \hline
    \end{tabular}
    \label{tiny_result}
\end{table}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/tiny_nn.png}
        \label{fig:tiny_nn}
        \caption{ANN}

    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{images/tiny_lr.png}
        \label{fig:tiny_lr}
        \caption{LR}
    \end{subfigure}
    \caption{Ma trận nhầm lẫn của 2 mô hình triển khai trên biên}
    \label{fig:tiny_confuse}
\end{figure}

Kết quả thực nghiệm Bảng~\ref{tiny_result} cho thấy sự khác biệt rõ rệt giữa
Logistic Regression (LR) và mô hình Neural Network (NN) khi đánh giá trên cùng
một tập dữ liệu gồm 12.749 cửa sổ tín hiệu. LR vẫn đạt độ chính xác 97.58\%,
trong khi NN chỉ đạt 89.73\%. Sự chênh lệch này không chỉ phản ánh ưu thế của
LR trong điều kiện dữ liệu được chuẩn hóa tốt, mà còn làm nổi bật tính ổn định
của LR khi chuyển sang môi trường triển khai thực, vốn chứa nhiều bất định và
sai số đặc trưng của thiết bị biên.

Ở mô hình LR, các chỉ số precision, recall và f1-score đều duy trì ở mức cao cho cả bốn tư thế.
Đặc biệt, tư thế sấp - vốn là tư thế dễ nhiễu và í
t xuất hiện - vẫn được nhận dạng với recall 0.98 và f1-score 0.98.
Ma trận nhầm lẫn của LR cho thấy các sai lệch chủ yếu mang tính cục bộ và không gây phá vỡ biên phân lớp.
Điều này cho thấy mô hình tuyến tính của LR, mặc dù đơn giản về mặt cấu trúc, lại tạo ra mặt phân tách tương đối bền vững đối với các biến động nhỏ trong tín hiệu gia tốc.

Ngược lại, mô hình NN thể hiện sự suy giảm đáng kể về hiệu năng khi triển khai.
Mặc dù recall của tư thế 2 và 3 vẫn ở mức tuyệt đối, mô hình gần như thất bại
hoàn toàn với tư thế sấp: recall bằng 0. Điều này phản ánh 1 phần độ chính xác
đã bị suy hao trong quá trình convert và triển khai trên biên.

Sự khác biệt giữa hai mô hình đặc biệt rõ trong ma trận nhầm lẫn
Hình~\ref{fig:tiny_confuse}. Trong khi LR duy trì cấu trúc phân lớp gần như lý
tưởng ở cả bốn tư thế, NN xuất hiện nhiều sai lệch nghiêm trọng giữa tư thế
ngửa và nghiêng phải, và đặc biệt là không thể nhận dạng tư thế sấp. Điều này
cho thấy LR phù hợp hơn cho tín hiệu từ cảm biến gia tốc gắn trên cơ thể.

Từ các kết quả này có thể khẳng định rằng, trong bối cảnh triển khai trên các
hệ thống TinyML, LR tỏ ra vượt trội so với NN không chỉ vì mô hình nhỏ gọn hơn
mà còn vì khả năng duy trì độ ổn định và độ tin cậy khi đối mặt với các biến
thiên tín hiệu thực. Điều này củng cố lập luận rằng ưu tiên lựa chọn mô hình
tuyến tính tinh gọn, thay vì mạng nơ-ron quy mô nhỏ, là một hướng đi có lợi thế
rõ rệt trong các ứng dụng theo dõi tư thế ngủ trên thiết bị đeo chi phí thấp.

\subsection*{Bài toán phát hiện nằm hoặc không nằm}

Sau khi triển khai thực tế trên biên, tác giác nhận thấy rằng, hiện nay hệ
thống tại biên đang chỉ nhận dạng được 4 nhãn lần lượt ngửa, nghiêng phải,
nghiêng trái, sấp chưa đủ đáp ứng thực tế rằng khi ngủ người bệnh có thể đứng
lên đi lại hoặc uống nước. Qua đó tác giả mở rộng thêm bài toán xác định nằm
hay không nằm. Đây là bài toán sàng lọc trước khi đến bài toán xác định tư thế
ngủ. Qua đó tác giả thu thập thêm 8500 mẫu dữ liệu các hoạt động như ngồi, đi
lại, uống nước. Tập các tư thế ngủ tác giả chọn lọc 11306 mẫu đủ các 4 tư thế
được quy về 1 nhãn là nằm. Tác giả áp dụng nguyên các bước để đánh giá tư thế
ngủ bao gồm độ dài cửa sổ 1s, độ phủ 50\%, 69 đặc trưng trích xuất. Qua đó mô
hình cho kết quả lên tới 100\% phân loại 2 nhãn là nằm và không nằm và có kích
thước mô hình là 3.8 kb.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{images/lying_lr_shap_model.png}
        \caption{LR}
    \end{subfigure}
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.7\textwidth]{images/lying_rf_shap.png}
        \label{fig:lying_rf_shap}
        \caption{RF}
    \end{subfigure}

    \caption{Biểu đồ mức độ ảnh hưởng của các đặc trưng lên mô hình với bài toán nằm hay không nằm}
    \label{fig:lying_shap}

\end{figure}

Sau khi đánh giá mức độ ảnh hưởng của đặc trưng lên mô hình như
Hình~\ref{fig:lying_shap}, tác giả chọn ra 6 đặc trưng: 'avg\_result\_accl',
'y\_energy', 'y\_min', 'y\_mean','z\_min', 'z\_max' để huấn luyện lại mô hình
LR. Kết quả độ chính xác có giảm 1 chút nhưng kích thước mô hình còn 1.9 kb
Hình~\ref{fig:lying_lr}. Điều này hoàn toàn phù với tiêu chí để trải khai đa mô
hình trên biên.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/lying_lr.png}
        \label{fig:lying_lr}
        \caption{dựa trên toàn bộ đặc trưng}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/lying_lr_shap.png}
        \label{fig:lying_lr_shap}
        \caption{dựa trên 6 tính năng vị trí đầu }
    \end{subfigure}

    \caption{Ma trận nhầm lẫn phân biệt 2 nhãn nằm và không nằm}

    \label{fig:lying_lr}

\end{figure}

Qua đó bài toán phân loại trên biên được nâng cấp thành 3 bước chính:

\usetikzlibrary{shapes.geometric, positioning}

\begin{tikzpicture}[node distance=20mm, >=latex]

    \node[draw] (data) {Dữ liệu cảm biến gia tốc};
    \node[draw, right=of data] (check) {Nằm hay không?};
    \node[draw, right=of check] (pose) {Tư thế ngủ};

    \draw[->] (data) -- (check);
    \draw[->] (check) -- node[above]{Có} (pose);
    \draw[->] (check) -- ++(0,-1.2) node[below]{Không};

\end{tikzpicture}

Việc này khẳng định để thực sự đưa bài toán này vào thực tế, còn rất nhiều bước
cần phải hiệu chỉnh để giải quyết các trường hợp thực tế. Tuy nhiên, các kết
quả đưa ra cho thấy giải quyết phần nào bài toán phân loại tư thế ngủ tại biên
cùng với 1 quy trình từ cảm biến đến mô hình trên biên. Với quy trình này, tác
giả tin có thể giải quyết được hầu như các trường hợp phát sinh khác và hướng
đến bài toán phân loại OSA.