
\section{Hội chứng ngưng thở khi ngủ}

Trong bối cảnh nghiên cứu các rối loạn hô hấp liên quan đến giấc ngủ, 
việc định nghĩa rõ ràng các kiểu sự kiện hô hấp là 
cần thiết nhằm phục vụ cho mục đích chẩn đoán, 
phân tầng nguy cơ và điều trị. 
Ba sự kiện hô hấp quan trọng bao gồm: ngưng thở (apnea), giảm thở (hypopnea), và hiện tượng kích hoạt liên quan đến nỗ lực hô hấp
(Respiratory Effort–Related Arousal – RERA) \cite{berry2012scoring}.

Ngưng thở (Apnea) được Hiệp hội Y học Giấc ngủ Hoa Kỳ (AASM) định nghĩa là 
sự ngưng luồng khí hô hấp qua mũi và miệng trong thời gian tối thiểu 10 giây. 
Các sự kiện ngưng thở có thể kéo dài đến 30 giây hoặc hơn trong những trường hợp nặng.
Có ba dạng chính của hội chứng ngưng thở khi ngủ \cite{ThaySYOSA}: ngưng thở tắc nghẽn, ngưng thở trung ương, Ngưng thở hỗn hợp. Trong đó: 
01)Ngưng thở khi ngủ do tắc nghẽn (Obstructive Sleep Apnea – OSA) là dạng phổ biến nhất, xảy ra khi các cơ vùng họng giãn ra và làm tắc đường thở, cản trở không khí đi vào phổi \cite{osa_summary}; 
02)Ngưng thở khi ngủ do trung ương (Central Sleep Apnea – CSA) là tình trạng não không gửi tín hiệu đúng đến các cơ kiểm soát hô hấp \cite{eckert2007csa}. Mặc dù ít gặp hơn OSA, CSA vẫn có thể gây ra mệt mỏi kéo dài và đau đầu vào buổi sáng.
03)Ngưng thở hỗn hợp (Mixed Apnea) là sự kết hợp của cả hai yếu tố: giai đoạn đầu của sự kiện không có nỗ lực hô hấp (giống CSA), sau đó xuất hiện nỗ lực hô hấp (giống OSA). 
Dạng này thường xuất hiện ở những bệnh nhân OSA nặng và được phân loại vào nhóm ngưng thở tắc nghẽn trong chỉ số AHI

Giảm thở (Hypopnea) với hai mức tiêu chuẩn đánh giá: 
01) Tiêu chuẩn khuyến nghị: một sự kiện được xác định 
là hypopnea nếu thỏa mãn đồng thời ba điều kiện: 
(i) biên độ tín hiệu luồng khí giảm $\geq 30$\% so với nền trước sự kiện, 
đo bằng cảm biến áp lực mũi hoặc thiết bị CPAP; 
(ii) thời gian giảm tín hiệu kéo dài $\geq 10$ giây; 
và (iii) kèm theo giảm độ bão hòa oxy $\geq 3$\% và/hoặc gây kích hoạt điện não (arousal); 
02) Tiêu chuẩn chấp nhận được (Acceptable): tương tự như trên, tuy nhiên yêu cầu giảm độ bão hòa 
oxy phải đạt từ 4\% trở lên.

RERA là sự kiện gia tăng nỗ lực hô hấp kéo dài $\geq 10$ giây, 
gây đánh thức khỏi giấc ngủ nhưng không đủ tiêu chí của apnea hoặc hypopnea. 
01) Phương pháp tiêu chuẩn để đo là đo áp lực thực quản, tuy nhiên khó áp dụng do gây khó chịu cho bệnh nhân. 
02) Phương án thay thế đáng tin cậy là dùng ống thông mũi kết hợp cảm biến áp lực, 
cho kết quả tương đương về mặt lâm sàng. 
03) RERA được tính vào chỉ số rối loạn hô hấp (Respiratory Disturbance Index - RDI); 
RDI >5 là bất thường, >15 là có ý nghĩa lâm sàng.

Trong số các rối loạn hô hấp liên quan đến giấc ngủ đã đề cập, 
hội chứng ngưng thở khi ngủ do tắc nghẽn (Obstructive Sleep Apnea – OSA) 
là dạng phổ biến nhất và có tác động sâu rộng đến sức khỏe cộng đồng. 
Đáng chú ý, một phân nhóm quan trọng của OSA là ngưng thở khi ngủ 
có liên quan đến tư thế (positional OSA – pOSA), 
trong đó tần suất các sự kiện ngưng thở tăng rõ rệt khi người bệnh 
nằm ngửa so với các tư thế khác. 
Do vậy, luận văn này tập trung phân tích chuyên sâu về OSA và đặc biệt là pOSA, 
làm rõ cơ chế bệnh sinh, tiêu chí chẩn đoán và các chỉ số phân tầng mức độ nặng. 
Trên cơ sở đó, nghiên cứu đề xuất và phát triển một hệ thống giám sát tư thế ngủ tích hợp cảm biến gia tốc và 
mô hình học máy gọn nhẹ (TinyML), hướng tới khả năng sàng lọc OSA tại nhà bằng thiết bị đeo thông minh hoạt động độc lập trên nền tảng vi điều khiển.

Các mức độ của hội chứng ngưng thở khi ngủ do tắc nghẽn 
(OSA) được đánh giá dựa trên chỉ số ngưng thở giảm thở 
(Apnea–Hypopnea Index - AHI) bằng cách chia tổng số 
lần ngưng thở và hẹp thở cho tổng số giờ đã ngủ, 
với mỗi sự kiện phải kéo dài ít nhất 10 giây Bảng~\ref{ahi} \cite{osa_summary}. 
Hội chứng ngưng thở khi ngủ tắc nghẽn tư thế (positional Obstructive Sleep Apnea – pOSA) 
là một dạng đặc biệt của OSA, trong đó mức độ nghiêm trọng 
của hội chứng ngưng thở chịu ảnh hưởng đáng kể từ tư thế nằm của bệnh nhân. 
Cụ thể, pOSA được xác định khi chỉ số AHI (Apnea–Hypopnea Index) ở tư thế nằm ngửa cao hơn đáng kể so với các tư thế khác, 
và thường gặp nhất ở bệnh nhân OSA mức độ nhẹ đến trung bình \cite{heinzer2018,aloweidat2023positional}. 
Người mắc pOSA thường có các đặc điểm như trẻ tuổi hơn, chỉ số khối cơ thể (BMI) thấp hơn, và mức độ OSA tổng thể nhẹ hơn so với nhóm bệnh nhân không thuộc dạng tư thế (non-positional OSA – NpOSA).

Trong nhiều năm qua, các nhà nghiên cứu đã đề xuất nhiều tiêu chí 
khác nhau nhằm chẩn đoán pOSA, từ đơn giản đến phức tạp. 
Định nghĩa cổ điển nhất được giới thiệu bởi Cartwright, 
theo đó bệnh nhân được coi là pOSA nếu AHI ở tư thế nằm ngửa lớn 
hơn ít nhất hai lần so với AHI ở tư thế không nằm ngửa \cite{cartwright1984position}. 
Mador sau đó kế thừa định nghĩa này và bổ sung tiêu chí rằng 
AHI ở tư thế không nằm ngửa phải nhỏ hơn 5 lần/giờ, 
nhằm tăng tính đặc hiệu trong chẩn đoán \cite{mador2005prevalence}. 
Song song đó, Levendowski đề xuất một cách tiếp cận theo tỷ lệ, 
trong đó pOSA được xác định khi AHI toàn bộ lớn hơn hoặc bằng 1.5 lần 
AHI ở tư thế không nằm ngửa \cite{levendowski2015neck}. 
Các tiêu chí này có ưu điểm là đơn giản và dễ áp dụng trong lâm sàng 
cũng như trên thiết bị theo dõi tại nhà, 
nhưng có thể bỏ sót những trường hợp ranh giới hoặc đa yếu tố.

Một hệ thống phân loại toàn diện hơn là Amsterdam Positional Obstructive Sleep Apnea Classification (APOC), 
được thiết kế để phản ánh chính xác hơn ảnh hưởng của tư thế đến mức độ nghiêm trọng của OSA \cite{frank2014positional}. 
Tiêu chí APOC xác định pOSA khi bệnh nhân có AHI toàn bộ lớn hơn 5 lần/giờ, 
đồng thời tổng thời gian ngủ (Total Sleep Time – TST) ở tư thế tốt nhất (Best Sleeping Position – BSP) và tư thế gây ra chỉ số AHI cao nhất 
(Worst Sleeping Position – WSP) đều chiếm tối thiểu 10\% TST. 
Ngoài ra, bệnh nhân cần thỏa mãn ít nhất một trong ba điều kiện sau: 
01) AHI ở BSP nhỏ hơn 5; 02) AHI ở BSP thấp hơn AHI toàn bộ; 
03) AHI ở BSP thấp hơn tối thiểu 25\% so với AHI toàn bộ trong trường 
hợp AHI toàn bộ vượt quá 40. Hơn nữa, APOC còn cho phép phân nhóm bệnh nhân thành 
ba mức độ đáp ứng điều trị: nhóm APOC-I bao gồm bệnh nhân có thể khỏi hoàn toàn nhờ PT; 
nhóm APOC-II và APOC-III bao gồm các trường hợp có cải thiện một phần như giảm phân loại OSA 
hoặc giảm chỉ số AHI sau can thiệp tư thế.

\begin{table}[h!]
\caption{\texorpdfstring{Phân loại mức độ OSA dựa trên chỉ số AHI}{Phân loại OSA}}
\label{ahi}
\vspace{-3mm}
\begin{center}
\begin{tabular}{|c|c|}
\hline
AHI & Cấp độ \\
\hline
<5 & Không mắc \\
5 đến 10 & Nhẹ \\
15 đến 30 & Trung bình \\
>30 & Nặng \\
\hline
\end{tabular}
\label{tab1}
\end{center}
\end{table}



Ngưng thở tắc nghẽn khi ngủ thường xảy ra ở người lớn tuổi và những người thừa cân béo phì. 
Yếu tố gây ra có thể liên quan đến cấu trúc hoặc phi cấu trúc, bao gồm cả yếu tố di truyền. 
Tỷ lệ ngưng thở tắc nghẽn là từ 2\% đến 9\% ở người lớn. 
Ngưng thở tắc nghẽn khi ngủ có thể tăng gấp 4 lần ở nam giới và gấp 7 lần hơn ở những người béo phì (ví dụ chỉ số khối cơ thể (Body mass Index - BMI) > 30). 
OSA nặng (AHI > 30/h) làm tăng nguy cơ tử vong ở nam giới trung niên.
Nguyên nhân chủ yếu là do diện tích vòng họng hoặc khoang mũi bị thu hẹp như viêm xoang, 
các khối u, bệnh phì đại tuyến lưỡi, amydal, phì đại tuyến mỡ (đặc biệt ở trẻ em), 
béo phì hoặc đến từ các bệnh lý: tiểu đường, huyết áp cao, các bệnh tim mạch v.v \cite{wright1997health}. 
Ngoài ra, có thể đến từ thói quen không lành mạnh của con người như là sử dụng các chất kích thích, hút thuốc, ngáy khi ngủ \cite{reason_osa}\cite{reasonOsa}. 
Bên cạnh đó, các yếu tố không giải phẫu như hoạt động kém của cơ giãn họng, ngưỡng thức giấc thấp và sự điều hòa hô hấp không ổn định cũng góp phần quan trọng vào cơ chế bệnh sinh. 
Sự tương tác giữa các yếu tố này tạo nên tính đa dạng trong biểu hiện và mức độ nặng của OSA.



Phần lớn bệnh nhân mắc hội chứng ngưng thở khi ngủ tắc nghẽn 
(\gls{OSA}) không tự nhận thức được các rối loạn hô hấp xảy ra trong lúc ngủ. 
Điều này đặc biệt đúng với những người sống hoặc ngủ một mình, 
do thiếu sự quan sát từ bên ngoài. Đáng lưu ý, hơn 80\% các 
trường hợp OSA được phát hiện ở những bệnh nhân mắc các 
bệnh lý liên quan đến béo phì như tiểu đường, bệnh thận, rối loạn lipid máu, v.v.~\cite{wright1997health}.
Hội chứng OSA ảnh hưởng nghiêm trọng đến chất lượng cuộc sống. 
Những hệ lụy thường gặp bao gồm: suy giảm trí nhớ, giảm tỉnh táo, 
dễ cáu gắt, trầm cảm, đau đầu và giảm khả năng tập trung~\cite{flemons1997quality}. Các tác động này làm giảm hiệu suất làm việc, gây rối loạn trong các mối quan hệ xã hội và làm tăng nguy cơ tai nạn giao thông.
Một nghiên cứu bởi Mooe và cộng sự~\cite{mooe1996sleep} 
thực hiện trên nam giới bị bệnh mạch vành (Coronary Artery Disease – CAD) 
cho thấy có tới 37\% bệnh nhân có chỉ số AHI vượt quá 10. 
Trong khi đó, nghiên cứu của Young và cộng sự (1997) đã phát hiện rằng chỉ số 
AHI tăng tỉ lệ thuận với huyết áp tâm thu và tâm trương, với mức ý nghĩa lần lượt 
là $p=0.003$ và $p=0.01$~\cite{young1997population}.

Trong điều kiện hiện tại, đa số bệnh nhân nghi ngờ mắc 
hội chứng ngưng thở tắc nghẽn khi ngủ được khám bới 
bs chuyên khoa Tai Mũi Họng và bác sĩ chuyên gia về ngủ ngáy. 
Khám tổng quát kết hợp khai thác bệnh sử liên quan, sử dụng các thang điểm đánh 
giá buồn ngủ và nguy cơ ngưng thở khi ngủ, như Epworth Sleepiness Scale, STOP-BANG (đã được dịch sang tiếng Việt) được chấp thuận tại Việt Nam như một phương án sáng lọc bệnh nhân OSA. 
hoặc có thể khám nội soi Tai Mũi Họng để tìm nguyên nhân. 
Vì đa số các trường hợp ngáy, ngưng thở khi ngủ là do tắc nghẽn 
ngoại biên, nguyên nhân từ Mũi – Họng – Màn hầu , VA và amidan, 
và những bất thường về hàm mặt khác. 
Việc đánh giá ngưng thở khi ngủ bắt đầu thường bắt đầu bằng 
một khảo sát giấc ngủ toàn diện, bao gồm khai thác bệnh sử liên quan đến 
các triệu chứng lâm sàng đặc trưng, 
sau đó tiến hành đánh giá khách quan thông qua đa ký giấc ngủ (PSG) \cite{diagnosis_osa}\cite{medical2006polysomnography}.
Phương pháp do dùng đa ký giấc ngủ (Polysomnography) với sự giám sát của các bác sĩ chuyên môn được coi là tiêu chuẩn vàng trong chẩn đoán chứng ngưng thở khi ngủ. 

Polysomnography là một phương pháp ghi đa kênh liên tục trong suốt một đêm, 
bao gồm nhiều thông số sinh lý nhằm đánh giá toàn diện hoạt động hô hấp và 
thần kinh khi ngủ. Các thành phần chính trong một đánh giá polysomnography 
bao gồm: điện não đồ (EEG) để ghi lại hoạt động điện của não; 
điện cơ ký (EMG) nhằm đo trương lực cơ, 
đặc biệt là ở cằm và chân; điện động mắt (EOG) để theo dõi chuyển động của nhãn cầu, 
giúp xác định các giai đoạn của giấc ngủ; và điện tâm đồ (ECG) để theo dõi hoạt động điện của tim. 
Bên cạnh đó, quá trình đo cũng bao gồm theo dõi độ bão hòa oxy trong máu (SpO$_2$), 
đo lưu lượng khí thở qua mũi và miệng, đánh giá nỗ lực hô hấp thông qua chuyển động của ngực và bụng, 
đo áp lực khí thở qua mũi, và ghi nhận cường độ tiếng ngáy. 
Tư thế ngủ là một tín hiệu quan trọng trong polysomnography (PSG), 
đặc biệt có giá trị trong chẩn đoán và phân loại hội chứng ngưng thở khi 
ngủ tắc nghẽn phụ thuộc tư thế (positional OSA – pOSA). 
Trong quá trình ghi đa ký giấc ngủ, việc theo dõi liên tục tư thế cơ thể giúp xác định mối liên hệ giữa tư thế nằm 
(như nằm ngửa, nằm nghiêng hoặc nằm sấp) với tần suất và mức độ nghiêm trọng của các rối loạn hô hấp. 
Tập hợp các thông số này cho phép bác sĩ chẩn đoán chính xác hội chứng ngưng thở khi ngủ tắc nghẽn (OSA).

Một trong những hạn chế của phương pháp đánh giá sử dụng (\gls{PSG}) là sự bất tiện, 
chi phí cao và khả năng phổ biến thấp, nhất là đối với phần lớn người bệnh có thu nhập thấp. 
Việc yêu cầu bệnh nhân phải lưu trú qua đêm tại cơ sở y tế, cùng với việc gắn nhiều thiết bị 
theo dõi sinh lý lên cơ thể, không chỉ gây cảm giác khó chịu mà còn tiềm ẩn nguy 
cơ ảnh hưởng đến chất lượng và tính chính xác của dữ liệu thu thập được. 
Chính những bất cập này đã thúc đẩy sự phát triển của các thiết bị theo dõi giấc 
ngủ ngoài trung tâm (Out-of-Center devices) hay còn gọi là thiết bị kiểm tra giấc ngủ tại nhà (Home Sleep Test – HST). 
Những thiết bị này thường được thiết kế với số lượng cảm biến tối giản hơn so với 
PSG truyền thống, đồng thời tích hợp các thuật toán phân tích tự động – được xử lý trực tiếp trên thiết bị 
hoặc thông qua phần mềm chuyên dụng – nhằm hỗ trợ chẩn đoán ngưng thở khi ngủ do tắc nghẽn (OSA) 
một cách thuận tiện và tiết kiệm hơn. Những thông số SCOPERA được coi là cơ sở để xây dựng thiết bị HST trong đó giấc ngủ (Sleep - S), tim mạch (Cardiovascular - C), oxi trong máu (Oximetry - O), cố gắng thở (Effort - E), 
luồng không khí lưu thông (Respiratory - R), âm thở (Audio - A).

Thiết bị đeo hỗ trợ theo dõi giấc ngủ (wearable Health Sleep Technology – HST) 
đang trở thành một xu hướng chủ đạo trong nghiên cứu và ứng dụng lâm 
sàng nhờ khả năng thu thập liên tục dữ liệu sinh lý một cách không xâm 
lấn, thuận tiện và có thể triển khai tại nhà. 
Dựa trên đặc điểm hình thái và vị trí gắn trên cơ thể, 
các thiết bị này có thể được phân thành các nhóm: 
vòng tay (bracelet), đai ngực (chest band), miếng dán (adhesive patch), 
tai nghe (headset), nhẫn thông minh (ring), v.v. 
Các thiết bị này có thể là sản phẩm thương mại sẵn có hoặc được thiết kế riêng cho mục đích nghiên cứu.

\begin{table}[htbp]
    \centering
    \caption{Phân loại thiết bị đeo trong phát hiện OSA và tài liệu tham khảo liên quan}
    \label{tab:wearable_types}
    \begin{tabular}{|p{5.5cm}|p{7.5cm}|}
        \hline
        \textbf{Loại thiết bị đeo} & \textbf{Tài liệu tham khảo} \\
        \hline
        Vòng tay (Bracelet) & \cite{jeon2020realtime}, \cite{shen2022mtcnn} \cite{e3hst} \cite{osa_sanchez2025} \\
        \hline
        Đai ngực (Chest band) & \cite{svmHSt2017}, \cite{chen2024hdc} \cite{e3hst} \cite{osa_sanchez2025} \\
        \hline
        Miếng dán (Adhesive patch) & \cite{Vu2025SleepPosition}, \cite{yeo2022resnet}, \cite{yeo2022respiratory}, \cite{p_3} \cite{osa_sanchez2025}\\
        \hline
        Dạng khác & \cite{Sleep_Posture_Detection}, \cite{hst_wear_paper} \cite{osa_sanchez2025} \cite{hstSurvey} \cite{hst_paper} \cite{hst_wear_paper}\\
        \hline
    \end{tabular}
\end{table}




Jeon và cộng sự \cite{jeon2020realtime} đã đề xuất một hệ thống chẩn đoán và 
dự đoán hội chứng ngưng thở khi ngủ dựa trên thiết bị đeo. 
Nghiên cứu giới thiệu hệ thống chỉ sử dụng một thiết bị đeo duy nhất – Sleep Care Kit (SCK) – 
có khả năng đo các thông số như nhịp thở, độ bão hòa oxy, nhịp tim và gia tốc ba trục. 
Thiết bị được đeo ở cổ tay, đảm bảo tiếp xúc trực tiếp với da để thu thập tín hiệu sinh lý một cách chính xác. 
Sau một giai đoạn học ban đầu, hệ thống tiến hành phân tích mối tương quan giữa nhịp tim và gia tốc ba trục 
nhằm dự đoán nguy cơ ngưng thở khi ngủ.
Trong nghiên cứu \cite{chen2024hdc}, Chen và cộng sự sử dụng thiết bị đeo dạng 
vòng tay thu tín hiệu PPG để phát hiện ngưng thở khi ngủ ở 100 tình nguyện viên. 
Thiết bị được thiết kế tối ưu về bộ nhớ, độ trễ và năng lượng, phù hợp triển khai 
trên các hệ thống tính toán giới hạn. Dữ liệu thu được được đồng bộ với PSG 
nhằm đảm bảo độ chính xác, đồng thời hướng tới ứng dụng giám sát dài hạn tại nhà.
Trong các nghiên cứu \cite{yeo2022resnet, yeo2022respiratory}, Yeo và cộng sự sử dụng thiết bị dán T-REX TR100A 
để ghi điện tâm đồ (ECG) một kênh từ vùng bụng trên. Thiết bị được dán trực tiếp lên da, 
đảm bảo tiếp xúc ổn định và tín hiệu thu nhận chính xác, giúp theo dõi liên tục và 
hạn chế nguy cơ bị bong tróc trong quá trình sử dụng.
Một thiết bị HST dạng miếng dán cổ đã được phát triển, tích hợp cảm biến 
gia tốc ba trục LIS2DH12 và vi điều khiển nRF5232, 
cho phép truyền dữ liệu không dây qua Bluetooth Low Energy (BLE) 
với tần số lấy mẫu 100~Hz \cite{Sleep_Posture_Detection}. Thiết bị có kích thước nhỏ gọn 
(\textasciitilde3207~mm\textsuperscript{3}), được dán trực tiếp lên vùng 
cổ bằng băng dính hai mặt, giúp đảm bảo tiếp xúc ổn định với da. 
Thiết kế này cho phép ghi nhận chính xác các tư thế ngủ phổ biến như nằm ngửa, 
nằm nghiêng và nằm sấp, phù hợp với mục tiêu theo dõi tại nhà và hỗ trợ đánh giá nguy cơ mắc pOSA.
Nghiên cứu\cite{svmHSt2017} chứng minh rằng tín hiệu chuyển động ngực (Thoracic movement signal - THO) và bụng (Abdominal movement signal - ABD), 
thu từ các dải piezoelectric đeo được, có thể được sử dụng hiệu quả để phân loại các dạng rối loạn thở khi ngủ thông qua mô hình 
thuật toán SVM. Kết quả cho thấy khi kết hợp cả hai tín hiệu, độ chính xác phân loại đạt trung bình 81.8\%, 
khẳng định tiềm năng ứng dụng của phương pháp này trong sàng lọc và theo dõi OSA tại nhà hoặc trong lâm sàng.

Theo tìm hiểu của tác giả, thiết bị HST vẫn có cấu hình khá phức tạp với nhiều cảm biến và thao thác 
cũng chưa hoàn toàn đơn giản, thêm vào đó giá trung bình của thiết bị vào khoảng 2300 USD làm hạn chế khả năng tiếp 
cận của người sử dụng, đặc biệt là những người có thu nhập trung bình hoặc thấp \cite{hst_review}. 

Hiện nay, đã có nhiều nghiên cứu và sản phẩm thương mại được phát triển nhằm mục đích theo dõi tư thế ngủ. 
Trong đó, iSleePost là một hệ thống thiết bị đeo được phát triển bởi Po-Yuan Jeng 
và cộng sự \cite{Jeng}, gồm hai thiết bị đeo độc lập sử dụng cảm 
biến gia tốc để theo dõi và phân loại tư thế ngủ. 
Trong đó, một thiết bị được đeo ở cổ tay nhằm ghi nhận chuyển động, 
còn thiết bị thứ hai được gắn ở ngực để thu thập nhãn tư thế một 
cách tự động phục vụ huấn luyện mô hình. Dữ liệu từ cổ tay được xử lý 
bằng kỹ thuật cửa sổ trượt để trích xuất đặc trưng, 
sau đó ánh xạ với tư thế cơ thể dựa trên dữ liệu từ thiết bị ngực.
Một hướng tiếp cận khác, Zhang và cộng sự sử dụng duy nhất một thiết bị đeo gắn ở ngực, 
có tích hợp cảm biến gia tốc ba trục, để theo dõi cả tư thế ngủ và 
các chỉ số sinh lý như nhịp tim và nhịp thở \cite{Zhang_osa}. 
Trong nghiên cứu được thực 
hiện trên 7 tình nguyện viên khỏe mạnh trong điều kiện phòng lab, 
hệ thống sử dụng bộ phân loại tuyến tính (LDA) để nhận diện bốn tư 
thế ngủ phổ biến trong trạng thái tĩnh, kết hợp với thuật toán phát 
hiện chuyển động hiệu quả nhằm phân biệt giữa tư thế tĩnh và vận động.
Một hệ thống thiết bị đeo theo dõi tư thế ngủ (Wearable Sleep System – WSS), 
được Kwasnicki và cộng sự phát triển với thiết kế riêng biệt, 
gồm các cảm biến đeo trên mỗi cánh tay và vùng ngực, kết nối không dây 
với bộ xử lý trung tâm (trong nghiên cứu là máy tính xách tay) thông qua 
bộ thu phát sóng vô tuyến \cite{kwasnicki2018}. Nền tảng phần cứng của hệ thống sử dụng bộ vi 
xử lý tiêu thụ điện năng cực thấp TI MSP430, kết hợp với mô-đun truyền 
thông không dây Chipcon CC2420, cùng pin Li-ion polymer nhẹ. Mỗi nút cảm 
biến được tích hợp cảm biến gia tốc ba trục ADXL330, con quay hồi chuyển 
số ITG-3200, và cảm biến từ trường ba trục HMC5843. Toàn bộ mô-đun có kích 
thước 20×30×17 mm, trọng lượng 10 g. 
Trong nghiên cứu của Asma Channa và cộng sự \cite{Channa_osa}, 
một hệ thống theo dõi tư thế ngủ dựa trên công nghệ Internet vạn vật (IoT) 
đã được đề xuất, sử dụng hai thảm cảm biến áp lực thương mại để thu thập dữ 
liệu từ 13 người tham gia ở các tư thế ngủ khác nhau. Dữ liệu được xử lý 
bằng nhiều thuật toán học máy giám sát, trong đó các mô hình như Weighted 
KNN và Linear SVM đạt độ chính xác nhận dạng tư thế lên tới 98,7\%. 


Các nghiên cứu hiện nay đã phát triển nhiều hệ thống theo dõi tư thế ngủ với độ chính xác cao, sử dụng đa dạng nền tảng như thiết bị đeo tích hợp cảm biến gia tốc, PPG, ECG hoặc thảm cảm biến áp lực. Nhiều hệ thống đã chứng minh hiệu quả trong việc phân loại tư thế ngủ và ghi nhận các chỉ số sinh lý liên quan đến hội chứng ngưng thở khi ngủ tắc nghẽn (OSA).

Tuy nhiên, để đáp ứng yêu cầu triển khai thực tế tại nhà, các giải pháp cần được tiếp tục hoàn thiện theo hướng tối giản phần cứng, giảm số lượng cảm biến, đồng thời tối ưu mô hình học máy cho nền tảng tính toán giới hạn (TinyML). Việc xây dựng một quy trình thu thập và xử lý dữ liệu rõ ràng, có thể lặp lại, cũng đóng vai trò quan trọng trong việc đảm bảo tính ổn định và khả năng áp dụng rộng rãi.

Bám sát định hướng này, luận văn đề xuất một hệ thống sử dụng duy nhất một cảm biến gia tốc dán dưới hõm ức để phát hiện các tư thế ngủ liên quan đến OSA. Trên cơ sở dữ liệu thu được, mô hình học máy nhẹ sẽ được xây dựng và tối ưu, hướng tới việc phát triển thiết bị IoT nhỏ gọn, chi phí thấp, có khả năng ước lượng chỉ số AHI – phục vụ cho sàng lọc và theo dõi OSA tại nhà một cách hiệu quả.


\section{Ứng dụng cảm biến gia tốc trong đánh giá tư thế ngủ của người mắc OSA tại nhà}

Tư thế ngủ của con người thường được phân loại thành bốn nhóm chính: 
nằm ngửa, nghiêng trái, nghiêng phải và nằm sấp (Hình~\ref{4_tuthe}) \cite{4_ngu}. 
Việc phân biệt rõ ràng các tư thế này giúp nâng cao độ chính xác trong việc phân tích ảnh hưởng của 
tư thế đến các chỉ số sinh lý trong giấc ngủ.

\begin{figure}
		\centering
 		\includegraphics[width=\textwidth]{images/4ngu.png}
 		\vspace*{-7mm}
		\caption{Các tư thế ngủ cơ bản của con người}
		\label{4_tuthe}
\end{figure}

Việc theo dõi tư thế cơ thể đặc biệt hữu ích trong phát hiện 
và điều trị hội chứng ngưng thở khi ngủ phụ thuộc tư thế (positional OSA).
Hiểu được mối quan hệ giữa tư thế ngủ và rối loạn hô hấp sẽ mở ra hướng điều trị cá thể hóa, 
chẳng hạn như liệu pháp định hướng tư thế. 
Việc tích hợp cảm biến đeo được như miếng dán, vòng tay hoặc 
nhẫn thông minh không chỉ tăng sự tiện lợi khi theo dõi tại nhà mà còn cung cấp góc 
nhìn toàn diện về hướng cơ thể và chuyển động hô hấp trong suốt thời gian ngủ. 
Các đặc trưng như mức độ chuyển động khí quản và chu kỳ nỗ lực hô hấp 
có thể được sử dụng để ước lượng mức độ nghiêm trọng của OSA, 
từ đó hướng tới phát hiện chính xác hơn và quản lý cá nhân hóa cho từng bệnh nhân.

Nhiều phương pháp kỹ thuật đã được phát triển nhằm ghi nhận và phân tích tư thế 
ngủ một cách chính xác. Các hệ thống ghi hình sử dụng camera hồng ngoại có khả năng 
thu thập toàn bộ quá trình ngủ trong điều kiện ánh sáng thấp, 
trong khi đó, các cảm biến gia tốc ba trục (triaxial accelerometers) 
cho phép nhận diện sự thay đổi tư thế dựa trên dao động và gia tốc của cơ thể. 
Bên cạnh đó, các thiết bị tích hợp cảm biến áp suất cung cấp thông tin về 
sự phân bố trọng lực và áp lực tiếp xúc, từ đó suy luận tư thế ngủ một cách gián tiếp 
nhưng hiệu quả. Những hệ thống tiên tiến hơn còn kết hợp đa cảm biến và 
tích hợp nhiều phương pháp đồng thời, nhằm nâng cao độ tin cậy, 
tính định lượng và khả năng ứng dụng trong cả môi trường lâm sàng lẫn tại nhà. 
Theo S. Akbarian và đồng các tác giả đã đề cập đến phương pháp giám sát tư 
thế ngủ bằng máy ảnh hồng ngoại kết hợp với công nghệ học sâu (Deep learning) 
\cite{Akbarian_osa} có kết quả tốt nhưng có khó khăn để xác định các góc các khác nhau của khuôn mặt. 
Còn theo A. Channa, M. Yousuf và N. Popescu đã sử dụng cảm biến áp suất được gắn dưới đệm để theo dõi 
thư thế ngủ với 2048 điểm cảm biến \cite{Channa_osa}. 
Trong đó cảm biến gia tốc 3 trục được đánh giá là phương pháp hiệu quả, 
tiết kiệm chi phí và độ chính xác cao. Jeng PY và đồng nghiệp đã thực hiện phát 
triển chế tạo thiết bị đeo tay sử dụng cảm biến gia tốc kết hợp với 
thiết bị ở ngực để lấy nhãn cho dữ liệu. Các phương pháp học máy truyền thống 
được sử dụng với độ chính xác đánh giá 4 tư thế khi ngủ trên 85\% \cite{Jeng}.
Trong \cite{ji2022airline}, Ji et al. và cộng sự phát triển một dây đeo ngực 
tích hợp vào dây an toàn máy bay nhằm theo dõi giấc ngủ và sức khỏe 
hành khách. Hệ thống kết hợp cảm biến ECG mềm, dải đai áp điện và 
cảm biến gia tốc 3 trục để ghi nhận ECG, hô hấp và tư thế cơ thể. 
Việc tiếp xúc da là cần thiết để đảm bảo thu nhận chính xác các tín 
hiệu sinh lý.

Cách đặt và vị trí đặt cảm biến ảnh hướng rất lớn đến chất lượng, độ chính xác của phép đo. 
Theo đó vị trí xương ức cổ được xem là vị trí có thể thu được tín hiệu chính xác để đặt 
đơn cảm biến \cite{Zhang_osa}. Việc sử dụng nhiều cảm biến ở những vị trí khác như cổ tay, trán, … 
sẽ có thêm nhiều dữ liệu hữu ích để phân tích, đánh giá. 
Ngoài ra, hiện nay với sự phát triển vượt bậc của điện thoại di động, 
việc tận dụng cảm biến gia tốc 
ở ngay trên chính chiếc điện thoại cũng là giải pháp hữu hiệu \cite{sun2017sleepmonitor}. 
Nhóm tác giả trong \cite{Ferrer_osa} đã báo cáo nghiên cứu đánh giá tư thế ngủ 
của bệnh nhân sử dụng thiết bị di động đeo ở xương ức kết hợp với 
phần mềm trên nền tảng Android để thu thập lại dữ liệu kể cả khi tắt màn hình. 
Trong một nghiên cứu tiêu biểu, Natale và cộng sự đã khai thác các cảm biến tích 
hợp sẵn trên điện thoại iPhone để ước lượng các thông số liên 
quan đến chất lượng giấc ngủ, bao gồm tổng thời gian ngủ (Total Sleep Time – TST), 
độ trễ vào giấc (Sleep Onset Latency – SOL) và hiệu quả giấc ngủ (Sleep Efficiency – SE). 
Phương pháp tiếp cận này cho thấy tiềm năng trong việc sử dụng thiết bị di động 
như một công cụ theo dõi giấc ngủ tiện lợi và dễ tiếp cận, đặc biệt trong các nghiên 
cứu cộng đồng và ứng dụng tại nhà\cite{Natale_osa}. Đặc điểm của sử dụng tích hợp cảm biến gia tốc 
trên điện thoại là rất tiện lợi, sử dụng trực tiếp mà không cần phát triển phần cứng. 
Tuy nhiên, việc tiếp xúc điện thoại trực tiếp với cơ thể trực tiếp trong thời gian 
lâu cũng có gây những ảnh hưởng nhất định đến người dùng.

\begin{figure}[!ht]
		\centering
% 		\setlength{\abovecaptionskip}{1pt plus 3pt minus 2pt}
 		\includegraphics[width=\textwidth]{images/vị trí đặt cảm biến.png}
 		\vspace*{-7mm}
		\caption{Vị trí tối ưu để đặt cảm biến gia tốc}
		\label{position_sensor}
\end{figure}

Trong khuôn khổ luận văn, tác giả đề xuất thiết kế một thiết bị đeo 
tiếp xúc sử dụng cảm biến gia tốc được đặt tại vị trí xương ức cổ 
nhằm theo dõi và phân tích tư thế ngủ của người dùng. 
Vị trí này được lựa chọn không chỉ do tính ổn định trong 
quá trình ngủ mà còn thuận lợi để tích hợp thêm các cảm biến 
khác như cảm biến âm thanh và cảm biến nhiệt độ – phục vụ cho các mục tiêu nghiên 
cứu mở rộng của nhóm. Tín hiệu từ cảm biến gia tốc sẽ được 
thu thập dưới dạng ba trục không gian (x, y, z), phản ánh chuyển động và 
hướng trọng lực tương ứng với tư thế cơ thể trong suốt thời gian ngủ. 
Sau quá trình thu thập, dữ liệu gia tốc sẽ được xử lý sơ cấp bao gồm hiệu chỉnh, 
lọc nhiễu, và chuẩn hóa nhằm đảm bảo tính chính xác và đồng nhất giữa các mẫu đo. 
Tiếp theo, các đặc trưng định lượng (features) trong miền thời gian 
sẽ được trích xuất để phục vụ cho bài toán phân loại tư thế ngủ (ngửa, nghiêng trái, nghiêng phải, sấp). 
Các đặc trưng này cùng với dữ liệu gốc sẽ được lưu trữ trong hệ thống để phục vụ cho các bước phân tích tiếp theo, 
bao gồm huấn luyện mô hình học máy hoặc tích hợp với các chỉ số sinh lý khác trong đánh giá rối loạn giấc ngủ, 
đặc biệt là hội chứng ngưng thở khi ngủ (OSA) Hình~\ref{position_sensor}.

Cảm biến gia tốc là một thiết bị đo lường có khả năng phát hiện 
và ghi nhận gia tốc – tức là sự thay đổi vận tốc theo thời gian – 
của một vật thể trong không gian ba chiều. 
Với ưu điểm nhỏ gọn, tiêu thụ năng lượng thấp và chi phí hợp lý, 
cảm biến gia tốc được ứng dụng rộng rãi trong nhiều lĩnh vực 
như điện tử tiêu dùng, ô tô, công nghiệp, và đặc biệt là y học, 
trong các thiết bị theo dõi hoạt động và giấc ngủ.

Nguyên lý hoạt động của cảm biến gia tốc dựa trên 
\textbf{Định luật II Newton}:

\begin{equation}
F = ma
\end{equation}

Trong đó, $F$ là lực tác động lên một khối lượng $m$, tạo ra gia tốc $a$. Trong cấu trúc vi cơ điện tử (MEMS) của cảm biến gia tốc, một khối lượng nhỏ được treo bằng các thanh đàn hồi. Khi cảm biến chịu tác động gia tốc, khối lượng này dịch chuyển, gây ra sự thay đổi về đặc tính điện, chẳng hạn như: 01) thay đổi điện dung trong cảm biến kiểu điện dung (capacitive type); 02) thay đổi điện tích do hiệu ứng áp điện trong cảm biến kiểu áp điện (piezoelectric type); và 03) thay đổi điện áp trong các cảm biến điện trở áp (piezoresistive type).

Tín hiệu điện sinh ra từ quá trình này được khuếch đại và số hóa để xử lý trong các ứng dụng khác nhau. Chính khả năng chuyển đổi giữa năng lượng cơ học và điện học giúp cảm biến gia tốc hoạt động hiệu quả trong việc ghi nhận các trạng thái động học của vật thể, bao gồm: 01) dịch chuyển tuyến tính (linear movement), 02) góc nghiêng (tilt), 03) rung động (vibration), và 04) va chạm (shock) hoặc rơi tự do (free fall).

Trong lĩnh vực y sinh, đặc biệt là trong nghiên cứu về giấc ngủ và ngưng thở khi ngủ (OSA), cảm biến gia tốc được sử dụng để: 01) theo dõi tư thế ngủ (supine, prone, lateral); 02) ghi nhận chu kỳ chuyển động hô hấp; và 03) phát hiện dao động vùng khí quản nhằm xác định sự kiện ngưng thở hoặc giảm thở.

Nhờ khả năng tích hợp dễ dàng vào các thiết bị đeo (vòng tay, miếng dán, nhẫn), cảm biến gia tốc trở thành thành phần cốt lõi trong các hệ thống theo dõi không xâm lấn, hỗ trợ hiệu quả cho việc sàng lọc và đánh giá OSA tại nhà hoặc trong môi trường lâm sàng.
\begin{figure}[!ht]
		\centering
% 		\setlength{\abovecaptionskip}{1pt plus 3pt minus 2pt}
 		\includegraphics[width=\textwidth]{images/acce.png}
 		\vspace*{-7mm}
		\caption{Nguyên lý cơ bản của cảm biến gia tốc}
		\label{acce}
\end{figure}

Như minh họa trong Hình~\ref{acce}, khi cảm biến gia tốc chịu tác động từ một chuyển động, khối gia trọng (proof mass) sẽ dịch chuyển, làm lò xo kết nối bị biến dạng. Sự biến dạng này tạo ra một lực đàn hồi theo định luật Hooke, tỷ lệ thuận với độ giãn của lò xo. Áp dụng định luật II Newton, ta có mối quan hệ giữa lực, khối lượng và gia tốc như sau:

\begin{equation} F = m \cdot a \Rightarrow a = \frac{k \cdot \Delta l}{m} \end{equation}

Trong đó: \begin{itemize} \item $F$ là lực đàn hồi tác dụng lên khối gia trọng (N) \item $m$ là khối lượng của khối gia trọng (kg) \item $k$ là hệ số đàn hồi của lò xo (N/m) \item $\Delta l$ là độ biến dạng (thay đổi chiều dài) của lò xo (m) \end{itemize}

Phương trình trên cho thấy gia tốc có thể được tính toán gián tiếp thông qua độ biến dạng của lò xo, từ đó cho phép cảm biến gia tốc chuyển đổi dao động cơ học thành tín hiệu điện phục vụ cho việc đo đạc và phân tích chuyển động. Trong hệ tọa độ của cảm biến gia tốc ba trục, trục z thường nằm theo phương vuông góc với mặt phẳng ngang và sẽ chịu thêm tác dụng của trọng lực. Do đó, ở trạng thái cân bằng (khi thiết bị đứng yên và không có chuyển động nào khác), giá trị gia tốc đo được tại trục z sẽ xấp xỉ bằng gia tốc trọng trường $g$ (khoảng 9.81 m/s²). Đặc điểm này có thể được khai thác trong việc hiệu chuẩn cảm biến cũng như xác định tư thế không gian tương đối của thiết bị.

Trong khuôn khổ luận văn này, tác giả tập trung tìm hiểu và ứng dụng 
cảm biến gia tốc được chế tạo dựa trên công nghệ vi cơ điện tử (Micro-Electro-Mechanical Systems – MEMS). 
Đây là một công nghệ tiên tiến cho phép tích hợp các thành phần phần cứng siêu nhỏ và 
linh kiện điện tử ngay trên cùng một chip bán dẫn, với kích thước cấu trúc có thể dưới 
10 micromet. Một trong những ưu điểm nổi bật của cảm biến gia tốc MEMS là 
khả năng tích hợp trực tiếp lên bo mạch in (Printed Circuit Board – PCB), 
qua đó giảm thiểu thể tích chiếm dụng, tiết kiệm chi phí sản xuất và 
đơn giản hóa thiết kế hệ thống nhúng. Nhờ đó, công nghệ này đặc biệt phù hợp 
cho các ứng dụng trong thiết bị đeo cá nhân, điện thoại di động, và các 
hệ thống theo dõi sức khỏe thế hệ mới.


Dựa trên nguyên lý hoạt động, cảm biến gia tốc MEMS hiện được phân thành ba loại chính, mỗi loại ứng dụng một cơ chế vật lý khác nhau để chuyển đổi dao động cơ học thành tín hiệu điện \cite{Acce}\cite{cambien}.

Hiện nay, cảm biến gia tốc MEMS được chia thành ba loại chính dựa trên nguyên lý hoạt động. 01) Cảm biến gia tốc dựa trên hiệu ứng điện dung (Capacitive accelerometers): 
Đây là loại cảm biến phổ biến nhất trong các thiết bị điện tử tiêu dùng như điện thoại thông minh 
và thiết bị đeo. Nguyên lý hoạt động dựa trên sự thay đổi điện dung giữa 
các bản cực khi khối gia trọng dịch chuyển dưới tác dụng của gia tốc. 
Sự thay đổi này được chuyển đổi thành tín hiệu điện tỷ lệ với mức gia tốc tác động. 
02) Cảm biến gia tốc dựa trên hiệu ứng áp điện trở (Piezoresistive accelerometers): 
Trong loại cảm biến này, ứng suất cơ học tác động lên vật liệu bán dẫn 
sẽ làm thay đổi điện trở của nó – hiện tượng gọi là hiệu ứng áp điện 
trở. Đặc tính tuyến tính giữa lực và điện trở giúp loại cảm biến này 
hoạt động ổn định trong môi trường có điều kiện khắc nghiệt, đặc biệt là 
nhiệt độ cao. 03) Cảm biến gia tốc dựa trên hiệu ứng áp điện 
(Piezoelectric accelerometers): Loại cảm biến này dựa trên khả năng 
sinh điện tích của các tinh thể áp điện khi bị nén hoặc kéo. Điện tích 
sinh ra tỷ lệ với lực tác động, cho phép ghi nhận các dao động cơ học 
có tần số cao. Cảm biến áp điện thường được sử dụng trong các ứng dụng 
yêu cầu đo rung động chính xác.



\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{images/diendung.png}
	\vspace*{-7mm}
	\caption{Cấu trúc cảm biến gia tốc điện dung}
	\label{acce_mems}
\end{figure}




\textbf{Cảm biến gia tốc kiểu điện dung (Capacitive Accelerometers)}

\textit{Nguyên lý hoạt động}: Cảm biến gia tốc kiểu điện dung hoạt động dựa trên nguyên lý biến thiên điện dung giữa các bản cực trong cấu trúc tụ điện khi chịu tác động bởi gia tốc. Cấu hình cơ bản của cảm biến bao gồm một khối lượng vi mô (proof mass) được treo bằng hệ thống lò xo vi cơ (MEMS spring system), trong đó một đầu được cố định và đầu còn lại liên kết với bản cực di động của tụ điện. Khi có gia tốc tác động theo một phương nhất định, khối lượng này sẽ lệch khỏi vị trí cân bằng, làm thay đổi khoảng cách giữa các bản cực và kéo theo sự biến đổi điện dung. Biến thiên này được phát hiện thông qua mạch đo nhạy điện dung, sau đó được chuyển đổi thành tín hiệu điện tử tỷ lệ với độ lớn của gia tốc. 
Quá trình này cho phép cảm biến ghi nhận gia tốc theo thời gian 
thực với độ chính xác cao và độ nhiễu thấp. Hình~\ref{acce_mems} minh họa nguyên lý dịch chuyển khối lượng và sự thay đổi điện dung trong cấu trúc cảm biến gia tốc MEMS kiểu điện dung.


\begin{figure} [!]
		\centering
 		\includegraphics[width=\textwidth]{images/acce_aptro.png}
 		\vspace*{-7mm}
		\caption{Cấu trúc cảm biến áp trở}
		\label{acce_aptro}
  \FloatBarrier
\end{figure}

\textbf{Cảm biến gia tốc kiểu áp điện trở (Piezoresistive Accelerometers)}

\textit{Nguyên lý hoạt động}: Cảm biến gia tốc kiểu áp điện trở hoạt động dựa trên hiện tượng thay đổi điện trở của các phần tử nhạy cảm khi chịu ứng suất cơ học. Trong cấu hình tiêu chuẩn, các phần tử áp điện trở được gắn trực tiếp lên thanh dầm (cantilever) liên kết với một khối gia trọng được treo trong vùng đo. Khi có gia tốc tác động lên hệ thống, lực quán tính gây ra sự biến dạng cơ học của thanh dầm, từ đó làm thay đổi điện trở của các phần tử cảm biến. Để tăng độ chính xác và khuếch đại tín hiệu, cấu hình cảm biến thường được tích hợp trong một mạch cầu Wheatstone, giúp tối đa hóa độ nhạy và cải thiện tỷ số tín hiệu trên nhiễu (Signal-to-Noise Ratio – SNR) của phép đo (xem Hình~\ref{acce_aptro}).

Cảm biến áp điện trở có ưu điểm nổi bật trong việc ghi nhận các biến đổi gia tốc chậm và có thể hoạt động hiệu quả trong một dải đo rộng. Nhờ đó, loại cảm biến này đặc biệt phù hợp cho các ứng dụng cần đo dao động có biên độ hoặc tần số lớn, chẳng hạn như trong thử nghiệm va chạm, đo động học kết cấu, hoặc môi trường công nghiệp có điều kiện phức tạp. Ngoài ra, cảm biến cũng thể hiện khả năng ổn định tốt trước các dao động nhiệt của môi trường xung quanh.

Tuy nhiên, hạn chế chính của cảm biến kiểu áp điện trở nằm ở độ nhạy tương đối thấp khi đo các tín hiệu yếu hoặc biên độ dao động nhỏ. Điều này có thể làm giảm độ chính xác trong các ứng dụng yêu cầu độ phân giải cao. Bên cạnh đó, chi phí chế tạo và triển khai cảm biến áp điện trở thường cao hơn so với các cảm biến điện dung MEMS, khiến việc tích hợp vào các hệ thống nhúng hoặc thiết bị tiêu dùng gặp nhiều giới hạn về mặt kinh tế.

\begin{figure} [!]
		\centering
 		\includegraphics[width=\textwidth]{images/acce_apdien.png}
 		\vspace*{-7mm}
		\caption{Cấu trúc cảm biến áp điện}
		\label{acce_apdien}
  \FloatBarrier
\end{figure}

\textbf{Cảm biến gia tốc kiểu áp điện (Piezoelectric Accelerometers)}

\textit{Nguyên lý hoạt động}:Cảm biến gia tốc kiểu áp điện hoạt động dựa trên hiệu ứng áp điện của một số vật liệu đặc biệt như gốm sứ hoặc thạch anh. Khi các vật liệu này chịu ứng suất cơ học, chúng sẽ bị biến dạng và tạo ra điện thế trên bề mặt. Lượng điện tích sinh ra có độ lớn tỉ lệ thuận với lực tác động lên cảm biến, trong khi cực tính phụ thuộc vào hướng của lực. Một trong những ưu điểm nổi bật của cảm biến áp điện so với các loại cảm biến gia tốc khác là khối lượng nhẹ và khả năng đáp ứng tần số rất cao, có thể đạt đến mức hàng megahertz. Nhờ đó, cảm biến áp điện đặc biệt phù hợp cho các ứng dụng yêu cầu đo dao động nhanh, ngắn hạn trong môi trường khắc nghiệt hoặc cần độ chính xác cao về thời gian và tần số.

Tuy nhiên, cảm biến kiểu áp điện có trở kháng đầu ra rất cao và chỉ tạo ra điện áp nhỏ, điều này khiến tín hiệu dễ bị suy giảm hoặc nhiễu nếu không được xử lý đúng cách. Để đảm bảo chất lượng tín hiệu và giảm thiểu sai số do tải (loading error), hệ thống đo thường được tích hợp thêm các bộ khuếch đại chuyển đổi trở kháng chuyên dụng, chẳng hạn như bộ khuếch đại điện tích (charge amplifier) (xem Hình~\ref{acce_apdien}).



Trong khuôn khổ luận văn này, cảm biến gia tốc MEMS kiểu điện dung được lựa chọn vì có độ nhạy cao với chuyển động chậm và biên độ nhỏ – đặc trưng của thay đổi tư thế khi ngủ. Loại cảm biến này có kích thước nhỏ, tiêu thụ điện năng thấp, dễ tích hợp vào thiết bị đeo và cho tín hiệu ổn định trong theo dõi dài hạn. So với các loại cảm biến khác, điện dung MEMS có chi phí hợp lý, phù hợp với yêu cầu kỹ thuật và tính khả thi triển khai trong hệ thống theo dõi tư thế ngủ.

\section{Ứng dụng trí tuệ nhân tạo trong đánh giá tư thế ngủ và hỗ trợ chẩn đoán hội chứng ngưng thở khi ngủ (OSA)}
Trong những năm gần đây, các mô hình học máy và mạng nơ-ron đã được 
ứng dụng rộng rãi trong lĩnh vực y sinh, đặc biệt là trong bài toán 
phân loại tư thế ngủ và hỗ trợ chẩn đoán hội chứng ngưng thở khi ngủ 
(OSA). Trong các hệ thống học máy ứng dụng cho y sinh, quy trình 
phân tích tín hiệu thường tuân theo một chuỗi các bước: (1) thu thập 
dữ liệu cảm biến, (2) xử lý tín hiệu thô, (3) trích xuất đặc trưng 
có ý nghĩa, (4) lựa chọn mô hình học máy phù hợp, và cuối cùng là 
(5) đánh giá hiệu năng của mô hình trên tập kiểm thử.
Mỗi bước trong quy trình này đều có ảnh hưởng trực tiếp đến độ chính xác 
và tính ổn định của hệ thống. Đặc biệt, trong bối cảnh thiết bị đeo và 
hệ thống IoT có tài nguyên tính toán hạn chế, việc tối ưu hóa lựa chọn 
đặc trưng và sử dụng các mô hình nhẹ là yếu tố then chốt để đảm bảo 
khả năng triển khai thực tế mà vẫn duy trì hiệu quả phân loại tư thế 
ngủ phục vụ đánh giá OSA.



Nhìn chung, việc chẩn đoán hội chứng ngưng thở khi ngủ — đặc biệt pOSA — đòi hỏi 
một hệ thống giám sát có khả năng thu thập liên tục dữ liệu sinh lý, 
phân tích chính xác tư thế ngủ, và đưa ra cảnh báo kịp thời trong 
thời gian thực. Điều này đặt ra yêu cầu ngày càng cao đối với tính tối 
ưu của mô hình, tính gọn nhẹ của thiết bị phần cứng, và khả năng triển 
khai thực tế tại nhà. Trong bối cảnh đó, các mô hình học máy đang trở thành 
công cụ đắc lực để phân loại mức độ nghiêm trọng của OSA 
thông qua chỉ số AHI hoặc nhận diện tư thế ngủ dựa trên tín hiệu cảm biến. 
Đây là hướng tiếp cận liên ngành, kết hợp giữa y học giấc ngủ và 
trí tuệ nhân tạo ứng dụng \cite{osa_sanchez2025}. 
\subsection{Quy trình tổng quát trong hệ thống ứng dụng AI cho đánh giá OSA và phân loại tư thế ngủ}
\begin{table}[htbp]
\centering
\caption{Các bước chính trong hệ thống ứng dụng AI cho phân tích tư thế ngủ và hỗ trợ chẩn đoán OSA}
\label{tab:pipeline_steps}
\small
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|p{3.8cm}|p{9.2cm}|}
\hline
\textbf{STT} & \textbf{Giai đoạn} & \textbf{Mô tả tổng quát} \\
\hline
1 & \textbf{Thu thập tín hiệu} \newline (Data Acquisition) & Ghi nhận tín hiệu từ cảm biến như gia tốc ba trục, PPG, ECG hoặc áp lực. Thiết bị đeo nhỏ gọn, truyền dữ liệu qua BLE, tốc độ lấy mẫu 10–100 Hz. \\
\hline
2 & \textbf{Tiền xử lý tín hiệu} \newline (Preprocessing) & Lọc nhiễu (notch, bandpass), loại bỏ trôi nền, phân đoạn theo cửa sổ thời gian. Mục tiêu là làm sạch và ổn định dữ liệu đầu vào. \\
\hline
3 & \textbf{Trích xuất đặc trưng} \newline (Feature Extraction) & Tính toán các đặc trưng thời gian (mean, std, energy...) và tần số (FFT, wavelet), đại diện cho nội dung sinh lý trong từng đoạn tín hiệu. \\
\hline
4 & \textbf{Lựa chọn và huấn luyện mô hình} \newline (Model Selection \& Training) & Lựa chọn thuật toán học máy (SVM, RF, LR, NN nhẹ) phù hợp với bài toán phân loại tư thế và/hoặc đánh giá OSA. \\
\hline
5 & \textbf{Đánh giá hiệu năng} \newline (Evaluation) & Sử dụng các chỉ số đánh giá mô hình như Accuracy, Precision, Recall, F1-Score, AUC, confusion matrix. \\
\hline
6 & \textbf{Tối ưu mô hình} \newline (Model Optimization) & Ứng dụng kỹ thuật pruning, quantization (8-bit) để giảm kích thước và độ phức tạp mô hình nhằm phục vụ triển khai biên. \\
\hline
7 & \textbf{Triển khai thực tế} \newline (Deployment) & Triển khai mô hình trên vi điều khiển (MCU) hỗ trợ TinyML, tích hợp trong thiết bị đeo nhằm theo dõi tư thế ngủ và ước lượng AHI tại nhà. \\
\hline
\end{tabular}
\end{table}


Quy trình này có thể được điều chỉnh tùy theo loại tín hiệu đầu vào và 
mục tiêu phân tích cụ thể (nhận diện tư thế, phát hiện ngưng thở, 
theo dõi nhịp thở,...). Tuy nhiên, nguyên tắc cơ bản là đảm bảo tín 
hiệu đầu vào chất lượng cao và mô hình đủ nhẹ để triển khai thực tế (xem Bảng~\ref{tab:pipeline_steps}).



\textbf{Thu thập tín hiệu} là bước đầu tiên và đóng vai trò nền tảng 
trong toàn bộ quy trình phân tích tư thế ngủ, chẩn đoán hội chứng ngưng 
thở khi ngủ (OSA) bằng trí tuệ nhân tạo. Trong các hệ thống theo dõi tại 
nhà (HST), quá trình này được thực hiện thông qua các thiết bị đeo hoặc 
cảm biến gắn ngoài, với mục tiêu ghi nhận liên tục các tín hiệu sinh 
lý phản ánh hoạt động hô hấp, tuần hoàn và chuyển động cơ thể trong 
suốt giấc ngủ.
Tín hiệu được ghi nhận có thể bao gồm: gia tốc ba trục nhằm phát hiện 
chuyển động và tư thế nằm; tín hiệu PPG để đo nhịp tim và độ bão hòa oxy; 
tín hiệu ECG để đánh giá hoạt động điện tim; hoặc tín hiệu từ cảm biến hô 
hấp, cảm biến áp lực gắn trên giường để xác định tư thế ngủ qua phân 
bố trọng lực. Tuỳ vào mục tiêu nghiên cứu và cấu hình thiết bị, các tín 
hiệu này được lấy mẫu với tần số phù hợp, thường dao động từ 10 Hz đến 
500 Hz \cite{Sleep_Posture_Detection, Jeng, Zhang_osa, Ferrer_osa, Sang, osa_sanchez2025}.
Một trong những yêu cầu quan trọng của bước thu thập là đảm bảo tính 
ổn định và chất lượng của dữ liệu. Các cảm biến cần được gắn chắc chắn 
tại những vị trí tối ưu, chẳng hạn như vùng ngực, cổ tay hoặc hõm ức, 
để giảm thiểu nhiễu do chuyển động và duy trì tiếp xúc ổn định trong 
suốt quá trình theo dõi. Ngoài ra, hệ thống cũng cần đảm bảo khả năng 
lưu trữ hoặc truyền dữ liệu hiệu quả thông qua các giao thức không dây 
như Bluetooth Low Energy (BLE) hoặc Wi-Fi \cite{thuong_wear_paper, hst_wear_paper}.
Trong một số nghiên cứu gần đây, các hệ thống HST hiện đại đã sử dụng 
vi điều khiển công suất thấp tích hợp cảm biến gia tốc, cho phép truyền 
dữ liệu liên tục với mức tiêu thụ năng lượng tối ưu. Ví dụ, trong nghiên 
cứu \cite{Sleep_Posture_Detection}, thiết bị dán cổ tích hợp cảm biến gia 
tốc LIS2DH12 và vi điều khiển nRF5232 đã được sử dụng để thu tín hiệu ở 
tần số 100 Hz và truyền không dây qua BLE, đảm bảo dữ liệu ổn định và 
chính xác trong điều kiện thực tế tại nhà.

Chất lượng của dữ liệu thu được trong bước này ảnh hưởng trực tiếp đến 
hiệu quả của toàn bộ hệ thống. Do đó, quá trình thu thập tín hiệu cần 
được thiết kế sao cho vừa đáp ứng được yêu cầu về độ chính xác sinh lý, 
vừa đảm bảo tính khả thi khi triển khai lâu dài trong môi trường ngoài 
lâm sàng. Tuy nhiên, trong nhiều nghiên cứu hiện nay, cấu trúc phần mềm
cho quá trình thu thập và lưu trữ dữ liệu vẫn chưa được trình bày một 
cách đầy đủ và thống nhất. Các yếu tố như kiến trúc hệ thống 
(ứng dụng di động, web, hay máy chủ trung tâm), giao thức truyền thông 
(MQTT, HTTP), phương thức lưu trữ (cục bộ, cloud, hoặc cơ sở dữ liệu 
liên kết), cũng như các vấn đề liên quan đến mã hóa – bảo mật dữ liệu 
sức khỏe – và tuân thủ quy định của cơ quan chuyên môn (chuẩn HIPAA, GDPR, 
hoặc quy định y tế quốc gia) thường chưa được đề cập rõ ràng. 
Những yếu tố này có thể ảnh hưởng đến khả năng mở rộng, tích hợp, 
và ứng dụng thực tiễn của hệ thống trong môi trường chăm sóc sức khỏe 
tại nhà.


\subsubsection{Tiền xử lý dữ liệu}



\textbf{Tiền xử lý dữ liệu} là một giai đoạn quan trọng nhằm cải thiện 
chất lượng tín hiệu, chuẩn hóa định dạng đầu vào và đảm bảo tính đồng 
nhất của dữ liệu trước khi đưa vào mô hình học máy. Các kỹ thuật tiền xử 
lý phổ biến bao gồm lọc tín hiệu (filtering), nội suy (interpolation), 
chuẩn hóa dữ liệu (normalization), phân đoạn tín hiệu (Segmentation – Epoch Creation).

\textbf{Lọc tín hiệu} là bước đầu tiên trong tiền xử lý nhằm loại bỏ nhiễu khỏi 
các tín hiệu sinh lý như EEG, ECG, EMG, $\mathrm{SpO_2}$ và gia tốc. 
Các loại nhiễu thường gặp bao gồm: nhiễu điện lưới (50–60 Hz), 
chuyển động cơ thể (motion artifacts), nhiễu tần số cao và trôi đường 
cơ sở (baseline drift) \cite{rossi2023sleep, sheta2021osa }. 
Trong nghiên cứu của Sheta và cộng sự \cite{sheta2021osa}, tác giả đã sử 
dụng bộ lọc notch IIR bậc hai nhằm loại bỏ nhiễu điện lưới 60~Hz khỏi 
tín hiệu ECG — vốn là loại nhiễu phổ biến gây khó khăn cho việc phân 
tích và trích xuất đặc trưng hình thái. Kết quả cho thấy tín hiệu sau 
lọc cho chất lượng cao hơn đáng kể và cải thiện hiệu năng của các mô 
hình học máy trong chẩn đoán OSA.
Các kỹ thuật lọc phổ biến bao gồm notch filter 
(đặc biệt là IIR notch filter bậc hai) để loại bỏ nhiễu điện lưới, 
bandpass filter để giữ lại dải tần sinh lý, và 
các bộ lọc mượt như Butterworth bậc ba, median filter hoặc 
moving average filter.
Đối với tín hiệu gia tốc, các bộ lọc cần đảm bảo vừa loại bỏ nhiễu vừa 
bảo toàn các đặc trưng chuyển động. Trong đó, Kalman filter được sử dụng 
rộng rãi để làm mượt chuỗi tín hiệu thời gian và giảm nhiễu ngẫu nhiên, 
còn total variation filter được đánh giá cao trong việc bảo toàn biên 
chuyển động rõ nét \cite{kalman, sun2017sleepmonitor}. 
Việc lựa chọn bộ lọc phù hợp cần dựa trên đặc điểm của từng loại 
tín hiệu và mục tiêu phân tích cụ thể.

\textbf{Nội suy}
là bước cần thiết để chuẩn hóa chuỗi thời gian. Các phương pháp như 
cubic spline, piecewise cubic Hermite (PCHIP) hay linear interpolation 
thường được áp dụng để điều chỉnh các chuỗi dữ liệu về cùng tần số chuẩn, 
đảm bảo đầu vào đồng bộ cho mô hình học máy hoặc mạng nơ-ron. 
Ngoài ra, đối với các chuỗi tín hiệu rời rạc như nhịp RR từ ECG 
hoặc các chuỗi $\mathrm{SpO_2}$ có thể bị gián đoạn hoặc mất mẫu, 
kỹ thuật nội suy còn đóng vai trò quan trọng trong việc làm đầy các 
giá trị bị thiếu (missing/null values) và tái cấu trúc tín hiệu thành 
chuỗi liên tục, giúp mô hình học được đặc trưng đầy đủ hơn từ 
dữ liệu \cite{zou2024mbtcn}. 
Trong nghiên cứu \cite{olsen2024transfer}, 
cả hai tín hiệu gia tốc (ACC) và xung quang học (PPG) 
đều được nội suy để tạo thành chuỗi thời gian đồng nhất với 
tần số lấy mẫu 32 Hz. 
Đối với các tín hiệu có tần số cao hơn 32 Hz, 
một bộ lọc thông thấp (lowpass filter) được áp dụng trước khi giảm 
tần số (down-sampling) nhằm hạn chế hiện tượng aliasing. 
Ngược lại, các tín hiệu có tần số lấy mẫu thấp hơn 32 Hz được 
nội suy bằng phương pháp đa thức Hermite từng đoạn 
(PCHIP – Piecewise Cubic Hermite Interpolation Polynomial) 
để khớp với tần số mong muốn.

\textbf{Chuẩn hóa dữ liệu}  giúp đưa các đặc trưng đầu vào về cùng một miền giá trị, 
tránh hiện tượng các đặc trưng có biên độ lớn chi phối quá trình học. 
Một số phương pháp phổ biến bao gồm: Z-score normalization 
(chuẩn hóa về trung bình 0 và độ lệch chuẩn 1), 
min-max scaling (đưa về khoảng [0,1]), và robust scaling 
(dựa trên trung vị và IQR, phù hợp với dữ liệu có nhiễu hoặc ngoại lệ). 
Trong các nghiên cứu về OSA, chuẩn hóa đã được áp dụng cho nhiều 
loại tín hiệu như $\mathrm{SpO_2}$, PPG và gia tốc, giúp tăng độ ổn định 
mô hình và cải thiện tốc độ hội tụ khi huấn luyện mạng nơ-ron 
\cite{Sleep_Posture_Detection, Vu2025SleepPosition, rossi2023sleep}.

\textbf{Phân đoạn tín hiệu} là một bước thiết yếu trong xử lý tín 
hiệu sinh lý, đặc biệt trong các hệ thống theo dõi vị trí giấc ngủ và phát 
hiện ngưng thở khi ngủ (OSA). Mục tiêu của bước này là chia chuỗi dữ 
liệu liên tục thành các đoạn thời gian ngắn cố định (epoch), 
giúp mô hình học máy nhận diện hiệu quả các đặc trưng biến đổi theo 
thời gian. Thời lượng epoch thường phụ thuộc vào loại tín hiệu và 
mục tiêu phân tích: 30 giây cho EEG, 60 giây cho ECG và $\mathrm{SpO_2}$, 
5 phút cho HRV, hoặc các cửa sổ trượt ngắn để phát hiện sự kiện ngắn hạn. 
Trong một số trường hợp, việc phân đoạn còn dựa vào các đặc điểm sinh lý 
như đỉnh sóng R trong ECG. Sau khi phân đoạn, các bước tiền xử lý như lọc nhiễu, 
chuẩn hóa hoặc làm mượt được áp dụng trong từng đoạn để nâng cao c
hất lượng dữ liệu đầu vào cho mô hình học máy 
\cite{Sleep_Posture_Detection, Vu2025SleepPosition, HOANG2025116309, zou2024mbtcn, osa_sanchez2025}.

Tóm lại, tiền xử lý tín hiệu không chỉ giúp nâng cao chất lượng dữ liệu mà còn đảm bảo tính nhất quán đầu vào cho hệ thống học máy. Việc lựa chọn kỹ thuật tiền xử lý cần phù hợp với đặc điểm của từng loại tín hiệu và mục tiêu phân tích cụ thể.

\subsubsection{Trích xuất đặc trưng}
\textbf{Trích xuất đặc trưng} là một bước quan trọng nhằm biến đổi dữ liệu cảm biến
thô thành tập hợp các đặc trưng có ý nghĩa, phản ánh các mẫu hình sinh lý 
liên quan đến mục đích của nghiên cứu. Quá trình này giúp làm nổi bật 
những thông tin cốt lõi từ tín hiệu sinh học như ECG, PPG, 
$\mathrm{SpO_2}$, gia tốc hay tín hiệu hô hấp, phục vụ cho các mô hình 
học máy trong việc phân loại tư thế ngủ hoặc phát hiện hội chứng ngưng 
thở khi ngủ (OSA) \cite{hstSurvey, HOANG2025116309, Channa_osa, Uday, Sang}. 
Các đặc trưng thường được sử dụng bao gồm biến thiên 
nhịp tim (HRV), khoảng RR, biên độ sóng R từ tín hiệu ECG; các chỉ số 
thống kê, tần số và entropy từ tín hiệu $\mathrm{SpO_2}$; hoặc các đặc 
trưng phi tuyến và miền tần số như năng lượng phổ, thông số Hjorth từ EEG. 
Ngoài ra, các đặc trưng từ tín hiệu PPG và gia tốc như entropy, phương sai 
hoặc số lượng chuyển động cũng đóng vai trò quan trọng trong việc phản ánh 
mức độ rối loạn hô hấp trong giấc ngủ. Ngoài các đặc trưng truyền thống 
trong miền thời gian và tần số, các đặc trưng hỗn hợp như biến đổi 
wavelet đã chứng minh vai trò đặc biệt quan trọng trong việc mô tả 
tín hiệu sinh lý một cách toàn diện hơn. Cụ thể, biến đổi wavelet 
cho phép phân tích tín hiệu ở nhiều thang thời gian khác nhau, đồng thời 
bảo toàn được cả thông tin về thời điểm và cấu trúc tần số của tín hiệu. 
Điều này đặc biệt hữu ích trong bối cảnh tín hiệu sinh lý thường không 
ổn định (non-stationary), như tín hiệu ECG, PPG hoặc tín hiệu gia tốc 
trong quá trình theo dõi tư thế ngủ. Các hệ số wavelet thu được từ tín 
hiệu gốc có thể phản ánh rõ ràng sự thay đổi chu kỳ hô hấp, chuyển động 
cơ thể, cũng như các đặc điểm bất thường liên quan đến cơn ngưng thở khi 
ngủ. Nhờ đó, việc trích xuất đặc trưng wavelet đóng góp quan trọng vào 
hiệu suất của các mô hình phân loại tư thế ngủ và phát hiện OSA \cite{Sleep_Posture_Detection}.

\textbf{Gán nhãn (labeling)}
được thực hiện nhằm liên kết các phân đoạn tín hiệu với nhãn sự kiện 
hô hấp tương ứng như “Apnea”, “Hypopnea”, hoặc phân mức độ nặng của OSA 
như “Mild”, “Moderate”, “Severe”. Một số nghiên cứu còn mở rộng sang 
các nhãn liên quan đến chất lượng tín hiệu (“Good” vs. “Poor”), 
kiểu hô hấp (“Bình thường”, “Bất thường”), các nhãn liên quan đến tư thế ngủ.
 Việc gán nhãn đúng đắn giúp huấn luyện mô hình 
AI chính xác và đánh giá mức độ nghiêm trọng của OSA một cách hiệu quả. 
Tùy theo thiết kế nghiên cứu, nhãn có thể được gán thủ công dựa trên 
chuyên gia hoặc tự động đồng bộ với thiết bị tham chiếu như
camera, hệ thống PSG.

\textbf{Phát hiện đỉnh (peak detection)} là kỹ thuật thường được áp dụng 
để trích xuất thông tin từ tín hiệu dạng sóng, đặc biệt là ECG và PPG. 
Trong các nghiên cứu về OSA, đỉnh sóng R từ ECG thường được xác định 
để tính toán HRV, sử dụng các thuật toán như Pan–Tompkins, Hamilton 
hoặc ngưỡng thích nghi (adaptive threshold) \cite{osa_sanchez2025}. Với tín hiệu PPG, 
đỉnh tâm thu được phát hiện thông qua các thuật toán lặp hoặc 
wavelet nhị phân để xác định các khoảng thời gian giữa hai đỉnh 
(peak-to-peak intervals). Kỹ thuật này giúp nâng cao độ chính xác 
trong việc phát hiện các thay đổi sinh lý, góp phần cải thiện năng 
lực chẩn đoán tự động OSA trong các hệ thống ứng dụng trí tuệ nhân tạo.


\subsubsection{Lựa chọn và huấn luyện mô hình}
Các kỹ thuật học máy và kiến trúc mạng nơ-ron nhân tạo đã được 
ứng dụng hiệu quả trong các bài toán phân loại tư thế ngủ và chẩn đoán 
hội chứng ngưng thở khi ngủ (OSA). Học máy (Machine Learning – ML) cung 
cấp một tập hợp đa dạng các thuật toán cho phép khai thác mẫu hình từ 
dữ liệu cảm biến, hỗ trợ phát hiện những thay đổi trong tư thế cơ thể 
và các rối loạn hô hấp liên quan đến giấc ngủ. Trong khi đó, mạng nơ-ron 
nhân tạo (Artificial Neural Networks – ANN), đặc biệt là các kiến trúc 
sâu như CNN, LSTM hoặc hybrid CNN-LSTM, thể hiện ưu thế trong việc xử 
lý tín hiệu sinh lý phi tuyến, phức tạp, có độ biến thiên cao theo thời 
gian như ECG, $\mathrm{SpO_2}$ hay tín hiệu gia tốc ba trục.

Trong số các \textbf{thuật toán học máy truyền thống} được sử dụng phổ biến, 
Random Forest (RF) \cite{genuer2020random} nổi bật nhờ khả năng kháng chống lại quá khớp và độ chính xác cao. 
Trong nghiên cứu \cite{wang2023ml_wearable}, Wang và cộng sự đã ứng dụng RF để phân loại các trường hợp ngưng thở khi ngủ, đạt độ chính xác 93.88\%, độ nhạy 89.93\% và độ đặc hiệu 91.8\%. 
Một nghiên cứu khác \cite{yeo2022respiratory}, Yeo và cộng sự sử dụng RF cho nhiệm vụ phân loại sự kiện hô hấp, thu được độ chính xác 83\%, độ nhạy 99\% và F1-score 81\%. 
Mặc dù có sự khác biệt về nguồn dữ liệu và phương pháp trích chọn đặc trưng, RF vẫn cho thấy hiệu quả vượt trội khi 
so sánh với các thuật toán khác như SVM, LDA hay QDA \cite{wang2023ml_wearable}, \cite{yeo2022respiratory}, \cite{parbat2024multiscale}.

Bên cạnh đó, thuật toán SVM \cite{cortes1995svm} cũng đã được áp dụng nhằm xác định siêu phẳng tối ưu để phân loại các nhóm trong không gian đặc trưng. 
Trong nghiên cứu \cite{wang2023ml_wearable}, Wang cũng sử dụng thêm mô hình SVM và đạt độ chính xác 88,28\%, độ đặc hiệu 91,69\% và độ nhạy 83,94\%, 
cho thấy hiệu quả cao trong phát hiện ngưng thở khi ngủ, dù mô hình Random Forest thường có kết quả cao hơn.
Ở nghiên cứu \cite{yeo2022respiratory}, SVM đạt độ chính xác 83\% và hệ số Cohen’s kappa 0,53 trong phân loại sự kiện hô hấp theo từng phút. 
Trong \cite{parbat2024multiscale}, SVM được huấn luyện trên tín hiệu ECG một kênh, đạt độ chính xác 69,13\%, góp phần cải thiện hiệu suất của hệ thống phân loại khi tích hợp trong mô hình tổ hợp. 
Những kết quả này cho thấy SVM vẫn là một phương pháp có giá trị trong ứng dụng học máy cho chẩn đoán ngưng thở khi ngủ.

K-Nearest Neighbors (KNN) \cite{cunningham2007knn} là một thuật toán khác 
cũng thường xuyên được áp dụng trong các nghiên cứu 
về phát hiện ngưng thở khi ngủ \cite{wang2023ml_wearable}, \cite{jeon2020realtime}. 
Dựa trên nguyên lý đo độ tương đồng trong không gian đặc trưng, 
KNN phân loại một điểm dữ liệu mới dựa trên nhãn của các điểm lân cận gần nhất. 
Wang và cộng sự đã dùng mô hình KNN xử lý tín hiệu quang học PPG và đạt độ chính xác 85.06\%, với độ đặc hiệu 86.11\% và độ nhạy 83.72\% \cite{wang2023ml_wearable}. 
Trong khi đó, nghiên cứu \cite{jeon2020realtime} báo cáo hiệu quả vượt trội hơn với accuracy lên đến 95\%, đồng thời vẫn đảm bảo thời gian thực thi đáp ứng yêu cầu hệ thống. 
Thành công này được cho là đến từ khả năng đo lường chính xác độ tương đồng giữa dữ liệu quan sát và dữ liệu đã học, 
giúp mô hình KNN đưa ra dự đoán phù hợp với mức độ nghiêm trọng của OSA.

Bên cạnh các thuật toán truyền thống, mô hình XGBoost \cite{chen2016xgboost} cũng được đưa vào thử nghiệm trong nghiên cứu \cite{wang2023ml_wearable}
nhằm đánh giá khả năng phân loại các mức độ ngưng thở khi ngủ. 
Là một biến thể của thuật toán boosting, XGBoost được thiết kế tối ưu cho hiệu suất tính toán 
và có khả năng xử lý hiệu quả cả bài toán hồi quy và phân loại. 
Kết quả cho thấy XGBoost đạt độ chính xác 82.05\%, độ đặc hiệu 84.91\% và độ nhạy 78.42\%, 
cho thấy tiềm năng lớn của mô hình này trong ứng dụng lâm sàng, 
đặc biệt trong các hệ thống đòi hỏi cân bằng giữa độ chính xác và tốc độ huấn luyện.
Trong nghiên cứu \cite{yeo2022respiratory}, 
thuật toán Linear Discriminant Analysis (LDA) \cite{tharwat2017lda} được đánh giá là một phương pháp quan trọng. 
LDA sử dụng trung bình và ma trận hiệp phương sai của từng lớp để xác định ranh giới quyết định tối ưu, 
nhằm tối đa hóa sự phân biệt giữa các lớp và giảm thiểu phương sai nội bộ. 
Trong bối cảnh nghiên cứu, LDA cho thấy hiệu quả vượt trội trong phát hiện sự kiện hô hấp với độ chính xác 
81\%, độ nhạy 88\%, độ đặc hiệu 79\% và điểm F1 đạt 81\%.


\textbf{Học sâu (Deep learning - DL)}là một lĩnh vực thuộc học máy 
tập trung vào việc khai thác các mạng nơ-ron nhân tạo nhiều lớp để 
trích xuất đặc trưng và mô hình hóa dữ liệu phức tạp. Các mô hình học 
sâu đã chứng minh hiệu quả trong việc phát hiện tư thế ngủ, đánh giá tình trạng OSA. 
Học sâu cho phép phân tích các tín hiệu sinh lý không tuyến tính, 
có nhiễu và mang tính thời gian, chẳng hạn như tín hiệu PPG, ECG, 
SpO\textsubscript{2} và gia tốc kế.

Khác với các mô hình học máy truyền thống vốn đòi hỏi kỹ thuật 
trích xuất đặc trưng thủ công, các mạng học sâu có khả năng tự động 
học các đặc trưng biểu diễn từ dữ liệu đầu vào thô thông qua quá 
trình huấn luyện. Điều này đặc biệt hữu ích trong phát hiện hội 
chứng ngưng thở khi ngủ (OSA – \textit{Obstructive Sleep Apnea}), 
nơi tín hiệu thu nhận từ thiết bị đeo thường biến thiên theo tư thế, 
giai đoạn ngủ và tình trạng sinh lý của từng bệnh nhân.

Trong các ứng dụng chẩn đoán OSA, nhiều kiến trúc học sâu đã được đề xuất và triển khai, 
bao gồm mạng nơ-ron tích chập (Convolutional Neural Networks – CNN), 
mạng nơ-ron hồi tiếp (Recurrent Neural Networks – RNN) với các biến 
thể như LSTM (Long Short-Term Memory) và GRU (Gated Recurrent Unit), 
mạng nơ-ron truyền thẳng (Feedforward Neural Networks – FNN), 
và mạng perceptron đa tầng (Multilayer Perceptron – MLP). 
Ngoài ra, các mô hình học chuyển tiếp (Transfer Learning) 
sử dụng các kiến trúc sâu như ResNet và ResNeXt cũng được chứng 
minh mang lại hiệu quả cao trong bối cảnh dữ liệu hạn chế 
\cite{osa_sanchez2025, wang2023ml_wearable, rossi2023sleep, olsen2024transfer}. 
Gần đây, các mô hình kết hợp giữa học sâu và phương pháp phân 
cụm phân cấp (Hierarchical Deep Clustering – HDC) cũng được 
áp dụng nhằm giảm chi phí tính toán và mở rộng khả năng triển 
khai trên các thiết bị vi xử lý nhúng.

Trong \cite{rossi2023sleep}, Rossi và cộng sự đã phát triển một mô hình mạng nơ-ron sâu 
(DNN) được phát triển 
để xử lý tín hiệu siêu âm
thu từ cảm biến đeo ngực, theo hướng kết hợp đa cảm biến. 
Mô hình được thiết kế cho bài toán phân loại ba chiều: 
chất lượng tín hiệu, các mẫu hô hấp và các mẫu giấc ngủ. 
Mô hình đạt độ chính xác 96\% trong phân biệt tín hiệu nhiễu 
và bình thường, với độ chính xác cao hơn trong dự đoán mẫu 
hô hấp (0.93) so với mẫu giấc ngủ (0.76).
Trong \cite{olsen2024transfer}, một mạng nơ-ron tích chập sâu (CNN) 
được triển khai nhằm phân loại các giai đoạn ngủ và phát hiện ngưng 
thở khi ngủ từ thiết bị CST (consumer sleep technologies) đeo tay, 
sử dụng tín hiệu từ cảm biến gia tốc và PPG. Mô hình gồm hai luồng 
xử lý riêng biệt, và kết quả cho thấy hiệu suất được cải thiện khi 
sử dụng dữ liệu thô, đặc biệt trong phát hiện sự kiện apnea trong 
giấc ngủ REM. 
Ji et al và cộng sự triển khai mô hình Long Short-Term Memory (LSTM) 
– một dạng mạng nơ-ron hồi tiếp (RNN) – 
nhằm phân tích chuỗi tín hiệu sinh lý phục vụ phát hiện hội chứng ngưng thở – 
giảm thở khi ngủ (SAHS) \cite{ji2022airline}. 
Mô hình gồm ba lớp lặp LSTM kết hợp với bốn lớp kết nối đầy đủ, 
có số nút lần lượt là 128, 64, 32 và 1. Kết quả cho thấy mô hình 
đạt độ chính xác trung bình từ 84–85\%, khẳng định tính hiệu quả 
của kiến trúc LSTM trong việc nhận dạng các đặc trưng liên quan 
từ dữ liệu tuần tự.
Tổng thể, các mô hình học sâu như CNN, LSTM và các biến thể kết hợp đã 
chứng minh hiệu quả vượt trội trong việc phát hiện OSA từ các tín hiệu 
sinh lý đa dạng. Tuy nhiên, thách thức về chi phí tính toán, 
dung lượng bộ nhớ và khả năng triển khai thực tế trên thiết bị 
đeo yêu cầu các hướng nghiên cứu tối ưu hóa mô hình và giảm độ phức tạp.

Tập trung vào mục tiêu phát hiện các hoạt động thường ngày và 
tư thế ngủ của con người, rất nhiều nghiên cứu gần đây 
đã ứng dụng các phương pháp học máy và trí tuệ nhân tạo để xây dựng 
hệ thống nhận dạng từ dữ liệu cảm biến đeo được. 
\textit{Bảng \ref{tab:sleepml}} dưới đây tổng hợp một số nghiên cứu 
tiêu biểu trong lĩnh vực này, bao gồm cả các mô hình học máy truyền 
thống (như cây quyết định, KNN, SVM) và các phương pháp học sâu 
(CNN, LSTM). Các hệ thống được triển khai với mục đích phân loại tư 
thế ngủ hoặc hoạt động thể chất, sử dụng nhiều loại dữ liệu cảm biến 
khác nhau như gia tốc ba trục, tín hiệu quang học (PPG) hoặc đặc 
trưng miền thời gian. Nhiều nghiên cứu cũng đã chú trọng đến việc 
triển khai mô hình trên thiết bị nhúng (on-chip), nhằm hướng đến khả 
năng theo dõi tại nhà trong thời gian thực với chi phí và mức tiêu 
thụ năng lượng thấp.

\begin{table}[htbp]
\centering
\caption{Hiệu quả mô hình học máy và khả năng triển khai biên trong nhận diện tư thế ngủ}
\label{tab:sleepml}
\small
\renewcommand{\arraystretch}{1.2}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|p{2.2cm}|p{2.2cm}|p{2.7cm}|p{3.3cm}|c|c|p{1.2cm}|}
\hline
\textbf{Tài liệu} & \textbf{Dữ liệu} & \textbf{Nhiệm vụ} & \textbf{Đặc trưng} & \textbf{Mô hình} & \textbf{Độ chính xác} & \textbf{Phần mềm} & \textbf{On-chip} \\
\hline
\cite{abdulsadig2023} & 18 đối tượng & Tư thế ngủ & 12 đặc trưng miền thời gian & DT, Extra-Trees, LSTM-NN & $>$98\% & NM & Có \\
\cite{Jeng} & Không nêu & Tư thế ngủ & NM & RF, SVM & 85\% & Có & Không \\
\cite{vu2023} & 561.859 mẫu & Tư thế ngủ & NM & LSTM\_sq, CNN, MLP, LSTM\_con & $>$99\% & Không & Không \\
\cite{kwasnicki2018} & 16 đối tượng & Tư thế ngủ & Trung bình, 3 trục & Ngưỡng cố định & 99.5\% & Không & Không \\
\cite{elnaggar2023} & 5 đối tượng & Tư thế ngủ & NM & Ngưỡng cố định & $>$99.2\% & Không & Không \\
\cite{gomes2021} & 8 đối tượng & Hoạt động người dùng & Trung bình, Độ lệch chuẩn (6) & KNN, RF, SVM & 97\% & Không & Không \\
\cite{dao2022} & Public + 20 private & Hoạt động người dùng & 31 đặc trưng miền thời gian & RF & 97\% & Có & Không \\
\cite{souza2017} & 10 đối tượng (public) & Hoạt động người dùng & 11 đặc trưng miền thời gian & KNN, NB, SVM, CTree, RF & 98\% & Không & Không \\
\hline
\multicolumn{8}{l}{\footnotesize NM = Không đề cập; DT = Decision Tree; CNN = Convolutional Neural Network; MLP = Multilayer Perceptron;} \\
\multicolumn{8}{l}{\footnotesize LSTM = Long Short-Term Memory; RF = Random Forest; SVM = Support Vector Machine; NB = Naive Bayes; CTree = Conditional Inference Tree.}
\end{tabular}
}
\end{table}


Sự phát triển nhanh chóng của trí tuệ nhân tạo (AI) trong lĩnh vực y học 
đã mở ra nhiều hướng tiếp cận mới trong việc đánh giá tư thế ngủ và 
chẩn đoán OSA. Các hệ thống AI đang dần chứng minh hiệu quả vượt trội 
trong việc xử lý dữ liệu cảm biến lớn và phức tạp, từ đó cung cấp các 
phân tích chính xác về hành vi giấc ngủ của bệnh nhân. Các mô hình học 
máy được huấn luyện trên tập dữ liệu cảm biến từ accelerometer, gyroscope 
hoặc thiết bị đeo thông minh có thể tự động phân loại các tư thế ngủ 
theo thời gian thực, với độ chính xác lên đến trên 90\% trong nhiều 
nghiên cứu gần đây 
\cite{Sleep_Posture_Detection}\cite{Vu2025SleepPosition}\cite{HOANG2025116309}.

\textbf{Tiny Machine Learning (TinyML)} là lĩnh vực nghiên cứu và ứng dụng các 
mô hình học máy có kích thước nhỏ gọn, tiêu thụ năng lượng thấp, 
được triển khai trực tiếp trên các thiết bị nhúng như vi điều khiển 
(microcontrollers – MCU) hoặc thiết bị đeo (wearables) \cite{ray2021tinyml}. 
Không giống như các mô hình học máy truyền thống thường yêu cầu nền 
tảng phần cứng mạnh và tính toán trên cloud, TinyML cho phép xử lý dữ 
liệu tại chỗ (on-device inference) mà không cần kết nối internet, 
nhờ đó nâng cao tính riêng tư, độ phản hồi thời gian thực và khả năng 
hoạt động ngoại tuyến.

Trong lĩnh vực chăm sóc sức khỏe, TinyML ngày càng được ứng dụng rộng 
rãi để phân tích các tín hiệu sinh lý như nhịp tim, hô hấp, chuyển động 
và tư thế ngủ. Với ưu điểm là tiết kiệm năng lượng và chi phí, 
các mô hình TinyML rất phù hợp cho các hệ thống theo dõi lâu dài, 
ví dụ như phát hiện ngưng thở khi ngủ (OSA) bằng cảm biến đeo tại nhà. 
Các thuật toán thường được sử dụng trong TinyML bao gồm các biến thể đơn giản hoá của CNN, 
LSTM hoặc các mô hình cây quyết định nhẹ như Decision Tree, Random Forest và Gradient Boosting 
đã được tối ưu hoá cho các nền tảng hạn chế tài nguyên.
Gần đây, các công cụ như TensorFlow Lite for Microcontrollers, 
Edge Impulse, và TinyML EON Compiler cho phép huấn luyện, 
chuyển đổi và triển khai các mô hình AI chỉ trong vài kilobyte bộ nhớ, 
mở ra cơ hội mới cho chẩn đoán y tế cá nhân hoá dựa trên thiết bị đeo thông minh.

Nhờ vào khả năng học và tự hiệu chỉnh, các thuật toán này có thể phân 
biệt hiệu quả giữa các trạng thái nằm nghiêng trái, nghiêng phải, nằm ngửa và nằm sấp – 
ngay cả khi có sự biến đổi nhẹ về góc độ hoặc cử động cơ thể. 
Hơn nữa, AI còn cho phép tích hợp thông tin về tư thế ngủ với các chỉ số sinh lý 
khác như nhịp tim, nhịp thở, SpO$_2$ và dữ liệu âm thanh để xây 
dựng mô hình chẩn đoán OSA đa chiều. Việc kết hợp các nguồn dữ liệu 
này giúp phát hiện chính xác các giai đoạn ngưng thở và giảm thở, 
đồng thời đánh giá được mức độ ảnh hưởng của từng tư thế đến tình trạng 
hẹp đường thở trong khi ngủ. Đây là một bước tiến quan trọng hướng đến 
cá nhân hóa chẩn đoán và điều trị OSA – điều mà các phương pháp truyền thống 
như đa ký giấc ngủ (polysomnography) còn nhiều hạn chế do chi phí cao và 
điều kiện thực hiện phức tạp. Đặc biệt, các hệ thống AI có thể được 
triển khai trong các thiết bị đeo thông minh tại nhà, hỗ trợ theo dõi 
lâu dài và liên tục mà không gây xâm lấn hay gián đoạn giấc ngủ. 
Nhờ đó, dữ liệu thu thập được phản ánh chính xác hơn về hành vi giấc 
ngủ trong môi trường tự nhiên của người bệnh, từ đó nâng cao giá trị 
lâm sàng của các kết quả phân tích. Ngoài ra, sự tích hợp AI trong các 
thiết bị di động, cùng với công nghệ điện toán biên (edge computing), 
có thể cho phép xử lý dữ liệu tại chỗ và phản hồi thời gian thực – 
mở ra tiềm năng to lớn trong việc sàng lọc, theo dõi và cá nhân hóa 
chiến lược quản lý OSA.

















% \section{Cơ chế giả lập hành vi\label{mock_mechanism}} 
% % Từ khóa sử dụng: mock, mocking, mock data, HTTP Request, caller, callee, API method
% \input{chapters/examples/example_code_new}
% Quá trình thực thi kiểm thử cần được đảm bảo là độc lập và nhanh chóng \cite {clean_coder}. Để làm được điều này, chúng ta có thể áp dụng cơ chế giả lập hành vi cho một số hàm hoặc phương thức tương tác với thành phần bên ngoài như cơ sở dữ liệu, dịch vụ bên thứ ba, v.v. Cơ chế giả lập hành vi (\textit{\gls{mocking}}) được sử dụng để cài đặt các hàm hoặc phương thức với các hành vi mới. Thay vì truy cập các tài nguyên từ xa như trang Web hoặc cơ sở dữ liệu, các nhà phát triển hoặc người kiểm thử có thể thay thế hành vi mới của hàm/phương thức bằng cách sử dụng dữ liệu giả (\textit{\gls{mockdata}}). \Gls{mockdata} được cố ý chèn vào một phần trong mã nguồn. Nó thường được sử dụng như là kết quả của các phương thức hoặc hàm. Nó có nghĩa là những phương thức/hàm này được thay đổi hành vi để phù hợp với việc thực thi kiểm thử. Để đơn giản, thuật ngữ \textit {``\gls{mocked_method}"} dùng để chỉ một phương thức kết nối với các tài nguyên từ xa và phải được thay đổi hành vi. Sử dụng cơ chế \gls{mocking} có hai lợi ích chính là quá trình kiểm thử trở nên nhanh chóng và độc lập, điều này cần có trong các nguyên tắc FIRST \cite {clean_coder}. 

% Ưu điểm đầu tiên của việc sử dụng cơ chế \gls{mocking} là nhanh chóng. Kỹ thuật này làm giảm chi phí tính toán để thực thi dữ liệu thử nghiệm. Nếu không áp dụng cách thức này, việc kết nối với các tài nguyên từ xa có thể gặp phải một số sự cố do kết nối mạng kém hoặc không khả dụng. Thay vì đợi phản hồi từ các tài nguyên từ xa, các phương thức có thể trả về nhanh chóng \gls{mockdata}. Một lợi thế khác của việc sử dụng cơ chế \gls{mocking} là đảm bảo tính độc lập. Nó giúp duy trì tính nhất quán của cơ sở dữ liệu khi thực thi dữ liệu thử nghiệm nhiều lần. Khi một ứng dụng Web doanh nghiệp được triển khai, hầu hết các API có thể yêu cầu một số thay đổi tương tác với cơ sở dữ liệu. Tuy nhiên, trong môi trường thử nghiệm, việc thực thi thử nghiệm không được tác động đến cơ sở dữ liệu để duy trì tính nhất quán của dữ liệu gốc. Thay vì thực hiện hành vi thực tế, các phương thức có thể trả về \gls{mockdata} ngay lập tức. Do đó, việc thực thi thử nghiệm sẽ không bao giờ thực hiện bất kỳ cập nhật nào đối với cơ sở dữ liệu.

% Để làm rõ hơn cơ chế \gls{mocking} được sử dụng như thế nào trong thực tế, ví dụ trong Mã nguồn~\ref{api_example} và Mã nguồn~\ref{mock_example} thể hiện một trường hợp cần phải dùng tới cơ chế này. Ví dụ đầu tiên Mã nguồn~\ref{api_example} có API $``/search"$ lấy dữ liệu từ tài nguyên bên ngoài bằng cách gọi phương thức $get()$ (dòng \ref{lst_exp_start_uncover}). Bên cạnh đó, Mã nguồn~\ref{mock_example} trình bày một ca kiểm thử có sử dụng \gls{mocking} cho API $``/search"$  trong Mã nguồn~\ref{api_example}. 
% Để đơn giản hóa, nếu phương thức $m_1$ gọi phương thức $m_2$, $m_1$ và $m_2$ tương ứng được gọi là
% \textit{``caller"} và \textit{``callee"}.

% \input{chapters/examples/example_test_data}
% Thứ nhất, Mã nguồn~\ref{api_example} thể hiện một ví dụ cần phải sử dụng cơ chế \gls{mocking} khi thực thi kiểm thử. Ví dụ này có một phương thức chính ($searchMasterData()$) và hai phương thức phụ ($get()$ và $checkRequired()$). Chúng là những đại diện điển hình của mã nguồn dự án được sử dụng làm thực nghiệm trong Mục~\ref{experiment_section} Mỗi phương thức đều có những đặc điểm riêng biệt. Đầu tiên, phương thức chính ($searchMasterData()$) được đánh dấu với ký hiệu $@Post("search")$ cung cấp bởi thư viện NestJS (dòng \ref{declare_api_method}). Điều này có nghĩa là phương thức này tương ứng với một API. API này có thể được lựa chọn nằm trong môi trường kiểm thử. Phương thức này gọi tới hai phương thức khác: phương thức $get()$ để lấy kết quả phản hồi từ một cơ sở dữ liệu (dòng \ref{lst_exp_start_uncover}) và phương thức thứ hai $checkRequired()$ để kiểm tra lại tính hợp lệ của dữ liệu đầu vào (dòng \ref{lst_exp_check_require}). 
% Ngoài ra, phương thức đầu tiên ($get()$) kết nối với máy chủ cơ sở dữ liệu từ xa bằng cách sử dụng đối tượng $httpService$ với phương thức $post()$ để gửi POST Request (dòng \ref{call_http_service}). Phương thức này cần được thiết lập hành vi giả trong tệp kiểm thử. Liên quan đến vấn đề này, kiểu trả về của phương thức này có cấu trúc lớp $AxiousResponse$ bao gồm một số thuộc tính như là $data, headers,config, status$, và $statusText$ \footnote{https://github.com/axios/axios\#response-schema}. Những thuộc tính này cần được cung cấp trong \textit{mock data} để thỏa mãn yêu cầu về kiểu trả về của phương thức. Cuối cùng, phương thức $checkRequired()$ là một phương thức bình thường có nhiệm vụ là kiểm tra sự tồn tại của một thuộc tính đặc biệt trong đầu vào. Vì vậy, nó không cần thiết phải áp dụng cơ chế \gls{mocking} trong tệp thực thi kiểm thử.
% % The caller is an API that needs to be tested and it calls the callee which connects to a remote database.
% % As a result, the consistency of data could be impacted during test execution. Therefore, the actual implementation of this callee has to be replaced by using mock data

% Thứ hai, Mã nguồn~\ref{mock_example} trình bày ví dụ một tập lệnh cho một ca kiểm thử cho API $@Post("search")$ trong Mã nguồn~\ref{api_example}. Tập lệnh này có sử dụng cơ chế \gls{mocking} cho phương thức truy cập đến có sở dữ liệu  $get()$. Đây là ví dụ một khối lệnh viết bằng ngôn ngữ Typescript để xây dựng một ca kiểm thử cho một API trong ứng dụng NestJS. API được gọi với đầu là một HTTP Request có chứa dữ liệu kiểm thử ảnh hưởng đến luồng thực thi của chương trình. Khối lệnh này có cấu trúc bao gồm ba phần: Khai báo giá trị đầu vào (dòng \ref{input_declaration}), khai báo \textit{mock data}  (dòng \ref{mock_declare_response}-\ref{mock_spy}), và lời gọi API (dòng \ref{begin_test_driver}-\ref{end_test_driver}).
% Như đã đề cập ở trước đó, phương thức $get()$ kết nối tới máy chủ cơ sở dữ liệu và cần được thiết lập hành vi thay thế. Vì vậy, \textit{mock data} được cung cấp (dòng \ref{mock_declare_response}-\ref{mock_spy}). Ở khía cạnh đầu tiên, nếu cơ chế \gls{mocking} không được áp dụng, phương thức $get()$ sẽ gửi một POST Request tới máy chủ từ xa dẫn đến tốn thêm thời gian để đợi phản hồi. Thêm vào đó, nếu máy chủ đang không khả dụng, giá trị thuộc tính $status$ của biến $ret$ trong Mã nguồn~\ref{api_example} luôn luôn khác $200$. Điều này có nghĩa là biểu thức điều kiện $ret.status == 200$ luôn luôn nhận giá trị $false$ (dòng \ref{lst_exp_200} trong Mã nguồn~\ref{api_example}), khiến một số câu lệnh không thể được thực thi khi chạy kịch bản kiểm thử (dòng \ref{lst_exp_hidden_code},\ref{lst_exp_end_uncover} trong Mã nguồn~\ref{api_example}). 
% Ở khía cạnh khác, cơ chế \gls{mocking} cần được áp dụng để đảm bảo cơ sở dữ liệu không bị ảnh hưởng (dòng \ref{mock_spy}). \Gls{mockdata} của phương thức $get()$  là giá trị của biến $response$ bao gồm tất cả những thuộc tính cần thiết như là $data, headers,config, status$, và $statusText$ (dòng \ref{mock_declare_response}). Những giá trị này sẽ giúp chương trình thực thi nhiều câu lệnh hơn. 

% Trên thực tế, \gls{mockdata} thường được các nhà phát triển hoặc người thử nghiệm sửa đổi dựa trên kinh nghiệm của họ. Bởi vì luồng thực thi có thể phụ thuộc vào cách các phương thức được giả lập, \gls{mockdata} có thể ảnh hưởng đến phạm vi bao phủ. Do đó, các nhà phát triển hoặc người kiểm tra cần phải hiểu rõ ràng về mã nguồn để thiết lập \gls{mockdata} phù hợp nhằm đạt được độ phủ cao hơn.

% \section{Kiểm thử ứng dụng Web}
% Cách đơn giản nhất để kiểm thử một ứng dụng Web là kiểm thử viên sẽ thực hiện các thao tác nhấp chuột thủ công trên giao diện của hệ thống và đánh giá cách ứng dụng phản hồi. Đây là phương pháp kiểm thử hộp đen \cite{black_box_testing} vì kiểm thử viên không cần biết chi tiết nội hàm của chương trình ứng dụng. Họ chỉ cần quan tâm xem với một đầu vào cụ thể, ứng dụng có thực thi hành vi đúng như đặc tả hay không. Phương pháp kiểm thử này dễ dàng thực hiện được vì không cần bất cứ thiết lập nào trước đó. Tuy nhiên, nó có thể bị ảnh hưởng bởi những lỗi liên quan đến người thực hiện kiểm thử. Ngoài ra, quá trình này cũng tốn rất nhiều thời gian và công sức khi mà tổ hợp các kịch bản người dùng thực hiện trên giao diện là một con số rất lớn. Điều này trở nên thách thức hơn khi mã nguồn luôn luôn có sự thay đổi, quá trình kiểm thử hồi quy cần được thực hiện liên tục để kiểm tra lại các thành phần trước đó vẫn hoạt động đúng như ban đầu. Vì vậy, việc kiểm thử đầy đủ nếu chỉ dựa vào kiểm thử thủ công trên giao diện là không hiệu quả.

% Thay vì kiểm thử viên nhấp chuột thủ công để kiểm thử hệ thống, họ có thể viết các dữ liệu kiểm thử sử dụng trình điều khiển Web. Trình điều khiển Web thực hiện lần lượt các bước mô tả trong dữ liệu kiểm thử và kiểm tra hành vi của hệ thống. Quá trình thực thi các dữ liệu kiểm thử này có thể được tự động hóa cho nên nó có thể tiết kiệm thời gian cho kiểm thử viên ở giai đoạn thực thi hệ thống. Những dữ liệu kiểm thử có thể được tái sử dụng cho những lần kiểm thử hồi quy sau này. Tuy nhiên, về bản chất, việc xây dựng và viết mã lệnh cho các dữ liệu kiểm thử vẫn phải thực hiện thủ công. Đây là công việc rất tốn thời gian và nguồn nhân lực, đòi hỏi lập trình viên có kiến thức về trình điều khiển Web. Để kiểm thử đầy đủ cho một ứng dụng Web, số lượng dữ liệu kiểm thử là rất lớn. Vì vậy, trong thực tế, danh sách dữ liệu kiểm thử thường không đầy đủ dẫn đến một số lỗi tiềm ẩn trong chương trình không thể phát hiện và thường bị bỏ qua.

% Với những hạn chế như đã được để cập ở trên, việc sinh dữ liệu kiểm thử cần được tự động hóa sao cho đảm bảo tính hiệu quả để tiết kiệm thời gian và chi phí cho doanh nghiệp phát triển phần mềm. Đây cũng là một trong những mảng nghiên cứu khá là quan trọng, dành được nhiều sự quan tâm của các nhà nghiên cứu trong lĩnh vực công nghệ phần mềm. Việc kiểm thử cho ứng dụng Web hiện nay gặp phải một số thách thức \cite{web_testing_1, web_testing_2}. Hiện tại, quá trình nghiên cứu các phương pháp tự động hóa sinh dữ liệu kiểm thử cho ứng dụng Web cũng đã đạt được một số kết quả nhất định. Có thể kể đến một số dự án nổi bật như là Artemis\cite{artermis}, Crawljax \cite{crawljax}, và SymJS \cite{symjs}. Artemis là một công cụ hỗ trợ kiểm thử tự động cho ứng dụng Javascript, tập trung vào các ứng dụng đơn trang. Công cụ này sử dụng một số hằng số và giá trị ngẫu nhiên để sinh ra đầu vào cho dữ liệu kiểm thử. Tiếp theo, Crawljax là một công cụ thu thập thông tin và kiểm thử cho các ứng dụng Web Ajax. Nó có thể thực hiện trên ứng dụng Web có quy mô lớn nhưng chỉ sinh ra các giá trị ngẫu nhiên cho đầu vào. Cả hai công cụ này mặc dù có thể sinh dữ liệu kiểm thử tự động cho ứng dụng Web nhưng bộ dữ liệu kiểm thử không hiệu quả vì không phân tích sâu đến nội hàm các xử lý lô-gic của thành phần kiểm thử. Khác với hai công cụ trước đó, SymJS là công cụ có phân tích mã nguồn của thành phần kiểm thử trong ứng dụng, thu thập các toán tử có điều kiện và thực thi tượng trưng để sinh ra bộ các đầu vào đi qua các đường đi khác nhau trong chương trình. Tuy nhiên, hiện tại công cụ này mới chỉ hỗ trợ mã nguồn JavaScript phía người dùng. Có thể nói rằng SymJS đã bước đầu nghiên cứu các phương pháp kiểm thử hộp trắng cho các ứng dụng Web. Phương pháp kiểm thử hộp trắng từ lâu đã được ứng dụng để sinh tự động dữ liệu kiểm thử ở nhiều ngôn ngữ lâu đời như Java, C++, C\#, v.v. và đã đạt được một số kết quả khả quan. Bộ dữ liệu kiểm thử được sinh ra bởi phương pháp này có thể đạt độ phủ cao, thực thi qua nhiều thành phần có trong chương trình. Tuy nhiên, phương pháp này cũng vẫn tồn tại mộ số nhược điểm nhất định và chưa thể coi như là một giải pháp tổng thể cho tất cả các mã nguồn dự án phần mềm. Việc áp dụng phương pháp này như thế nào thì phải phụ thuộc vào bài toán cụ thể hoặc đặc trưng của mã nguồn được áp dụng. Thời điểm hiện tại vẫn chưa có nhiều nghiên cứu ứng dụng phương pháp kiểm thử hộp trắng cho ứng dụng Web.

% \section{Kiểm thử hộp trắng}
% Phương pháp được đề xuất trong luận văn này xây dựng dựa trên phương pháp kiểm thử dòng điều khiển. Đây là một trong những phương pháp kiểm thử hộp trắng đảm bảo tất cả các thành phần có trong mã nguồn đều được thực thi. Cụ thể, kiểm thử hộp trắng là phương pháp sinh dữ liệu kiểm thử dựa trên việc phân tích cấu trúc bên trong của mã nguồn \cite{software_testing, white_box_testing_2}. Nếu kiểm thử hộp đen cho phép phát hiện lỗi/khiếm khuyết có thể quan sát được thì kiểm thử hộp trắng có thể phát hiện những lỗi/khiếm khuyết tiềm ẩn bên trong chương trình/đơn vị phần mềm. Các lỗi này thường rất khó có thể phát hiện bằng kiểm thử hộp đen, tuy nhiên điều này không có nghĩa là kiểm thử hộp đen là không quan trọng. Mỗi phương pháp đều có những ưu nhược điểm và mục đích khác nhau, thường xuyên được sử dụng kết hợp với nhau trong quy trình kiểm thử nhằm đảm bảo phần mềm có chất lượng tốt nhất. Kiểm thử hộp trắng có các dữ liệu kiểm thử được sinh ra từ mã nguồn bằng các kỹ thuật phân tích phức tạp. Vì vậy, để có thể áp dụng được phương pháp này, các kỹ thuật viên không chỉ cần nắm rõ giải thuật mà còn cần có các kỹ năng và kiến thức tốt về ngôn ngữ lập trình, hiểu rõ được mã nguồn mới có thể đưa ra những cách giải quyết phù hợp. Do đó, việc áp dụng các phương pháp kiểm thử hộp trắng thường tốn nhiều thời gian và công sức, đặc biệt khi thành phần kiểm thử có kích thước lớn. Với lý do như vậy, các phương pháp kiểm thử hộp trắng thường được áp dụng trong pha kiểm thử đơn vị.

% Hai phương pháp được sử dụng trong kiểm thử hộp trắng là kiểm thử dòng điều khiển (Control Flow Testing - CFT) và kiểm thử dòng dữ liệu (Data Flow Testing - DFT) \cite{whitebox-testing}. Phương pháp kiểm thử dòng điều khiển tập trung kiểm thử tính đúng đắn của các giải thuật sử dụng trong thành phần cần kiểm thử. Phương pháp kiểm thử dòng dữ liệu quan tâm đến tính đúng đắn của việc sử dụng các biến dữ liệu trong thành phần kiểm thử. Luận văn này sử dụng phương pháp kiểm thử dòng điều khiển. Vì vậy, các kiến thức liên quan đến kiểm thử dòng điều khiển được trình bày chi tiết trong phần tiếp theo.
% % cần kiểm thử nhưng vẫn phát hiện được lỗi ngay từ giai đoạn đầu tiên trong quy trình phát triển phần mềm. Nhờ đó, các khiếm khuyết trong thiết kế và code được sửa chữa sớm, giảm thời gian và chi phí hoàn thiện sản phẩm. Đồng thời, hiệu suất phát triển cũng được nâng cao vì thiết kế được cải tiến, code có chất lượng tốt hơn, dễ bảo trì. Ngoài việc kiểm tra tài liệu (code reviews) và đánh giá cú pháp tự động, kiểm thử hộp trắng có thể được ứng dụng trong việc sinh dữ liệu kiểm thử thỏa mãn những tiêu chí đánh giá về độ phủ. Cụ thể trong phạm vi khóa luận này, phương pháp kiểm thử hộp trắng được áp dụng là xây dựng đồ thị luồng điều khiển đại diên cho cấu trúc chương trình và sử dụng tiêu chuẩn bao phủ nhánh của đồ thị để làm căn cứ đánh giá sự hiểu quả của giải pháp. 

% % % \section{Cây cú pháp trừu tượng}
% % % Cây cú pháp trừu tượng (Abstract Syntax Tree - AST) được sử dụng rộng rãi trong các trình biên dịch hoặc IDE. Với đầu vào là mã nguồn, các trình biên dịch/IDE này sẽ xây dựng AST tương ứng. AST là một cách biểu diễn cấu trúc mã nguồn dưới dạng cây. Mỗi một thành phần trong cây tương ứng với một thành phần mã nguồn như câu lệnh gán, khối lệnh điều kiện, biến, phép toán, v.v. Đối với một ngôn ngữ bất kỳ, AST
% % % Mỗi thành phần trong cây đều có các kiểu khác nhau được quy định bởi trình biên dịch. Ví dụ, trong CDT, kiểu IASTDeclSpecifier tương ứng với kiểu trả về của hàm hay kiểu biến. Kiểu IASTBinaryExpression tương ứng với dấu phép toán. Kiểu IASTName đại diện tên biến, tên hàm. IASTReturnStatement chính là câu lệnh return. 
% \section{Đồ thị dòng điều khiển}
% Như đã giới thiệu, phương pháp được sử dụng trong luận văn này là kiểm thử dựa trên dòng điều khiển. Tổng quan của phương pháp này là phân tích mã nguồn, xây dựng đồ thị dòng điều khiển và phân tích các biểu thức điều kiện có trong đồ thị đề sinh ra các giá trị hữu ích. Việc sinh dữ liệu kiểm thử dựa trên phân tích mã nguồn sẽ gặp rất nhiều khó khăn nếu chỉ thao tác với mã nguồn ở dạng văn bản đơn thuần. Vì vậy, chúng ta cần có một cấu trúc dữ liệu khác cũng có thể mô tả mã nguồn nhưng đơn giản để phân tích hơn. Đồ thị dòng điều khiển là một cấu trúc dữ liệu hỗ trợ giải quyết vấn đề này. Đồ thị dòng điều khiển (Control Flow Graph - \gls{CFG}) mô tả kịch bản thực thi của chương trình một cách trực quan, bao gồm các đỉnh là đại diện cho câu lệnh/nhóm câu lệnh và các cạnh là dòng điều khiển giữa các câu lệnh/nhóm câu lệnh đó \cite{CFG_definition}. Tất cả các đồ thị luồng điều khiển đều có đỉnh bắt đầu và đỉnh kết thúc đại diện cho trạng thái bắt đầu và trạng thái kết thúc của chương trình. Các cạnh là các mũi tên có hướng thể hiện thứ tự thực hiện của câu lệnh/nhóm câu lệnh. Cạnh nối hai đỉnh $i$ và $j$ theo hướng từ đỉnh $i$ đến đỉnh $j$ nghĩa là câu lệnh thứ $i$ được thực hiện trước câu lệnh thứ $j$.
% Về cơ bản, CFG bao gồm các thành phần chính là đỉnh bắt đầu, đỉnh xử lý, đỉnh quyết định, đỉnh kết nối và đỉnh kết thúc. 
% \begin{itemize}
%     \item Đỉnh bắt đầu: Đánh dấu thời điểm bắt đầu của chương trình, được thể hiện bằng hình tròn
%     \item Đỉnh xử lý: Đại diện cho các câu lệnh gán, khai báo và khởi tạo, được thể hiện bằng hình chữ nhật
%     \item Đỉnh quyết định: Đại diện cho câu lệnh điều khiển trong khối lệnh điều khiển rẽ nhánh, được thể hiện bằng hình thoi
%     % \item Đỉnh kết nối: Đại diện cho câu lệnh được thực hiện ngay sau các lệnh rẽ nhánh, có nhiều hơn hai đỉnh trỏ đến, được thể hiện bằng hình tròn
%     \item Đỉnh kết thúc: Đánh dấu thời điểm kết thúc của hàm, được thể hiện bằng hình tròn
% \end{itemize} 
% \begin{figure}[!ht]
% 		\centering
% % 		\setlength{\abovecaptionskip}{1pt plus 3pt minus 2pt}
%  		\includegraphics[width=\textwidth]{figures/cfg-control.pdf}
%  		\vspace*{-7mm}
% 		\caption{Các cấu trúc điều khiển phổ biến trong TypeScript}
% 		\label{cau-truc-dieu-khien}
% \end{figure}

% Hình~\ref{cau-truc-dieu-khien} mô tả các cấu trúc điều khiển chính có trong TypeScript được mô phỏng dưới dạng các đỉnh của CFG, bao gồm có cấu trúc điều khiển tuần tự, rẽ nhánh, vòng lặp \textit{for}, vòng lặp \textit{do…while}, vòng lặp \textit{ while…do}.

% \section{Các độ đo kiểm thử}
% Các độ đo kiểm thử thường được xác định là các quy tắc hoặc yêu cầu mà một tập hợp dữ liệu kiểm thử cần đáp ứng \cite{coverage_criteria}. Có một số độ đo phổ biến là bao phủ hàm (function coverage), bao phủ câu lệnh (statement coverage) và bao phủ nhánh (branch coverage). Bao phủ hàm là độ đo dễ đạt được nhất trong ba tiêu chí bao phủ này. Nó được đo bằng tỷ lệ phần trăm các hàm hoặc phương thức đã thực thi trên tổng số các hàm/phương thức có trong mã nguồn thử nghiệm. Bởi vì một hàm được thực thi có thể chứa các đoạn chưa được thực thi như các câu lệnh và các nhánh, một số lỗi bên trong một hàm có thể không được xem xét. Để giải quyết vấn đề này, quá trình kiểm tra phải được thực hiện với cả phạm vi bao phủ của câu lệnh và phạm vi bao phủ nhánh. Liên quan đến bao phủ câu lệnh, nó được biểu thị bằng tỷ lệ phần trăm các câu lệnh được thực thi trong tổng số các câu lệnh thuộc phạm vi kiểm thử. Nếu độ phủ câu lệnh đạt 100\%, thì bao phủ hàm/phương thức cũng đạt đến 100\%. Tuy nhiên, nó không thể xác nhận rằng tất cả các nhánh của điều kiện đều được thực thi. Vì vậy, độ phủ nhánh được đề xuất để đánh giá quá trình thử nghiệm một cách toàn diện hơn. Nó được đo bằng phần trăm các nhánh được thực thi trên tất cả các nhánh thuộc phạm vi kiểm thử. Nếu việc thực thi kiểm thử đạt được bao phủ nhánh tối đa, có thể đảm bảo rằng bao phủ câu lệnh và hàm cũng đạt đến giá trị lớn nhất. Vì vậy, bao phủ nhánh được sử dụng là độ đo cơ bản để đánh giá bộ dữ liệu kiểm thử.

% Công thức tổng quát để tính độ phủ theo các độ đo của $n$ tệp được trình bày trong Công thức \ref{coverage_equation}:
% \begin{equation} \label{coverage_equation}
% \begin{split}
%         e_c &= f(c, tested\ files) \\
%         &= \frac{\sum_{i=1}^n e_{i_c}}
%         {\sum_{i=1}^n t_{i_c}}*100 \\
%  \end{split}
% \end{equation}
% ,trong đó: $c$: loại độ đo bao phủ, bao gồm bao phủ hàm (\textit{function coverage}), bao phủ câu lệnh (\textit{statement coverage}), bao phủ nhánh (\textit{branch coverage})\\
% $e_{i_c}$: số lượng các thành phần được thực thi theo từng độ đo $c$ trong tệp thứ $i$. Thành phần được coi là các hàm, câu lệnh, và nhánh trong mã nguồn kiểm thử. \\
% $t_{i_c}$: số lượng tất cả các thành phần theo độ đo $c$ trong tệp thứ $i$

% Các tiêu chí bao phủ này được sử dụng để đánh giá hiệu quả của phương pháp được đề xuất trong việc tạo dữ liệu thử nghiệm. Nếu độ phủ tăng lên, nhiều thành phần trong mã nguồn được thực thi. Trong trường hợp các độ phủ không đạt 100 \%, các vấn đề sau có thể gặp phải. Thứ nhất, dữ liệu kiểm thử không thực thi toàn bộ các thành phần có trong mã nguồn. Do đó, có thể có một số lỗi tiềm ẩn không được phát hiện. Mặt khác, mã nguồn có thể chứa những câu lệnh không bao giờ có thể thực thi. Các nhà phát triển phải loại bỏ những đoạn mã này để tối ưu kích thước chương trình, tránh thực hiện các hành vi không đúng hoặc đơn giản hóa cấu trúc chương trình.

% % Trong kiểm thử hộp trắng nói chung và kiểm thử dòng điều khiển nói riêng, bài toán kiểm thử là sinh được bộ dữ liệu kiểm thử sao cho thỏa mãn các tiêu chuẩn cho trước. Các tiêu chuẩn này đã được thống nhất và định nghĩa bằng văn bản trong ISO \cite{iso_coverage}. Công thức tính toán độ đo theo các tiêu chuẩn này dựa trên mức độ bao phủ của chương trình với một tập dữ liệu kiểm thử cho trước. Tập dữ liệu kiểm thử có độ phủ cao sẽ đáng tin cậy hơn tập dữ liệu kiểm thử có độ phủ thấp. Mục tiêu là tập dữ liệu kiểm thử có số lượng tối thiểu nhưng đạt được độ phủ tối đa. Hiện nay, có nhiều tiêu chuẩn bao phủ khác nhau được sử dụng. Độ phủ của mỗi tiêu chuẩn đánh giá đều có công thức tính riêng nhưng về cơ bản sẽ được tính bằng tỉ lệ thành phần được kiểm thử trên tổng số các thành phần cần kiểm thử. Thành phần ở đây có thể là câu lệnh, nhánh chương trình, điểm quyết định, điều kiện con hoặc sự kết hợp giữa chúng. Độ đo này giúp các kỹ thuật viên kiểm soát và quản lý quá trình kiểm thử tốt hơn, có thể kiểm tra lại thành phần không được chạy qua hoặc bổ sung thêm dữ liệu kiểm thử trong trường hợp độ phủ thấp. Dưới đây là ba độ đo kiểm thử được sử dụng nhiều trong quy trình kiểm thử phần mềm \cite{Lee03}.
% % \begin{itemize}
% %     \item Độ phủ câu lệnh (statement coverage): mỗi câu lệnh được đi qua ít nhất một lần sau khi chạy bộ dữ liệu kiểm thử.
% %     \item Độ phủ nhánh (branch coverage): nhánh đúng và nhánh sai của mỗi đỉnh điều kiện có trong đồ thị dòng điều khiển được đi qua ít nhất một lần sau khi chạy bộ dữ liệu kiểm thử.
% %     \item Độ phủ điều kiện con (Modified Condition/Decision Coverage - MC/DC): các điều kiện con thuộc các đỉnh điều kiện phức tạp đều được thực hiện cả hai nhánh đúng và nhánh sai ít nhất một lần mỗi nhánh sau khi chạy bộ dữ liệu kiểm thử.
% % \end{itemize}

% % \section{Đường kiểm thử}
% % Bộ dữ liệu kiểm thử sinh ra dành cho một hàm bao gồm nhiều dữ liệu kiểm thử. Mỗi dữ liệu kiểm thử là một bộ giá trị đầu vào của tham số. Với một bộ giá trị đầu vào, chương trình của hàm sẽ chạy qua một số câu lệnh và dừng lại khi tới điểm kết thúc. Tập hợp các câu lệnh theo thứ tự thực hiện tạo thành một đường đi. Những đường đi được chọn để sinh dữ liệu kiểm thử  được gọi là đường kiểm thử. Để thống nhất khái niệm sử dụng trong suốt khóa luận, Định nghĩa 2.4 mô tả tổng quát một đường kiểm thử. Mỗi đường kiểm thử có thể bao gồm đầy đủ các câu lệnh khai báo, gán giá trị, khởi tạo và câu lệnh rẽ nhánh. Các đường đi khác nhau sẽ khác nhau ở số lượng, danh sách và thứ tự thực hiện các câu lệnh. Việc sinh dữ liệu kiểm thử tương ứng với đường kiểm thử chính là tìm kiếm bộ giá trị đầu vào sao cho khi thực thi, các nút điều kiện của đường đi đều được thỏa mãn. Trong thực tế, số lượng đường đi của chương trình có thể rất lớn dẫn đến việc sinh bộ dữ liệu kiểm thử cho tất cả các đường đi là không thể. Vì vậy, một số đường đi được chọn để sinh dữ liệu kiểm thử nhằm đáp ứng tiêu chí về độ phủ được gọi là tập đường kiểm thử.\\
% % \textbf{Định nghĩa 2.1}: Đường kiểm thử là một đường đi từ điểm bắt đầu đến điểm kết thúc của CFG, được biểu diễn bằng tập hợp các đỉnh từ $v_1$  đến $v_n$ sao cho cứ hai đỉnh cạnh nhau thì có cạnh nối theo hướng từ trái qua phải. Nếu cạnh ($v_i$, $v_j$) là nhánh sai thì biểu thức điều kiện tại đỉnh $v_i$ được viết dưới dạng phủ định $!v_i$.

% % Để có thể sinh được bộ dữ liệu kiểm thử thỏa mãn yêu cầu về tiêu chuẩn bao phủ, việc lựa chọn tập kiểm thử là một công đoạn không thể thiếu. Tuy nhiên, có hai vấn đề chúng ta cần phải đối mặt:
% % \vspace{-0.5cm}
% % \begin{itemize}
% %     \item Tính khả thi của đường đi: Một đường kiểm thử gọi là có khả khi nếu tồn tại một dữ liệu kiểm thử sao cho khi thực thi trong môi trường thật, tất cả các đỉnh của đường đi được duyệt qua. Ngược lại, đường kiểm thử gọi là không khả thi.
% %     \item 	Sự bùng nổ đường đi: với một hàm có kích thước lớn, nhiều vòng lặp hoặc các lệnh rẽ nhánh phức tạp, số lượng đường đi của chương trình có thể rất lớn. Việc sinh dữ liệu kiểm thử cho tất cả các đường đi để chắc chắn đạt độ phủ 100\% là không thể.
% % \end{itemize}
% % Mục tiêu của khóa luận này là xây dựng công cụ đầu tiên hỗ trợ sinh dữ liệu kiểm thử cho TypeScript, bắt đầu thử nghiệm với các hàm TypeScript kích thước vừa phải. Vì vậy, tập đường kiểm thử được lựa chọn là tập các đường đi có thể có của chương trình. Trong trường hợp tất cả các đường đi đều khả thi, độ bao phủ nhánh có thể đạt được là 100\%.

% % \section{Thư viện sử dụng}

% % \subsection{Thư viện phân tích mã nguồn TypeScript ``ts-morph''}
% % Phương pháp sinh dữ liệu kiểm thử tự động được đề xuất trong khóa luận này dựa trên việc thao tác với CFG của hàm. Việc xây dựng CFG như thế nào sẽ tùy biến theo từng tình huống bài toán. Đặc biệt đối với một ngôn ngữ mới như TypeScript, hiện tại không có thư viện nào có thể hỗ trợ giải quyết tác vụ này. Vì vậy, quá trình này được thực hiện thủ công dựa trên kỹ thuật phân tích mã nguồn và thiết kế cấu trúc dữ liệu mô hình hóa sao cho phù hợp với bài toán kiểm thử hiện tại. Phân tích mã nguồn thành cây cú pháp trừu tượng (Abstract Syntax Tree - AST) giúp việc xây dựng CFG trở nên đơn giản hơn. AST là một cây đại diện cho cấu trúc cú pháp trừu tượng của mã nguồn. Ngôn ngữ lập trình khác nhau có AST khác nhau.  Mỗi nút của cây biểu thị một cấu trúc có trong mã nguồn. AST thường được xây dựng bởi chính trình phân tích cú pháp của ngôn ngữ tương ứng trong quá trình biên dịch. Đối với các ngôn ngữ lâu đời, việc này có thể được thực hiện bởi một số thư viện khác. Do TypeScript là một ngôn ngữ mới nên chưa có công cụ nào hỗ trợ phân tích mã nguồn thành AST. Vì vậy, khóa luận này sử dụng chính trình biên dịch ngôn ngữ TypeScript của Microsoft để phân tích nội dung hàm. ``ts-morph''\footnote{\url{https://github.com/dsherret/ts-morph}} là một thư viện mở rộng từ trình biên dịch TypeScript, cung cấp các giao diện lập trình ứng dụng (Application Programming Interface - API) hỗ trợ người dùng có một cách dễ dàng hơn để điều hướng chương trình và thao tác với mã TypeScript.
% % Với sự hỗ trợ của ``ts-morph'', người sử dụng có đầy đủ các API để trích xuất thông tin cần thiết từ mã nguồn.  Các khối lệnh của thân hàm và các biểu thức  điều kiện đều có thể dễ dàng có được thông qua việc duyệt các đỉnh, hay gọi là $node$ của AST. Ngoài ra, thư viện cung cấp giao diện\footnote{\url{https://TypeScript-ast-viewer.com/}} để người dùng có thể theo dõi kết quả dưới dạng hình cây rất trực quan và dễ nhìn. Từ đó, việc thao tác với AST trở nên dễ dàng hơn.

% % %  Đối với TypeScript, các cấu trúc này có thể là lớp, hàm, thuộc tính, tham số, câu lệnh, v.v.

% % \subsection{Bộ giải hệ ràng buộc Z3}
% % Công cụ sinh dữ liệu kiểm thử cho mỗi đường kiểm thử bằng cách giải hệ ràng buộc ứng với tập các đỉnh điều kiện. Giải hệ ràng buộc nghĩa là quá trình tìm ra giải pháp cho một tập hợp các ràng buộc áp đặt bởi các phép toán điều kiện mà các biến phải thỏa mãn \cite{ref-constraints}. Do đó, một giải pháp là một tập hợp các giá trị cho các biến thỏa mãn tất cả các ràng buộc, đó là một điểm trong vùng khả thi.
% % Hiện nay, có nhiều thư viện, công cụ hỗ trợ việc giải hệ trong đó nổi bật là bộ giải Z3. Bộ giải Z3 được xây dựng chủ yếu bằng ngôn ngữ C++. Các ràng buộc cần được chuyển sang dạng chuẩn của Z3 để công cụ có thể tính toán và giải nghiệm. Z3 có thể giải hệ ràng buộc của các số nguyên, số thực, mảng và hàm tượng trưng. Đặc biệt trong phiên bản 4.8, bộ giải Z3 hỗ trợ giải một số ràng buộc liên quan đến chuỗi (string) \cite{z3_str_paper}. Điều này giúp việc tìm kiếm dữ liệu kiểm thử có tham số đầu vào kiểu chuỗi trở nên đơn giản hơn. Để có thể sử dụng Z3 giải nghiệm, bộ ràng buộc được lưu trong tệp và khởi chạy tiến trình bằng dòng lệnh:
% % \vspace{0.5cm}
% % \begin{lstlisting}
% % z3 -smt2 <file name>.smt2
% % \end{lstlisting}
% % Mã nguồn~\ref{constraints-file-example} là ví dụ một tệp constraints.smt2 hợp lệ làm đầu vào cho bộ giải Z3. Trong tệp, các biến sử dụng cần được khai báo bằng cú pháp \textit{declare-fun}. Sau đó, lệnh \textit{assert} được sử dụng để thêm các ràng buộc của hệ. Để kiểm tra hệ ràng buộc có nghiệm hay không, lệnh \textit{check-sat} được gọi. Kết quả trả về là \textit{sat} nếu có nghiệm và \textit{unsat} trong trường hợp không có nghiệm. Tập các giá trị của các biến thỏa mãn hệ ràng buộc được hiển thị bằng lệnh \textit{get-model}. Trong ví dụ này, hệ ràng buộc sử dụng ba biến tham số đầu vào là tvw\_s,  tvw\_a, tvw\_b và có ba ràng buộc được thêm vào câu lệnh \textit{assert} trong tệp \textit{constraints.smt2}. Mã nguồn~\ref{z3-result-example} là kết quả tương ứng sau khi giải hệ. Trong đó, các giá trị của các biến tìm được là  tvw\_a = 12,  tvw\_b = 11,  tvw\_s = "\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00". Như vậy, bộ giá trị (a, b, s) = \{12, 11, "\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00"\} là một nghiệm của hệ ràng buộc.
% % Nếu áp dụng với một đường kiểm thử cụ thể, các biến được khai báo trong hệ ràng buộc là các biến gọi đến trong các câu lệnh. Các đỉnh điều kiện sẽ được biểu diễn qua những biến này và chuẩn hóa thành những ràng buộc của hệ. Kết quả giải hệ là một dữ liệu kiểm thử thỏa mãn đường đi tương ứng. Trong trường hợp hệ ràng buộc của tất cả các đường đi đều giải được bỏi bộ giải Z3, tập các dữ liệu kiểm thử thu được phủ 100\% đường đi của CFG.

% % \vspace{0.5cm}
% % \begin{lstlisting}[caption=Ví dụ nội dung tệp đầu vào cho bộ giải Z3, label=constraints-file-example,captionpos=b]
% % (set-option :timeout 5000)
% % (declare-fun tvw_s () String)
% % (declare-fun tvw_a () Int)
% % (declare-fun tvw_b () Int)
% % (assert (> a b))
% % (assert (> b 10))
% % (assert (not (> (+ (str.len tvw_s) 1) 10)))
% % (check-sat)
% % (get-model)
% % \end{lstlisting}

% % \begin{lstlisting}[caption=Ví dụ kết quả giải hệ của Z3, label=z3-result-example, captionpos=b]
% % sat
% % (model
% %   (define-fun tvw_s () String
% %     "\x00\x00\x00\x00\x00")
% %   (define-fun tvw_b () Int
% %     11)
% %   (define-fun tvw_a () Int
% %     12)
% % )

% % \end{lstlisting}

% % \subsection{Mocha và Istanbul}
% % Để kiểm tra độ phủ đạt được với bộ dữ liệu kiểm thử đã được sinh tự động, công cụ có sử dụng Mocha trong việc thực thi mã nguồn. Mocha (Mocha Test Framework) là một bộ công cụ hỗ trợ kiểm thử dành cho JavaScript giàu tính năng chạy trên Nodejs và trong trình duyệt, giúp cho việc kiểm tra bất đồng bộ trở nên đơn giản và thú vị \cite{ref-mocha}. Các quy trình thực thi kiểm thử thực hiện bởi Mocha chạy ổn định, cho phép báo cáo linh hoạt và chính xác. Mocha có thể áp dụng với TypeScript thông qua một số bước cài đặt kỹ thuật. Ngoài ra,  Mocha cũng có thể kết hợp với một số thư viện để xuất báo cáo kiểm tra độ phủ (test coverage report). Ngoài việc cung cấp chức năng chạy kiểm thử với thao tác bằng tay, Mocha còn kèm theo bộ API để vận hành các bài kiểm tra tự động. Mocha có rất nhiều tính năng tuyệt vời, trong đó có một số tính năng nổi bật được kể đến là:
% % \begin{itemize}
% %     \item Hỗ trợ bất đồng bộ đơn giản
% %     \item Cung cấp đa dạng báo cáo
% %     \item Có thể chạy trong trình duyệt
% %     \item Tương thích với nhiều thư viện xác nhận (assertion library) Javascript
% %     \item Tương thích với mô hình phát triển phần mềm định hướng hành vi (Behaviour Driven Development - BDD) và mô hình phát triển phần mềm định hướng kiểm thử (Test Driven Development - TDD)
% % \end{itemize}
% % Với sự hỗ trợ của Mocha, các tệp kiểm thử được thực thi một cách nhanh chóng. Kết quả chạy kiểm thử được thống kê trực quan với số lượng dữ liệu kiểm thử thành công hay thất bại kèm theo vị trí cụ thể. Từ đó kỹ thuật viên nhanh chóng xác định được dữ liệu kiểm thử bị sai và dễ dàng sửa chữa.

% % Mocha chỉ hỗ trợ quá trình thực thi tệp kiểm thử và thống kê kết quả số lượng dữ liệu kiểm thử thành công hay thất bại. Tuy nhiên, để có thể biết được thống kê độ phủ mà bộ dữ liệu kiểm thử đạt được, Mocha cần kết hợp thêm một số thư viện bên ngoài. trong đó, được sử dụng nhiều nhất phải kể đến thư viện Istanbul \cite{ref-instanbul}. Đây là thư viện hỗ trợ sinh báo cáo độ phủ của quá trình kiểm thử đơn vị với nhiều định dạng khác nhau như HTML, XML, terminal output, JSON, v.v. Người dùng có thể lựa chọn kiểu báo cáo phù hợp với nhu cầu. Công cụ được phát triển trong khóa luận sử dụng báo cáo thể hiện dưới dạng HTML, bao gồm các thông tin về các độ phủ như số lượng hàm, câu lệnh, nhánh được thực thi. Đồng thời, báo cáo cũng nổi bật các đoạn mã không được chạy qua. Từ đó, kỹ thuật viên có thể phát hiện ra  được các đoạn mã không bao giờ được chạy để làm sạch mã nguồn hoặc bổ sung thêm dữ liệu kiểm thử mới để bộ dữ liệu kiểm thử hoàn thiện hơn.