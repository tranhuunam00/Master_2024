
Trong chương này, tác giả trình bày tổng quan về hội chứng ngưng thở khi ngủ do
tắc nghẽn (OSA), phân tích ảnh hưởng của tư thế ngủ đối với mức độ nghiêm trọng
của OSA và dạng ngưng thở khi ngủ phụ thuộc tư thế (Position OSA - pOSA). Tiếp
đó, chương tập trung làm rõ cơ sở khoa học cho việc phát triển các thiết bị
theo dõi giấc ngủ và thiết bị HST (Home Sleep Test), phân loại tư thế ngủ. Cuối
cùng, tác giả đưa ra xu hướng ứng dụng trí tuệ nhân tạo (AI) và điện toán biên
(Edge Computing) trong thu thập, phân tích dữ liệu sinh lý và phân loại tư thế
ngủ, qua đó đặt nền tảng cho các hướng nghiên cứu và triển khai kỹ thuật được
trình bày trong những chương tiếp theo.
\section{Hội chứng ngưng thở khi ngủ}

Trong lĩnh vực nghiên cứu các rối loạn hô hấp liên quan đến giấc ngủ, việc
chuẩn hóa và định nghĩa chính xác các kiểu sự kiện hô hấp giúp đảm bảo tính
nhất quán trong chẩn đoán, phân lớp nguy cơ và lựa chọn phương pháp điều trị
phù hợp. Theo tiêu chuẩn của Hiệp hội Y học Giấc ngủ Hoa Kỳ (AASM)
\cite{berry2012scoring}, ba hiện tượng hô hấp chính cần được nhận diện bao gồm:
ngưng thở (apnea), giảm thở (hypopnea), và hiện tượng kích hoạt liên quan đến
nỗ lực hô hấp (Respiratory Effort–Related Arousal – RERA).

\subsection{Định nghĩa}

Ngưng thở (Apnea) được AASM định nghĩa là sự ngưng luồng khí hô hấp qua mũi và
miệng trong thời gian tối thiểu 10 giây gây giảm nồng độ oxy trong máu. Các sự
kiện ngưng thở có thể kéo dài đến 30 giây hoặc hơn trong những trường hợp nặng.
Có ba dạng chính của hội chứng ngưng thở khi ngủ \cite{ThaySYOSA}: ngưng thở
tắc nghẽn, ngưng thở trung ương, ngưng thở hỗn hợp. Trong đó: 01)Ngưng thở khi
ngủ do tắc nghẽn OSA là sự hẹp hoặc tắc nghẽn một phần hay toàn bộ đường hô hấp
trên, bao gồm vùng mũi họng, hầu họng \cite{osa_summary}; 02)Ngưng thở khi ngủ
do trung ương (Central Sleep Apnea – CSA) là tình trạng não không gửi tín hiệu
đúng đến các cơ kiểm soát hô hấp \cite{eckert2007csa}. 03)Ngưng thở hỗn hợp
(Mixed Apnea) là sự kết hợp của cả hai yếu tố. Dạng này thường xuất hiện ở
những bệnh nhân OSA nặng.

Giảm thở (hypopnea) phản ánh sự giảm một phần của lưu lượng khí qua đường hô
hấp trên mà không dẫn đến ngừng thở hoàn toàn. Theo AASM sự kiện giảm thở được
xác định khi biên độ tín hiệu luồng khí thường đo bằng cảm biến áp lực mũi hoặc
tín hiệu lưu lượng khí của thiết bị CPAP giảm ít nhất 30\% so với giá trị nền
trước sự kiện, kéo dài tối thiểu 10 giây, và đi kèm với hiện tượng giảm độ bão
hòa oxy từ 3\% trở lên hoặc xuất hiện kích hoạt điện não.

RERA theo AASM là sự kiện gia tăng nỗ lực hô hấp kéo dài $\geq 10$ giây, gây
đánh thức khỏi giấc ngủ nhưng không đủ tiêu chí của apnea hoặc hypopnea. 01)
Phương pháp tiêu chuẩn để đo là đo áp lực thực quản, tuy nhiên khó áp dụng do
gây khó chịu cho bệnh nhân. 02) Phương án thay thế đáng tin cậy là dùng ống
thông mũi kết hợp cảm biến áp lực, cho kết quả tương đương về mặt lâm sàng. 03)
RERA được tính vào chỉ số rối loạn hô hấp (Respiratory Disturbance Index -
RDI); RDI >5 là bất thường, >15 là có ý nghĩa lâm sàng.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{images/OSA.png}
  \vspace*{-7mm}
  \caption{Hình ảnh khác nhau về đường thở của người bình thường và người mắc OSA}
  \label{OSA}
\end{figure}

Trong số các rối loạn hô hấp liên quan đến giấc ngủ đã đề cập, hội chứng ngưng
thở khi ngủ do tắc nghẽn là dạng phổ biến nhất và có tác động sâu rộng đến sức
khỏe cộng đồng. Mức độ của OSA được đánh giá dựa trên chỉ số ngưng thở giảm thở
(Apnea–Hypopnea Index - AHI) bằng cách chia tổng số lần ngưng thở và giảm thở
cho tổng số giờ đã ngủ, với mỗi sự kiện phải kéo dài ít nhất 10 giây
Bảng~\ref{ahi} \cite{osa_summary}.
\begin{table}[h!]
  \caption{\texorpdfstring{Phân loại mức độ OSA dựa trên chỉ số AHI}{Phân loại OSA}}
  \label{ahi}
  \vspace{-3mm}
  \begin{center}
    \begin{tabular}{|c|c|}
      \hline
      AHI       & Cấp độ     \\
      \hline
      <5        & Không mắc  \\
      5 đến 10  & Nhẹ        \\
      15 đến 30 & Trung bình \\
      >30       & Nặng       \\
      \hline
    \end{tabular}
    \label{tab1}
  \end{center}
\end{table}

\subsection{Nguyên nhân}

Nguyên nhân của OSA có bản chất đa yếu tố và phức tạp, phản ánh sự tương tác
chặt chẽ giữa các yếu tố giải phẫu và sinh lý chức năng của đường hô hấp trên.
Các nguyên nhân nền tảng này không đồng nhất giữa các cá thể và thường thể hiện
sự kết hợp khác nhau về mức độ ảnh hưởng của từng yếu tố. Về mặt giải phẫu, hẹp
hoặc giảm độ vững của cấu trúc đường hô hấp trên là yếu tố tiên quyết. Những
bất thường như vòm khẩu hẹp, lưỡi to, phì đại amidan, vách mũi lệch, xương hàm
nhỏ hoặc tụt sau, cùng phân bố mỡ vùng cổ tăng (vòng cổ lớn, béo phì trung
tâm), đều làm giảm tiết diện đường thở và tăng khả năng xẹp trong thì hít vào
\cite{Young2004_nguyen_nhan}.

Về chức năng thần kinh – cơ, trong giấc ngủ, trương lực cơ duy trì độ mở của
đường hô hấp trên suy giảm, làm tăng xu hướng xẹp hầu. Sự mất cân bằng giữa lực
mở do cơ giãn và lực đóng do áp lực âm trong lồng ngực khi hít vào dẫn đến tắc
nghẽn tạm thời. Ngoài ra, yếu tố điều hòa trung ương và đáp ứng sinh lý cũng là
yếu tố đáng kể. Một số người bệnh có ngưỡng kích hoạt hô hấp cao, mức
$\mathrm{CO_2}$ kích thích thấp, hoặc dao động điều hòa thần kinh không ổn định
khiến quá trình kiểm soát hô hấp trong ngủ dễ rơi vào chu kỳ tắc nghẽn, thức
ngắn, tái thông khí lặp lại. Các yếu tố nguy cơ được ghi nhận bao gồm: béo phì,
giới nam, tuổi trung niên đến cao tuổi, hút thuốc lá, uống rượu trước ngủ, mãn
kinh ở nữ giới, nghẹt mũi mạn tính, và yếu tố di truyền
\cite{Spicuzza2015_nguyen_nhan, reason_osa, reasonOsa}.

\subsection{Ảnh hưởng của OSA}
Theo nghiên cứu của Benjafield và cộng sự \cite{Benjafield2019}, ước tính có
gần một tỷ người trên toàn cầu đang mắc hội chứng ngưng thở tắc nghẽn khi ngủ
(Obstructive Sleep Apnea – OSA). Tại Việt Nam, theo GS.TS.BS. Dương Quý Sỹ, tỷ
lệ mắc OSA ở người trưởng thành chiếm khoảng 8,5\% dân số
\cite{nguoimacOSA_VN}. OSA được xem là một rối loạn hô hấp trong giấc ngủ có
ảnh hưởng sâu rộng tới sức khỏe thể chất lẫn tinh thần, và là nguyên nhân y
khoa hàng đầu gây ra tình trạng buồn ngủ quá mức vào ban ngày (Excessive
Daytime Sleepiness – EDS).

Một phân tích gộp được thực hiện bởi Salari và cộng sự \cite{Salari2025} trên
15 nghiên cứu với tổng cộng 42.924 đối tượng cho thấy tỷ lệ EDS ở bệnh nhân OSA
trên toàn cầu đạt 39,9\%. Tình trạng buồn ngủ quá mức này làm gia tăng đáng kể
nguy cơ tai nạn giao thông, suy giảm năng suất lao động, và rối loạn chức năng
tình dục \cite{flemons1997quality}.

Hơn nữa, tình trạng giảm oxy máu tái diễn trong khi ngủ cùng với sự gián đoạn
chu kỳ giấc ngủ được chứng minh có liên quan mật thiết đến nhiều bệnh lý mạn
tính như suy tim, bệnh động mạch vành, rối loạn nhịp tim, gan nhiễm mỡ do rối
loạn chuyển hóa, và đột quỵ
\cite{wright1997health,Zinchuk2018,young1997population}. Nghiên cứu quy mô lớn
của Xia Wang và cộng sự với 25.760 người tham gia cho thấy, khi chỉ số
ngưng–giảm thở (Apnea–Hypopnea Index, AHI) tăng thêm mỗi 10 đơn vị, nguy cơ mắc
bệnh tim mạch tăng tương ứng 17\% \cite{Wang2013_tim}. GS.TS.BS. Dương Quý Sỹ
và cộng sự đã khảo sát 524 trẻ em mắc rối loạn tăng động giảm chú ý (Attention
Deficit Hyperactivity Disorder - ADHD) tại Bệnh viện Nhi Trung ương Việt Nam
\cite{ThaySUCHildren}. Kết quả cho thấy tỷ lệ mắc (OSA) ở nhóm này là 23.3\%,
trong đó chủ yếu ở mức độ trung bình đến nặng. Nghiên cứu cũng đồng thời xác
định mối tương quan đáng kể giữa mức độ nghiêm trọng của OSA và các triệu chứng
mất tập trung, tăng động, rối loạn hành vi, lo âu và trầm cảm.

\subsection{Tư thế ngủ và liên hệ với OSA}
Tư thế ngủ (Hình~\ref{4_tuthe_nguoi}) giữ vai trò thiết yếu trong việc duy trì
sức khỏe tổng thể và chất lượng giấc ngủ, bên cạnh các yếu tố khác như thời
lượng, môi trường và thói quen ngủ. Nhiều nghiên cứu đã chỉ ra rằng tư thế nằm
có thể ảnh hưởng trực tiếp đến hoạt động của hệ hô hấp, tim mạch và hệ cơ –
xương, đặc biệt là cột sống \cite{Cary2021_tu_the_ngủ}. Trong hội chứng ngưng
thở tắc nghẽn khi ngủ , tư thế ngủ được xem là một yếu tố quan trọng quyết định
mức độ nghiêm trọng của bệnh.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{images/4ngu.png}
  \vspace*{-7mm}
  \caption{Các tư thế ngủ cơ bản của con người}
  \label{4_tuthe_nguoi}
\end{figure}

Các nghiên cứu cho thấy, nhiều bệnh nhân OSA có tần suất ngưng thở và giảm thở
cao hơn rõ rệt khi nằm ngửa so với khi nằm nghiêng. Nguyên nhân chủ yếu là do
tác động của trọng lực lên các cấu trúc mô mềm vùng hầu họng, làm tăng xu hướng
xẹp tắc đường thở trên và dẫn đến sự gia tăng của các sự kiện hô hấp bất thường
như Hình ~\ref{fig:tuthe_osa}. Hiện tượng này được gọi là OSA phụ thuộc tư thế
(positional OSA, pOSA) \cite{heinzer2018,aloweidat2023positional}.

Để chẩn đoán pOSA, nhiều tiêu chí khác nhau đã được đề xuất, từ các phương pháp đơn
giản đến phức tạp hơn. Định nghĩa kinh điển nhất do Cartwright (1984) đưa ra cho
rằng bệnh nhân được xem là mắc pOSA khi chỉ số ngưng thở – giảm thở (AHI)
ở tư thế nằm ngửa cao hơn ít nhất hai lần so với AHI ở tư thế không nằm
ngửa \cite{cartwright1984position}. Tiếp đó, Mador (2005) đã mở rộng định
nghĩa này bằng cách bổ sung tiêu chí rằng AHI ở tư thế không nằm ngửa phải
nhỏ hơn 5 lần/giờ nhằm tăng tính đặc hiệu cho chẩn đoán \cite{mador2005prevalence}.
Levendowski (2015) lại đề xuất một cách tiếp cận theo tỷ lệ, trong đó
pOSA được xác định khi AHI toàn bộ lớn hơn hoặc bằng 1.5 lần AHI ở tư thế
không nằm ngửa \cite{levendowski2015neck}.
Ngoài ra, Frank và cộng sự (2014) đã giới thiệu Amsterdam Positional
Obstructive Sleep Apnea Classification (APOC) – một hệ thống phân loại
dành cho các bệnh nhân có chỉ số AHI cao \cite{frank2014positional}.
Theo tiêu chí APOC, bệnh nhân được xác định mắc pOSA khi có AHI toàn
bộ > 5 lần/giờ, đồng thời tổng thời gian ngủ (Total Sleep Time – TST)
ở tư thế tốt nhất (Best Sleeping Position – BSP) và tư thế xấu nhất
(Worst Sleeping Position – WSP) đều chiếm ít nhất 10\% TST.
Hệ thống này chia bệnh nhân thành ba nhóm: APOC-I (có thể khỏi hoàn
toàn nhờ thay đổi tư thế ngủ), APOC-II (không phụ thuộc tư thế),
và APOC-III (phụ thuộc tư thế một phần).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/tuthe_osa.png} % giảm xuống 70% chiều rộng trang
  \vspace*{-5mm}
  \caption{Xẹp đường thở ở tư thế ngửa}
  \label{fig:tuthe_osa}
\end{figure}

Từ các nghiên cứu trên, có thể thấy việc hiểu rõ mối liên hệ giữa tư thế ngủ và
sự ổn định của đường thở trên không chỉ giúp cải thiện khả năng chẩn đoán mà
còn mở ra hướng điều trị không xâm lấn đầy tiềm năng – đó là liệu pháp huấn
luyện thay đổi tư thế ngủ, nhằm giảm mức độ tắc nghẽn và cải thiện chất lượng
giấc ngủ ở bệnh nhân OSA.

\section{Công nghệ trong chẩn đoán OSA và phân loại tư thế ngủ}\

Với sự phát triển vượt bậc của công nghệ chế tạo cảm biến, vi xử lý và các
thuật toán học máy dựa trên dữ liệu thu nhận từ các thiết bị này, việc chẩn
đoán hội chứng ngưng thở khi ngủ tắc nghẽn (OSA) và phân loại tư thế ngủ đã đạt
được những bước tiến đáng kể. Các hệ thống hiện nay có xu hướng thu nhỏ kích
thước thiết bị, mở rộng khả năng ứng dụng thực tế và giảm đáng kể chi phí triển
khai, tạo tiền đề cho việc giám sát giấc ngủ cá nhân hóa ngay tại nhà.
\subsection{Đa ký giấc ngủ}
Phần lớn bệnh nhân mắc hội chứng ngưng thở khi ngủ tắc nghẽn (\gls{OSA}) không
tự nhận biết được các rối loạn hô hấp xảy ra trong khi ngủ
\cite{Gottlieb2020_psg}. Hiện tượng này đặc biệt phổ biến ở những người sống
hoặc ngủ một mình, do thiếu sự quan sát từ bên ngoài.

Trong điều kiện lâm sàng hiện nay, phần lớn bệnh nhân nghi ngờ mắc OSA được
thăm khám bởi bác sĩ chuyên khoa Tai Mũi Họng và bác sĩ chuyên sâu về giấc ngủ.
Quy trình thăm khám bao gồm khai thác bệnh sử, đánh giá các yếu tố nguy cơ và
sử dụng những thang điểm sàng lọc như Epworth Sleepiness Scale hoặc STOP-BANG –
các công cụ được chấp thuận tại Việt Nam nhằm xác định sớm khả năng mắc OSA.
Ngoài ra, bác sĩ có thể tiến hành nội soi Tai Mũi Họng để tìm nguyên nhân gây
hẹp đường thở trên, chẳng hạn như phì đại amidan, lệch vách ngăn, hay bất
thường vùng hàm mặt.

Các đánh giá thường bắt đầu bằng khảo sát giấc ngủ toàn diện, bao gồm thu thập
bệnh sử liên quan đến các triệu chứng đặc trưng, sau đó tiến hành ghi nhận
khách quan bằng đa ký giấc ngủ (Polysomnography – PSG) \cite{diagnosis_osa,
  medical2006polysomnography}. Phương pháp PSG, khi được thực hiện dưới sự giám
sát của bác sĩ chuyên môn, được xem là tiêu chuẩn vàng trong chẩn đoán hội
chứng ngưng thở khi ngủ. Đây là một kỹ thuật ghi đa kênh liên tục trong suốt
một đêm, cho phép theo dõi đồng thời nhiều thông số sinh lý phản ánh toàn diện
hoạt động thần kinh và hô hấp trong giấc ngủ.

Một hệ thống PSG điển hình bao gồm: điện não đồ (EEG) để ghi và lưu lại hoạt
động điện của não; điện cơ đồ (EMG) nhằm đo trương lực cơ; điện động nhãn cầu
(EOG) để xác định giai đoạn ngủ thông qua chuyển động mắt; và điện tâm đồ (ECG)
để giám sát hoạt động tim. Bên cạnh đó, các cảm biến ghi nhận độ bão hòa oxy
trong máu (SpO\textsubscript{2}), lưu lượng khí thở qua mũi và miệng, nỗ lực hô
hấp thông qua chuyển động ngực và bụng, áp lực đường thở qua mũi, và cường độ
tiếng ngáy \cite{psg_paper, kushida2005psg}. Hình~\ref{fig:noxa1} là màn hình
phần mềm NoxA1 hiển thị nhiều tín hiệu sinh lý theo chuỗi thời gian, cho phép
quan sát đồng thời các kênh hô hấp, SpO$_2$, và chuyển động ngực – bụng. Hệ
thống cung cấp công cụ đánh dấu tự động và thủ công các sự kiện bất thường như
ngưng thở và giảm thở.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/noxa1.png} % giảm xuống 70% chiều rộng trang
  \vspace*{-5mm}
  \caption{Màn hình tổng hợp tín hiệu của PSG}
  \label{fig:noxa1}
\end{figure}

Trong số các tín hiệu này, tư thế ngủ là một thông số đặc biệt quan trọng, góp
phần xác định thể bệnh positional OSA (pOSA). Theo dõi liên tục tư thế cơ thể
trong quá trình PSG cho phép xác định mối tương quan giữa tư thế nằm và mức độ
nghiêm trọng của rối loạn hô hấp. Các thông số thu được sau đêm ghi PSG được
tổng hợp và phân tích, giúp bác sĩ đưa ra chẩn đoán chính xác về tình trạng
ngưng thở khi ngủ tắc nghẽn.

Tuy nhiên, phương pháp PSG vẫn tồn tại nhiều hạn chế trong thực tế. Việc yêu
cầu bệnh nhân lưu trú qua đêm tại cơ sở y tế, gắn nhiều điện cực và cảm biến
trên cơ thể không chỉ gây bất tiện mà còn có thể làm sai lệch hành vi ngủ tự
nhiên. Chi phí cao, thời gian chờ đợi dài, cùng tỷ lệ thu tín hiệu gián đoạn
hoặc nhiễu cũng là những trở ngại thường gặp. Kinh nghiệm thực tế cho thấy,
trong nhiều trường hợp, bác sĩ có thể đưa ra nhận định dựa trên một tập nhỏ
kênh tín hiệu còn nguyên vẹn, từ đó gợi mở hướng ứng dụng các mô hình học máy
(machine learning) nhằm tự động hóa quá trình nhận dạng.

\subsection{Thiết bị theo dõi OSA tại nhà}

Những hạn chế về chi phí, sự bất tiện và tính khả thi của đa ký giấc ngủ (PSG)
trong điều kiện lâm sàng đã thúc đẩy sự phát triển của các thiết bị theo dõi
giấc ngủ ngoài trung tâm (Out-of-Center Sleep Testing Devices – OCST), hay còn
gọi là thiết bị kiểm tra giấc ngủ tại nhà (Home Sleep Test – HST). Các hệ thống
HST được thiết kế với mục tiêu giảm thiểu số lượng cảm biến nhưng vẫn đảm bảo
độ chính xác chẩn đoán thông qua việc tích hợp các thuật toán xử lý tín hiệu
tiên tiến và mô hình học máy. Nhờ đó, các thiết bị có khả năng tự động thu
nhận, phân tích và phân loại các thông số sinh lý đặc trưng cho hội chứng ngưng
thở khi ngủ, có thể được thực thi trực tiếp trên phần cứng nhúng hoặc thông qua
ứng dụng hỗ trợ trên điện thoại di động.

Một trong những khung chuẩn được sử dụng rộng rãi trong quá trình phát triển
các hệ thống HST là mô hình \textbf{SCOPERA}, bao gồm sáu nhóm thông số cốt
lõi: \textit{Sleep (S)} – đặc trưng giấc ngủ; \textit{Cardiovascular (C)} –
hoạt động tim mạch; \textit{Oximetry (O)} – độ bão hòa oxy; \textit{Effort (E)}
– nỗ lực hô hấp; \textit{Respiratory flow (R)} – lưu lượng khí hô hấp; và
\textit{Audio (A)} – âm thanh thở.

Dựa trên hình thái cấu trúc và vị trí gắn trên cơ thể, các thiết bị HST có thể
được phân thành các nhóm chính như: vòng tay, đai ngực, miếng dán, tai nghe và
nhẫn thông minh (Bảng~\ref{tab:wearable_types}).

\begin{table}[htbp] \centering \caption{Phân loại thiết bị đeo trong phát hiện OSA. tư thế ngủ} \label{tab:wearable_types}
  \begin{tabular}{|p{5.5cm}|p{7.5cm}|} \hline
    \textbf{Loại thiết bị đeo} & \textbf{Tài liệu tham khảo}                                                           \\
    \hline Vòng tay            & \cite{e3hst,osa_sanchez2025, shen2022mtcnn, jeon2020realtime,}                        \\
    \hline Đai ngực            & \cite{e3hst, osa_sanchez2025, svmHSt2017, chen2024hdc}                                \\
    \hline Miếng dán           & \cite{osa_sanchez2025, yeo2022resnet, yeo2022respiratory, p_3}                        \\
    \hline Dạng khác           & \cite{hstSurvey, hst_paper, hst_wear_paper, osa_sanchez2025, Sleep_Posture_Detection} \\
    \hline\end{tabular}
\end{table}

Nghiên cứu của Jeon và cộng sự \cite{jeon2020realtime} sử dụng thiết bị đeo
Sleep Care Kit (Hình~\ref{fig:sleepcare}) gắn ở ngực để thu nhận tín hiệu nhịp
tim, gia tốc ba trục, hô hấp và SpO$_2$. Các mô hình Gaussian Naive Bayes,
Artificial Neural Network và k-Nearest Neighbor được huấn luyện nhằm phân loại
trạng thái hô hấp và phát hiện ngưng thở, trong đó mô hình KNN đạt độ chính xác
95\% và thời gian xử lý chỉ 640~$\mu$s – đáp ứng tiêu chí chẩn đoán OSA theo
thời gian thực. Tương tự, Chen và cộng sự \cite{chen2024hdc} phát triển thiết
bị vòng tay ghi tín hiệu PPG trên 100 đối tượng tình nguyện, tối ưu về bộ nhớ,
độ trễ và năng lượng, đồng thời đồng bộ dữ liệu với PSG để đảm bảo độ tin cậy,
hướng tới ứng dụng giám sát dài hạn tại nhà.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/sleepcare.png} % giảm xuống 70% chiều rộng trang
  \vspace*{-5mm}
  \caption{Thiết bị Sleep Care Kit}
  \label{fig:sleepcare}
\end{figure}

Yeo và cộng sự \cite{yeo2022resnet, yeo2022respiratory} triển khai thiết bị dán
\textit{T-REX TR100A} để ghi điện tâm đồ (ECG) một kênh tại vùng bụng trên.
Thiết bị dán trực tiếp lên da, đảm bảo tiếp xúc ổn định và tín hiệu chính xác,
giúp ghi liên tục trong thời gian dài mà không gây khó chịu cho người sử dụng.
Bên cạnh đó, nghiên cứu \cite{svmHSt2017} chỉ ra rằng các tín hiệu chuyển động
ngực (THO) và bụng (ABD) thu từ dải cảm biến áp điện có thể được khai thác hiệu
quả trong phân loại rối loạn hô hấp khi ngủ bằng mô hình SVM, đạt độ chính xác
trung bình 81.8%.

Ngoài ra, Domingues và cộng sự (2024) đề xuất một mô hình mạng nơ-ron nhân tạo
sử dụng dữ liệu từ SpO$_2$, cảm biến gia tốc và âm thanh ngáy của hệ thống
Biologix, cho kết quả tiệm cận độ chính xác của PSG truyền thống
\cite{domingues2024sleep}. Hướng tiếp cận khác được Boiko và cộng sự
\cite{Boiko2023} phát triển dựa trên cảm biến gia tốc đặt dưới nệm giường, ghi
nhận dao động do chuyển động ngực trong quá trình hô hấp. Hệ thống này đạt độ
chính xác 94.6\%, độ đặc hiệu 95.3\% và độ nhạy 93.7\%, khẳng định tiềm năng
ứng dụng của cảm biến thụ động trong phát hiện ngưng thở khi ngủ mà không cần
thiết bị đeo trực tiếp lên cơ thể.

Nhìn chung, các hệ thống HST thế hệ mới đang chuyển dịch từ kiến trúc đám mây
sang kiến trúc tại biên, tích hợp khả năng học máy. Điều này không chỉ nâng cao
tính riêng tư và độ tin cậy của dữ liệu, mà còn mở đường cho các thiết bị chẩn
đoán OSA cá nhân hóa, nhỏ gọn và có khả năng triển khai đại trà trong thực hành
y học giấc ngủ hiện đại.

\subsection{Thiết bị phân loại tư thế ngủ}

Hiện nay, đã có nhiều nghiên cứu tập trung phát triển các hệ thống theo dõi tư
thế ngủ phục vụ chẩn đoán và hỗ trợ điều trị hội chứng ngưng thở khi ngủ (OSA).
Hầu hết các hướng tiếp cận ban đầu đều sử dụng nhiều loại cảm biến như cảm biến
áp lực, camera RGB/hồng ngoại hoặc hệ thống đeo đa điểm, nhằm ghi nhận toàn bộ
chuyển động cơ thể trong khi ngủ. Chẳng hạn, Asma Channa và cộng sự
\cite{Channa_osa} đã phát triển hệ thống theo dõi tư thế ngủ sử dụng hai thảm
cảm biến áp lực để thu thập dữ liệu từ 13 người tham gia, với các thuật toán
học máy như Weighted KNN và Linear SVM cho độ chính xác tới 98,7\%. Tương tự,
Xi Xu và cộng sự \cite{xu2024classification} đề xuất mô hình stacking kết hợp
ba thuật toán mạnh (XGBoost, SVM, DNDT), tối ưu hóa bằng Bayesian optimization
và gán trọng số theo entropy weighting, đạt độ chính xác 94,48\% trên dữ liệu
áp suất từ nệm khí.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/sleep_camera.png} % giảm xuống 70% chiều rộng trang
  \vspace*{-5mm}
  \caption{Thiết thống nệm áp suất trong nghiên cứu của Xi Xu và cộng sự}
  \label{fig:sleep_camera}
\end{figure}

Các nghiên cứu sử dụng camera RGB hoặc hồng ngoại cũng cho kết quả ấn tượng
trong môi trường có kiểm soát. Ví dụ, Khan và cộng sự
\cite{KHAN20241729_camera} ứng dụng kết hợp camera RGB và camera nhiệt, huấn
luyện mô hình VGG16 và ResNet50, đạt độ chính xác 99\% khi sử dụng kỹ thuật hợp
nhất dữ liệu. Mahvash và cộng sự \cite{Mahvash_camera} tiếp tục mở rộng hướng
nghiên cứu này bằng cách sử dụng camera hồng ngoại 2D, kết hợp học sâu với mô
hình ResNet-152, cho kết quả accuracy = 95.1\%, f1-score = 94.9\% và kappa =
92.2\%, vượt trội hơn cảm biến PSG truyền thống. Ngoài ra, một hướng tiếp cận
không tiếp xúc khác sử dụng cảm biến radar sóng milimet cũng được đề xuất để
nhận dạng tư thế ngủ. Phương pháp này khai thác chiến lược học tương tác giữa
thông tin ngắn hạn và dài hạn nhằm tăng tính ổn định của mô hình, qua ba giai
đoạn: tách trạng thái chuyển động, phân loại ba tư thế ngủ cơ bản (nằm ngửa,
nằm nghiêng, nằm sấp) và nhận dạng bảy chuyển đổi tư thế theo thời gian thực.
Kết quả cho thấy hệ thống đạt độ chính xác 91\% trong nhận dạng tư thế và
83.7\% trong phát hiện chuyển tư thế, với ưu điểm nổi bật về khả năng bảo vệ
quyền riêng tư và độ ổn định tín hiệu. Nhóm Yunyoung Nam và cộng sự cũng đã
tích hợp hệ thống thu thập, phân tích sử dụng một cảm biến gia tốc ba trục và
một cảm biến áp suất để giám sát chất lượng giấc ngủ tư thế ngủ, trạng thái
ngủ, giai đoạn ngủ (REM và chu kỳ giai đoạn ngủ không REM)
\cite{hst_pressure_paper}. Tại Việt Nam, nhóm nghiên cứu của Giáo sư Lê Tiến
Thường, trường đại học Bách Khoa TP Hồ Chí Minh đã sử dụng cảm biến gia tốc
MPU6050 cùng với vi xử lý ESP32 nhằm ghi nhận hơi thở và nhịp tim của bệnh nhân
OSA thông qua rung động, và dòng chảy của động mạch và tĩnh mạch ở cổ
\cite{thuong_wear_paper}.

Ngoài ra, hiện nay với sự phát triển vượt bậc của điện thoại di động, việc tận
dụng cảm biến gia tốc ở ngay trên chính chiếc điện thoại cũng là giải pháp hữu
hiệu \cite{sun2017sleepmonitor}. Nhóm tác giả trong \cite{Ferrer_osa} đã báo
cáo nghiên cứu đánh giá tư thế ngủ của bệnh nhân sử dụng thiết bị di động đeo ở
xương ức kết hợp với phần mềm trên nền tảng Android để thu thập lại dữ liệu kể
cả khi tắt màn hình. Trong một nghiên cứu tiêu biểu, Natale và cộng sự đã khai
thác các cảm biến tích hợp sẵn trên điện thoại iPhone để ước lượng các thông số
liên quan đến chất lượng giấc ngủ, bao gồm tổng thời gian ngủ (Total Sleep Time
– TST), độ trễ vào giấc (Sleep Onset Latency – SOL) và hiệu quả giấc ngủ (Sleep
Efficiency – SE). Phương pháp tiếp cận này cho thấy tiềm năng trong việc sử
dụng thiết bị di động như một công cụ theo dõi giấc ngủ tiện lợi và dễ tiếp
cận, đặc biệt trong các nghiên cứu cộng đồng và ứng dụng tại
nhà\cite{Natale_osa}. Đặc điểm của sử dụng tích hợp cảm biến gia tốc trên điện
thoại là rất tiện lợi, sử dụng trực tiếp mà không cần phát triển phần cứng. Tuy
nhiên, việc tiếp xúc điện thoại trực tiếp với cơ thể trực tiếp trong thời gian
lâu cũng có gây những ảnh hưởng nhất định đến người dùng.

Tuy nhiên, các hệ thống trên đều có hạn chế về tính phức tạp phần cứng, yêu cầu
nhiều cảm biến, khó áp dụng trong điều kiện thực tế tại nhà. Vì vậy, xu hướng
nghiên cứu gần đây tập trung vào việc tối giản phần cứng, đặc biệt là sử dụng
duy nhất một cảm biến gia tốc để nhận dạng tư thế ngủ.

Trong hướng này, Jeng và cộng sự \cite{Jeng_osa} phát triển hệ thống iSleePost
gồm hai cảm biến gia tốc đeo ở cổ tay và ngực để ánh xạ chuyển động và nhãn tư
thế, với độ chính xác trung bình 0.82–0.84. Zhang và cộng sự \cite{Zhang_osa}
tiến thêm một bước khi chỉ sử dụng một cảm biến gia tốc ba trục gắn ở ngực, kết
hợp bộ phân loại tuyến tính (LDA), cho phép nhận dạng bốn tư thế ngủ cơ bản và
phát hiện chuyển động hiệu quả. Một số thiết kế khác như Wearable Sleep System
(WSS) \cite{kwasnicki2018} hoặc thiết bị HST dạng miếng dán cổ
\cite{Sleep_Posture_Detection} cũng tận dụng cảm biến gia tốc ba trục để đạt độ
chính xác cao (trên 97\%) trong nhận dạng tư thế ngủ.

Nghiên cứu \cite{abdulsadig2023}, tác giả tập trung vào nhận dạng tư thế ngủ tự
động bằng cảm biến gia tốc đơn gắn tại vùng cổ (Hình~\ref{fig:vitri_co}), vị
trí thuận lợi cho việc kết hợp theo dõi đa thông số sinh lý trong các ứng dụng
y tế như OSA hoặc động kinh. Ba mô hình được thử nghiệm gồm Decision Tree (DT),
Extra-Trees (ET) và LSTM Neural Network (LSTM-NN), nhằm đánh giá hiệu năng
trong điều kiện giới hạn về năng lượng và bộ nhớ của thiết bị đeo. Kết quả cho
thấy chỉ với tần số lấy mẫu 5 Hz và cửa sổ 1 s, các mô hình vẫn đạt độ chính
xác trung bình > 98\% và f1-score lần lượt 0.945, 0.975, 0.965, trong đó mô
hình DT có ưu thế về tốc độ dự đoán (0.8 ms) và dung lượng nhỏ (1.765 KB), phù
hợp triển khai trên các thiết bị IoT công suất thấp. Đặc biệt, tác giả Vũ Hoàng
Diệu và cộng sự \cite{Vu2025SleepPosition} đã chứng minh khả năng của một hệ
thống đơn cảm biến gia tốc trong nhận dạng đến 12 tư thế ngủ phục vụ bệnh nhân
GERD, sử dụng mô hình AnpoNet kết hợp 1D-CNN và LSTM, đạt độ chính xác 94,67\%
và f1-score 92,94\%. Kết quả này cho thấy cảm biến gia tốc đơn không chỉ đảm
bảo độ chính xác cao mà còn mang lại sự tiện lợi, chi phí thấp và khả năng
triển khai thực tế.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/vitri_co.png} % giảm xuống 70% chiều rộng trang
  \vspace*{-5mm}
  \caption{Ví trị đặt cảm biến được đề xuất trong nghiên cứu \cite{abdulsadig2023}}
  \label{fig:vitri_co}
\end{figure}

Bám sát định hướng này, luận văn đề xuất một hệ thống sử dụng duy nhất một cảm
biến gia tốc gắn dưới hõm ức để phát hiện các tư thế ngủ liên quan đến OSA. Vị
trí ở cổ còn là tiền đề để nhóm mở rộng thêm cảm biến như luồng khí thở với mục
đích đánh giả OSA. Dữ liệu thu được sẽ được xử lý qua các bước tiền xử lý,
trích xuất đặc trưng và huấn luyện mô hình học máy nhẹ, hướng tới việc phát
triển thiết bị IoT nhỏ gọn, tiêu thụ năng lượng thấp và có khả năng ước lượng
chỉ số AHI. Cách tiếp cận này kỳ vọng góp phần hiện thực hóa việc sàng lọc và
theo dõi OSA tại nhà một cách hiệu quả, tiện lợi và có chi phí thấp.

\subsection{Cảm biến gia tốc trong đánh giá tư thế ngủ}
Từ góc độ học thuật, các công trình nghiên cứu gần đây đã khẳng định tính hiệu
quả và độ tin cậy của cảm biến gia tốc trong việc phân loại tư thế ngủ ở người.
\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.75\textwidth, keepaspectratio]{images/vị trí đặt cảm biến.png}
  \vspace*{-5mm}
  \caption{Vị trí tối ưu để gắn cảm biến gia tốc}
  \label{position_sensor}
\end{figure}

Ưu điểm nổi bật của cảm biến gia tốc nằm ở khả năng vận hành độc lập với mức
tiêu thụ năng lượng thấp, đồng thời có thể tích hợp dễ dàng vào các hệ thống
vi điều khiể.
Nhờ đó, cảm biến này đặc biệt thích hợp cho việc phát triển các thiết
bị đeo thông minh có khả năng xử lý tại chỗ, nhỏ gọn, di động, tiêu thụ năng lượng thấp phù hợp với xu hướng TinyML
trong lĩnh vực điện toán biên. Ngoài ra, cảm biến gia tốc không phụ
thuộc vào các điều kiện môi trường như ánh sáng hay địa hình phẳng,
và quan trọng hơn, không xâm phạm quyền riêng tư của người dùng
như các hệ thống giám sát bằng hình ảnh.

Tuy nhiên, giới hạn kỹ thuật chủ yếu của cảm biến gia tốc xuất phát từ tính
nhạy cảm đối với vị trí gắn cảm biến. Việc lắp đặt sai vị trí hoặc xoay lệch
trục có thể dẫn đến sai lệch nghiêm trọng trong kết quả phân loại tư thế. Hơn
nữa, cảm biến này không cung cấp thông tin về các thông số sinh lý quan trọng
như độ bão hòa oxy trong máu ($\mathrm{SpO_2}$), nhịp thở hoặc nhịp tim. Do đó,
để chẩn đoán toàn diện hội chứng ngưng thở khi ngủ tắc nghẽn (OSA), việc tích
hợp cảm biến đa kênh hoặc ứng dụng các mô hình suy luận dựa trên học máy là cần
thiết nhằm bù đắp cho những thiếu hụt về dữ liệu sinh lý.

Về mặt lựa chọn vị trí, các vùng như cổ tay hoặc trán thường chịu ảnh hưởng
mạnh từ các chuyển động ngoại ý và lệch trục cơ thể, làm giảm độ đại diện của
tín hiệu thu được. Ngược lại, vùng cổ được xem là vị trí lý tưởng nhờ tính ổn
định hình học cao, gần trục trung tâm của cơ thể, và khả năng phản ánh trực
tiếp hướng trọng lực. Những đặc điểm này giúp tín hiệu gia tốc tại vùng cổ có
độ tương quan cao với tư thế ngủ thực tế, qua đó nâng cao độ chính xác của hệ
thống nhận diện tư thế trong ứng dụng y sinh. Đặc biệt, thuận lợi cho việc tích
hợp thêm các cảm biến khác như cảm biến âm thanh (microphone) hoặc cảm biến
nhiệt độ, phục vụ cho các mục tiêu mở rộng trong các nghiên cứu tiếp theo

Xuất phát từ các phân tích nêu trên, nghiên cứu này lựa chọn thiết kế một thiết
bị đeo tiếp xúc sử dụng cảm biến gia tốc ba trục, được gắn tại vùng cổ.

Sau khi xác định được vị trí gắn tối ưu, bước tiếp theo là làm rõ cơ sở nguyên
lý đo lường của cảm biến, nhằm lý giải vì sao thiết bị này có thể phản ánh
chính xác tư thế cơ thể trong khi ngủ.

\subsection*{Nguyên lý cảm biến gia tốc}

Cảm biến gia tốc là một thiết bị đo lường có khả năng phát hiện và ghi nhận gia
tốc theo thời gian. Với ưu điểm nhỏ gọn, tiêu thụ năng lượng thấp và chi phí
hợp lý, cảm biến gia tốc được ứng dụng rộng rãi trong nhiều lĩnh vực như điện
tử tiêu dùng, ô tô, công nghiệp, trong các thiết bị theo dõi hoạt động và giấc
ngủ \cite{Santoso2015_mems_accelerometer_apply,
  Szermer2025_mems_accelerometer_apply}.

Hiện nay, có 3 dạng chính của cảm biến gia tốc vi cơ điện tử
(Micro-Electro-Mechanical Systems - MEMS) là kiểu điện trở áp, kiểu điện dung
và kiểu áp điện \cite{Shi2023_mems_accelerometer}.

\subsubsection*{Cảm biến gia tốc MEMS điện trở áp}

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.75\textwidth, keepaspectratio]{images/giatoc_ap_dien_tro.png}
  \vspace*{-5mm}
  \caption{(a) Sơ đồ bố trí tổng thể của cảm biến gia tốc điện trở áp
    (b) Cấu trúc mặt cắt qua khối trọng và dầm
    (c) Cầu Wheatstone đo gia tốc trục X
    (d) Cầu Wheatstone đo gia tốc trục Y
    (e) Cầu Wheatstone đo gia tốc trục Z.}
  \label{position_sensor}
\end{figure}

Đầu tiên, cảm biến MEMS điện trở áp ra đời sớm nhất, có cấu tạo gồm một khối
dầm bằng vật liệu có tính điện trở áp, kèm theo một khối trọng (mass) và
khung đỡ \cite{Song2018_mems_accelerometer}.
Bề mặt trên của khối trọng, các dầm và khung nằm trên cùng một mặt phẳng,
đảm bảo tính đối xứng cấu trúc và khả năng tương thích cao với quy trình
chế tạo vi cơ điện tử (MEMS).
Khi cảm biến chịu tác động của gia tốc ngoài, ứng suất cơ học
xuất hiện tại vùng đầu dầm, dẫn đến sự thay đổi điện trở của các
phần tử này. Các điện trở piezo-resistive được bố trí và
liên kết một cách tối ưu để tạo thành ba cầu Wheatstone độc lập,
tương ứng với việc phát hiện các thành phần gia tốc theo ba trục vuông góc X, Y và Z,

Trong mỗi cầu Wheatstone, sự thay đổi điện trở vi sai được chuyển đổi trực tiếp
thành tín hiệu điện áp đầu ra, cho phép cảm biến biến đổi biến dạng cơ học
thành tín hiệu điện tương ứng. Dựa trên đặc tính hình học và sự đối xứng của
cấu trúc, mô hình toán học của cảm biến có thể được chia thành hai trường hợp
chính: (1) Gia tốc tác dụng theo phương vuông góc với mặt phẳng (trục Z); (2)
Gia tốc tác dụng trong mặt phẳng (trục X hoặc Y).

\subsubsection*{Cảm biến gia tốc MEMS áp điện}

Cảm biến gia tốc được cấu tạo gồm hai phần chính
\cite{Li2018_mems_accelerometer}: (1)Dầm đàn hồi– là một dầm silicon có một đầu
cố định và đầu còn lại tự do mang trọng (mass block). Khi có gia tốc tác động,
khối lượng này tạo ra lực quán tính khiến dầm bị uốn cong, sinh ra ứng suất cơ
học trên bề mặt dầm. Các thông số hình học cơ bản bao gồm: chiều dài dầm ($L$),
chiều rộng ($b$), độ dày ($h$), chiều rộng khối lượng ($d$) và độ dày khối
lượng ($t$); (2)Cấu trúc áp điện – gồm ba lớp vật liệu xếp chồng theo thứ tự:
lớp điện cực dưới thường bằng bạch kim/titan, lớp màng áp điện thường bằng
Li-doped ZnO, và lớp điện cực trên thường bằng nhôm.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.75\textwidth, keepaspectratio]{images/giatoc_ap_dien.png}
  \vspace*{-5mm}
  \caption{Cấu trúc cơ bản của cám biến MEMS áp điện: (a) mặt trên (b) mặt dưới}
  \label{giatoc_ap_dien}
\end{figure}

\noindent
Khi chịu tác dụng của lực ngoài $F$, dầm công xôn bị biến dạng đàn hồi.
Theo phân tích cơ học dầm và lý thuyết biến dạng nhỏ \cite{Hao2013_mems_accelerometer},
ứng suất dọc $\sigma_l$ xuất hiện trên bề mặt dầm theo phương trục $x$ được biểu diễn như sau:

\begin{equation}
  \sigma_l = \sigma_1 = \frac{6 F L}{b h^2}
\end{equation}

\noindent
Dựa trên hiệu ứng áp điện thuận,
hai bề mặt trên và dưới của màng áp điện ZnO pha tạp Li
lần lượt mang điện tích dương và âm theo phương trục $z$.
Lượng điện tích cảm ứng $q_3$ được xác định bởi công thức:

\begin{equation}
  q_3 = d_{31} \sigma_1
\end{equation}

\noindent
Trong đó, $d_{31}$ là hệ số áp điện,
và $\sigma_1$ là ứng suất pháp tuyến theo phương $x$.
Theo định nghĩa, điện dung $C$ giữa hai điện cực trên và dưới của cấu trúc áp điện được xác định bởi:

\begin{equation}
  C = \frac{q_3}{V}
\end{equation}

\noindent
với $V$ là điện áp đầu ra giữa hai điện cực của màng áp điện.
Từ các quan hệ trên, điện áp đầu ra có thể được biểu diễn theo dạng:

\begin{equation}
  V = \frac{d_{31} \cdot 6 m L}{b h^2 C} \cdot a
\end{equation}

\noindent
Kết hợp với định nghĩa độ nhạy của cảm biến,
ta có biểu thức:

\begin{equation}
  S = \frac{V}{a} = \frac{d_{31} \cdot 6 m L}{b h^2 C}
\end{equation}

\subsubsection*{Cảm biến gia tốc MEMS điện dung}
Cảm biến gia tốc điện dung được gồm ba khối chức năng chính:
khối trọng, hệ dầm đàn hồi và cụm lược điện cực \cite{Wang2022_mems_accelerometer}.
Khối trọng là phần trung tâm của cảm biến, dao động khi có gia tốc tác động.
Các dầm có nhiệm vụ đỡ và liên kết khối lượng này,
đồng thời cho phép chuyển động đàn hồi trong giới hạn thiết kế.
Cụm lược ghép (assembly combs)  được sử dụng để căn chỉnh trong quá trình chế tạo,
trong khi cụm lược kích thích (drive combs) tạo dao động cưỡng bức cho khối lượng quán tính trong các thí nghiệm đo đáp ứng.
Cụm lược đo (sense combs) đảm nhiệm chức năng phát hiện độ dịch chuyển của khối lượng thông qua sự thay đổi điện dung giữa các ngón điện cực.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.75\textwidth, keepaspectratio]{images/giatoc_diendung.png}
  \vspace*{-5mm}
  \caption{Sơ đồ thiết kế cơ bản của cảm biến MEMS điện dung}
  \label{giatoc_diendung}
\end{figure}

Các cụm lược kích thích và cụm lược ghép có cấu trúc tương tự nhau, chỉ khác về
số lượng các ngón điện cực. Trong phần đo tín hiệu, cảm biến sử dụng hai cụm
lược đo (sense combs 1 và sense combs 2) được mắc theo cấu hình vi sai. Khi cảm
biến dịch chuyển dọc theo trục $x$, điện dung của sense combs 1 giảm, trong khi
điện dung của sense combs 2 tăng. Hai tín hiệu điện dung biến thiên ngược pha
này giúp tăng hệ số khuếch đại vi sai và loại bỏ nhiễu chế độ chung, nhờ đó cải
thiện đáng kể độ nhạy và độ ổn định của cảm biến điện dung.

\begin{figure}[H]
  \centering
  \[
    \text{Tác động đầu vào}
    \;\xrightarrow[\text{Gây ra dịch chuyển }x]{}
    \;
    \text{Thay đổi điện dung }(\Delta C)
    \;\xrightarrow[\text{Mạch xử lý tín hiệu}]{}
    \;
    \text{Điện áp ra}
  \]
  \caption{Quá trình biến đổi tín hiệu trong cảm biến điện dung.}
  \label{fig:signal_flow}
\end{figure}

Tín hiệu đầu vào là một đại lượng vật lý cần đo (ví dụ: gia tốc, áp suất, vị
trí), tác động lên cảm biến điện dung và gây ra sự dịch chuyển cơ học $x$ giữa
các bản cực của tụ điện. Sự dịch chuyển này làm thay đổi điện dung $\Delta C$
của cảm biến. Biến thiên điện dung $\Delta C$ này được mạch xử lý tín hiệu
(signal conditioning circuit) chuyển đổi thành điện áp đầu ra $V_{\text{out}}$.

\textbf{Nguyên lý kích thích và chuyển đổi C–V trong cảm biến điện dung MEMS}

Dựa trên nguyên lý cảm ứng điện dung vi sai, hai tụ điện cảm biến có điện dung
lần lượt được xác định bởi \cite{Tirupathi2018_mems_accelerometer}:

\begin{equation}
  C_1 = C_0 + \Delta C,
  \qquad
  C_2 = C_0 - \Delta C
\end{equation}

\noindent
Trong đó, $C_0$ là điện dung danh định khi không có gia tốc tác động,
và $\Delta C$ là phần biến thiên điện dung phát sinh do dịch chuyển cơ học của khối trọng dưới tác dụng của gia tốc.

\noindent
Tín hiệu kích thích được áp dụng lên hai tụ có dạng sóng vuông vi sai $\pm V_p$,
gọi là điện áp kích thích.
Sự dịch chuyển cơ học $x$ gây ra biến thiên điện dung $\Delta C$ được chuyển đổi thành tín hiệu điện thông qua
mạch khuếch đại điện tích
hoạt động theo nguyên lý bảo toàn điện tích:

\begin{equation}
  Q = C_f \, V_{\text{out}}
\end{equation}

\noindent
Trong đó, $Q$ là điện tích tích lũy tại nút khuếch đại,
$C_f$ là điện dung phản hồi của op-amp,
và $V_{\text{out}}$ là điện áp đầu ra của mạch.

\noindent
Sau quá trình giải điều chế  trong hai pha $\varphi_1$ và $\varphi_2$,
hai nhánh đầu ra vi sai của mạch được xác định bởi:

\begin{equation}
  V_{\text{out}+} = V_{\text{cm}} + \frac{4 \, \Delta C}{C_f} \, V_p,
  \qquad
  V_{\text{out}-} = V_{\text{cm}} - \frac{4 \, \Delta C}{C_f} \, V_p
\end{equation}

\noindent
với $V_{\text{cm}}$ là điện áp chế độ chung ,
$V_p$ là biên độ của tín hiệu kích thích.

\noindent
Khi lấy hiệu hai đầu ra vi sai, điện áp hữu ích của cảm biến được xác định như sau:

\begin{equation}
  V_{\text{out}} = V_{\text{out}+} - V_{\text{out}-} = \frac{8\,\Delta C}{C_f}\,V_p
\end{equation}

\noindent
Trong đó, $\Delta C$ biểu thị mức độ biến dạng cơ học của phần tử cảm biến (do gia tốc, áp suất hoặc lực),
$C_f$ quyết định độ khuếch đại của mạch (giá trị $C_f$ càng nhỏ thì độ khuếch đại càng lớn),
và $V_p$ là biên độ kích thích tỉ lệ thuận với biên độ điện áp đầu ra.

\noindent
Từ công thức~(4), có thể thấy rằng điện áp vi sai đầu ra $V_{\text{out}}$
tỉ lệ tuyến tính với biến thiên điện dung $\Delta C$,
tỉ lệ thuận với điện áp kích thích $V_p$,
và tỉ lệ nghịch với điện dung phản hồi $C_f$.

\noindent
Dạng tổng quát của mối quan hệ này có thể được biểu diễn gọn hơn như sau:

\begin{equation}
  V_{\text{out}} = K \cdot \frac{\Delta C}{C_f} \, V_p
\end{equation}

\noindent
với $K = 8$ là \textbf{hệ số khuếch đại hiệu dụng} (\textit{effective gain factor})
phụ thuộc vào cấu hình vi sai và mạch lấy mẫu–giữ (\textit{sample–hold circuit}).

\begin{table}[H]
  \centering
  \caption{ So sánh đặc tính giữa ba loại cảm biến gia tốc MEMS}
  \label{tab:so_sanh_cam_bien_MEMS}
  \renewcommand{\arraystretch}{1.25}
  \fontsize{9pt}{11pt}\selectfont
  \begin{tabular}{|p{4cm}|p{3.4cm}|p{3.4cm}|p{3.4cm}|}
    \hline
    \textbf{Tham số}                      & \textbf{Áp điện}                     & \textbf{Áp điện trở}                 & \textbf{Điện dung}                                                 \\ \hline

    \textbf{Đáp ứng DC}                   & Kém – không đo được tín hiệu tĩnh    & Tốt – đo được tín hiệu tĩnh          & Tốt – đo được tín hiệu tĩnh và chậm                                \\ \hline

    \textbf{Trở kháng}                    & Cao                                  & Thấp                                 & Cao                                                                \\ \hline

    \textbf{Mức tín hiệu}                 & Cao – tạo điện áp trực tiếp          & Thấp – cần khuếch đại cầu Wheatstone & Trung bình – phụ thuộc vào biến thiên điện dung và mạch khuếch đại \\ \hline

    \textbf{Hiệu chuẩn tĩnh}              & Kém                                  & Tốt                                  & Tốt                                                                \\ \hline

    \textbf{Độ nhạy}                      & Cao                                  & Thấp                                 & Cao                                                                \\ \hline

    \textbf{Thiết kế giảm chấn}           & Kém – khó kiểm soát tắt dần          & Tốt – dễ điều chỉnh                  & Tốt – điều khiển được qua cấu trúc MEMS                            \\ \hline

    \textbf{Giá thành}                    & Cao – vật liệu và chế tạo phức tạp   & Thấp – tương thích công nghệ CMOS    & Cao – yêu cầu mạch xử lý phức tạp                                  \\ \hline

    \textbf{Đo xung dài ($>$10 ms)}       & Kém – chỉ đo tín hiệu dao động nhanh & Tốt                                  & Tốt                                                                \\ \hline

    \textbf{Độ nhạy với ứng suất lắp đặt} & Cao – dễ sai lệch do biến dạng       & Thấp                                 & Thấp – cấu trúc vi sai cân bằng                                    \\ \hline

    \textbf{Độ phức tạp của mạch}         & Đơn giản – xuất điện áp trực tiếp    & Đơn giản – cầu Wheatstone            & Phức tạp – cần mạch khuếch đại vi sai, điều chế–giải điều chế      \\ \hline
  \end{tabular}
\end{table}

Dựa vào Bảng~\ref{tab:so_sanh_cam_bien_MEMS} trong khuôn khổ luận văn này, cảm
biến gia tốc MEMS kiểu điện dung được lựa chọn làm phần tử cảm biến trung tâm
cho hệ thống theo dõi tư thế ngủ kéo dài, trên cơ sở đánh giá đa chiều cả về
đặc trưng tín hiệu, yêu cầu hệ thống, lẫn khả năng triển khai thực tế.

\textbf{Tóm lại}, việc lựa chọn cảm biến điện dung MEMS không đơn thuần là một quyết định kỹ thuật thuần tuý, mà còn phản ánh một giải pháp có tính cân bằng giữa hiệu quả đo lường, khả năng tích hợp phần cứng, và chiến lược mở rộng ứng dụng lâm sàng theo hướng chi phí thấp. Đây là một trong những nguyên tắc then chốt trong xu hướng đổi mới công nghệ y tế cộng đồng hiện đại – nơi mà tính khả thi triển khai và khả năng mở rộng đóng vai trò không kém phần quan trọng so với độ chính xác kỹ thuật.

\vspace{1em}

Nhìn chung, việc xác định tư thế ngủ để phục vụ việc chẩn đoán hội chứng ngưng
thở khi ngủ đòi hỏi một hệ thống giám sát liên tục, có khả năng thu thập dữ
liệu sinh lý trong thời gian dài trong môi trường sinh hoạt tự nhiên tại nhà.
Những yêu cầu này không chỉ giới hạn ở độ chính xác mô hình, mà còn mở rộng tới
tiêu chí về tính gọn nhẹ, tiết kiệm năng lượng, và dễ triển khai trên nền tảng
vi điều khiển hoặc thiết bị đeo.

Trong bối cảnh đó, các mô hình học máy trở thành công cụ thiết yếu để khai thác
dữ liệu cảm biến. Chúng không chỉ cho phép phân loại tư thế với độ chính xác
cao mà còn mở rộng sang suy luận các chỉ số lâm sàng như AHI. Việc triển khai
trực tiếp trên vi điều khiển Cortex-M4 theo hướng TinyML đưa giải pháp từ phòng
thí nghiệm đến ứng dụng thực tiễn tại nhà, đánh dấu sự giao thoa giữa y học
giấc ngủ truyền thống và trí tuệ nhân tạo ứng dụng – một lĩnh vực đang phát
triển mạnh mẽ trong thập niên gần đây \cite{osa_sanchez2025}.

\subsection{Học máy trong phân loại tư thế ngủ}

Hiện nay, trí tuệ nhân tạo (AI) đã và đang len lỏi vào hầu hết các lĩnh vực của
đời sống, đặc biệt là trong các thiết bị y tế tại nhà. Việc ứng dụng các kỹ
thuật học máy (machine learning) không chỉ giúp nâng cao hiệu suất xử lý, giảm
chi phí vận hành, mà còn đảm bảo tính ổn định và độ lặp lại cao, đồng thời giảm
thiểu sự can thiệp trực tiếp của con người.

Với lượng dữ liệu phong phú và liên tục được thu thập từ các cảm biến sinh học,
học máy trở thành công cụ thiết yếu để phân tích và khai thác hiệu quả các dòng
dữ liệu này, giúp đưa ra quyết định nhanh chóng và chính xác.

Đặc biệt, trong bối cảnh các thiết bị theo dõi sức khỏe tại nhà yêu cầu kích thước nhỏ gọn,
tính di động cao, và không phụ thuộc vào kết nối Internet,
thì học máy tại biên (Edge Machine Learning) nổi lên như một
giải pháp tối ưu vừa mang lại khả năng tính toán mạnh mẽ,
vừa dễ dàng triển khai trên các phần cứng có giới hạn tài nguyên.

Chính vì những lý do đó, tác giả lựa chọn hướng nghiên cứu và phát triển học
máy tại biên cho đề tài này.

Bảng~\ref{tab:pipeline_steps} trình bày tổng quan quy trình triển khai một bài
toán học máy.

\begin{table}[htbp]
  \centering
  \caption{Các bước chính trong bài toán sử dụng học máy trên biên}
  \label{tab:pipeline_steps}
  \small
  \renewcommand{\arraystretch}{1.2}
  \begin{tabular}{|c|p{3.8cm}|p{9.2cm}|}
    \hline
    \textbf{STT} & \textbf{Giai đoạn}                      & \textbf{Mô tả tổng quát}                                                                                                             \\
    \hline
    1            & \textbf{Thu thập tín hiệu}              & Ghi nhận tín hiệu từ cảm biến, xử lý  và lưu trữ.                                                                                    \\
    \hline
    2            & \textbf{Tiền xử lý}                     & Lọc nhiễu, phân đoạn theo cửa sổ thời gian, thống kê dữ liệu.                                                                        \\
    \hline
    3            & \textbf{Trích xuất đặc trưng}           & Tính toán các đặc trưng thời gian, tần số - đại diện cho nội dung sinh lý trong từng đoạn tín hiệu.                                  \\
    \hline
    4            & \textbf{Lựa chọn và huấn luyện mô hình} & Lựa chọn thuật toán học máy phuù hợp với bài toán.                                                                                   \\
    \hline
    5            & \textbf{Đánh giá hiệu năng}             & Sử dụng các chỉ số đánh giá mô hình như Accuracy, Precision, Recall, F1-Score, AUC, confusion matrix.                                \\
    \hline
    6            & \textbf{Tối ưu mô hình}                 & Ứng dụng kỹ thuật cắt tỉa (pruning), lượng tử (quantization) để giảm kích thước và độ phức tạp mô hình nhằm phục vụ triển khai biên. \\
    \hline
    7            & \textbf{Triển khai thực tế}             & Triển khai mô hình trên vi điều khiển, đánh giá và tái huấn luyện                                                                    \\
    \hline
  \end{tabular}
\end{table}

Quy trình này có thể được điều chỉnh linh hoạt tùy theo loại tín hiệu đầu vào
và mục tiêu phân tích cụ thể, chẳng hạn như nhận diện tư thế ngủ, phát hiện
ngưng thở hay theo dõi nhịp hô hấp. Tuy nhiên, nguyên tắc cốt lõi vẫn là đảm
bảo tín hiệu đầu vào có chất lượng cao và mô hình học máy đủ nhẹ để triển khai
trong thực tế.

\textbf{Phần tiếp theo tác giả sẽ tập trung phân tích quy trình triển khai nêu trên vào
  bài toán phân loại tư thế ngủ và đánh giá OSA.}

\subsubsection{Thu thập tín hiệu}

Là bước đầu tiên và đóng vai trò nền tảng trong toàn bộ quy trình tiếp đó. Các
tín hiệu được ghi nhận có thể bao gồm tín hiệu gia tốc ba trục để phát hiện
chuyển động và tư thế nằm; tín hiệu PPG dùng để đo nhịp tim và độ bão hòa oxy
trong máu; tín hiệu ECG phản ánh hoạt động điện học của tim; hoặc các tín hiệu
hô hấp và áp lực từ cảm biến gắn trên giường, giúp xác định tư thế ngủ thông
qua phân bố trọng lực và các tín hiệu bổ sung khác. Tùy theo dạng dữ liệu thu
thập và cấu hình thiết bị, các tín hiệu này được lấy mẫu với tần số phù hợp
\cite{Sleep_Posture_Detection, Jeng_osa, Zhang_osa, Ferrer_osa, Sang,
  osa_sanchez2025}.

Một yêu cầu then chốt của bước này là đảm bảo tính ổn định và chất lượng dữ
liệu. Các cảm biến cần được gắn cố định tại các vị trí tối ưu, chẳng hạn như
vùng ngực, cổ tay hoặc hõm ức, nhằm giảm nhiễu chuyển động và duy trì tiếp xúc
ổn định trong suốt quá trình theo dõi.

Ngoài ra, hệ thống cũng cần đảm bảo khả năng lưu trữ và truyền dữ liệu hiệu quả
thông qua các giao thức không dây tiết kiệm năng lượng như Bluetooth Low Energy
(BLE) hoặc Wi-Fi \cite{thuong_wear_paper, hst_wear_paper,
  Sleep_Posture_Detection}.

Chất lượng dữ liệu thu được trong bước này ảnh hưởng trực tiếp đến hiệu quả của
toàn bộ hệ thống học máy. Do đó, quy trình thu thập tín hiệu cần được thiết kế
sao cho vừa đảm bảo độ chính xác sinh lý, vừa duy trì tính khả thi khi triển
khai lâu dài trong môi trường ngoài lâm sàng.

Tuy nhiên, trong nhiều nghiên cứu hiện nay, kiến trúc phần mềm cho quá trình
thu thập và lưu trữ dữ liệu vẫn chưa được mô tả một cách đầy đủ và thống nhất.
Các yếu tố như:
\begin{itemize}
  \item Kiến trúc hệ thống: ứng dụng di động, nền tảng web hoặc máy chủ trung tâm;
  \item Giao thức truyền thông: MQTT, HTTP;
  \item Phương thức lưu trữ dữ liệu: cục bộ, đám mây (cloud) hoặc cơ sở dữ liệu liên
        kết;
  \item Các vấn đề liên quan đến mã hóa, bảo mật dữ liệu sức khỏe và tuân thủ quy định
        chuyên ngành (chuẩn HIPAA, GDPR hoặc quy định y tế quốc gia).
\end{itemize}

Việc thiếu chuẩn hóa trong các yếu tố trên có thể ảnh hưởng đáng kể đến khả
năng mở rộng, tích hợp và ứng dụng thực tiễn của hệ thống trong môi trường chăm
sóc sức khỏe tại nhà. Chính vì vậy, luận văn này tập trung giải quyết những hạn
chế đó, hướng đến xây dựng một quy trình thu thập và quản lý tín hiệu sinh học
thống nhất, bảo mật và sẵn sàng cho triển khai thực tế.

\subsubsection{Tiền xử lý}

\textbf{Lọc tín hiệu} là bước đầu tiên trong tiền xử lý nhằm loại bỏ nhiễu khỏi
các tín hiệu sinh lý như EEG, ECG, EMG, $\mathrm{SpO_2}$ và gia tốc.
Các loại nhiễu thường gặp bao gồm: nhiễu điện lưới (50–60 Hz),
chuyển động cơ thể, nhiễu tần số cao và trôi đường
cơ sở \cite{rossi2023sleep, sheta2021osa}.
Trong nghiên cứu của Sheta và cộng sự \cite{sheta2021osa}, tác giả đã sử
dụng bộ lọc notch IIR bậc hai nhằm loại bỏ nhiễu điện lưới 60~Hz khỏi
tín hiệu ECG — vốn là loại nhiễu phổ biến gây khó khăn cho việc phân
tích và trích xuất đặc trưng hình thái. Kết quả cho thấy tín hiệu sau
lọc cho chất lượng cao hơn đáng kể và cải thiện hiệu năng của các mô
hình học máy trong chẩn đoán OSA.
Các kỹ thuật lọc phổ biến bao gồm notch filter
(đặc biệt là IIR notch filter bậc hai) để loại bỏ nhiễu điện lưới,
bandpass filter để giữ lại dải tần sinh lý, và
các bộ lọc mượt như Butterworth bậc ba, median filter hoặc
moving average filter.
Đối với tín hiệu gia tốc, các bộ lọc cần đảm bảo vừa loại bỏ nhiễu vừa
bảo toàn các đặc trưng chuyển động. Trong đó, Kalman filter được sử dụng
rộng rãi để làm mượt chuỗi tín hiệu thời gian và giảm nhiễu ngẫu nhiên,
còn total variation filter được đánh giá cao trong việc bảo toàn biên
chuyển động rõ nét \cite{kalman, sun2017sleepmonitor}.
Việc lựa chọn bộ lọc phù hợp cần dựa trên đặc điểm của từng loại
tín hiệu và mục tiêu phân tích cụ thể.

\textbf{Nội suy}
là bước cần thiết để chuẩn hóa chuỗi thời gian. Các phương pháp như
cubic spline, piecewise cubic Hermite (PCHIP) hay linear interpolation
thường được áp dụng để điều chỉnh các chuỗi dữ liệu về cùng tần số chuẩn,
đảm bảo đầu vào đồng bộ cho mô hình học máy hoặc mạng nơ-ron.
Ngoài ra, đối với các chuỗi tín hiệu rời rạc như nhịp RR từ ECG
hoặc các chuỗi $\mathrm{SpO_2}$ có thể bị gián đoạn hoặc mất mẫu,
kỹ thuật nội suy còn đóng vai trò quan trọng trong việc làm đầy các
giá trị bị thiếu (missing/null values) và tái cấu trúc tín hiệu thành
chuỗi liên tục, giúp mô hình học được đặc trưng đầy đủ hơn từ
dữ liệu \cite{zou2024mbtcn}.
Trong nghiên cứu \cite{olsen2024transfer},
cả hai tín hiệu gia tốc (ACC) và xung quang học (PPG)
đều được nội suy để tạo thành chuỗi thời gian đồng nhất với
tần số lấy mẫu 32 Hz.
Đối với các tín hiệu có tần số cao hơn 32 Hz,
một bộ lọc thông thấp (lowpass filter) được áp dụng trước khi giảm
tần số (down-sampling) nhằm hạn chế hiện tượng aliasing.
Ngược lại, các tín hiệu có tần số lấy mẫu thấp hơn 32 Hz được
nội suy bằng phương pháp đa thức Hermite từng đoạn
(PCHIP – Piecewise Cubic Hermite Interpolation Polynomial)
để khớp với tần số mong muốn.

\textbf{Chuẩn hóa dữ liệu}  giúp đưa các đặc trưng đầu vào về cùng một miền giá trị,
tránh hiện tượng các đặc trưng có biên độ lớn chi phối quá trình học.
Một số phương pháp phổ biến bao gồm: Z-score normalization
(chuẩn hóa về trung bình 0 và độ lệch chuẩn 1),
min-max scaling (đưa về khoảng [0,1]), và robust scaling
(dựa trên trung vị và IQR, phù hợp với dữ liệu có nhiễu hoặc ngoại lệ).
Trong các nghiên cứu về OSA, chuẩn hóa đã được áp dụng cho nhiều
loại tín hiệu như $\mathrm{SpO_2}$, PPG và gia tốc, giúp tăng độ ổn định
mô hình và cải thiện tốc độ hội tụ khi huấn luyện mạng nơ-ron
\cite{Sleep_Posture_Detection, Vu2025SleepPosition, rossi2023sleep}.

\textbf{Phân đoạn tín hiệu} là một bước thiết yếu trong xử lý tín
hiệu sinh lý, đặc biệt trong các hệ thống theo dõi vị trí giấc ngủ và phát
hiện ngưng thở khi ngủ (OSA). Mục tiêu của bước này là chia chuỗi dữ
liệu liên tục thành các đoạn thời gian ngắn cố định (epoch),
giúp mô hình học máy nhận diện hiệu quả các đặc trưng biến đổi theo
thời gian. Thời lượng epoch thường phụ thuộc vào loại tín hiệu và
mục tiêu phân tích: 30 giây cho EEG, 60 giây cho ECG và $\mathrm{SpO_2}$,
5 phút cho HRV, hoặc các cửa sổ trượt ngắn để phát hiện sự kiện ngắn hạn.
Trong một số trường hợp, việc phân đoạn còn dựa vào các đặc điểm sinh lý
như đỉnh sóng R trong ECG. Sau khi phân đoạn, các bước tiền xử lý như lọc nhiễu,
chuẩn hóa hoặc làm mượt được áp dụng trong từng đoạn để nâng cao c
hất lượng dữ liệu đầu vào cho mô hình học máy
\cite{Sleep_Posture_Detection, Vu2025SleepPosition, HOANG2025116309, zou2024mbtcn, osa_sanchez2025}.

\textbf{Phân tích dữ liệu} là bước thống kê lại nhưng dữ liệu mình đã thu
thập bao gồm các yếu tố như: độ cân bằng, độ lặp, các giá trị null/NaN, hay các
thống kê khác theo yêu cầu bài toán

Tóm lại, phân tích dữ liệu không chỉ giúp nâng cao chất lượng dữ liệu mà còn
đảm bảo tính nhất quán đầu vào cho hệ thống học máy. Việc lựa chọn kỹ thuật
tiền xử lý cần phù hợp với đặc điểm của từng loại tín hiệu và mục tiêu phân
tích cụ thể.

\subsubsection{Trích xuất đặc trưng}
\textbf{Trích xuất đặc trưng} là một bước quan trọng nhằm biến đổi dữ liệu cảm biến
thô thành tập hợp các đặc trưng có ý nghĩa, phản ánh các mẫu hình sinh lý
liên quan đến mục đích của nghiên cứu. Quá trình này giúp làm nổi bật
những thông tin cốt lõi từ tín hiệu sinh học.

Đối với phân loại tư thế ngủ hoặc phát hiện hội chứng ngưng
thở khi ngủ (OSA) \cite{hstSurvey, HOANG2025116309, Channa_osa, Uday, Sang}, các đặc trưng thường được sử dụng bao gồm biến thiên
nhịp tim (HRV), khoảng RR, biên độ sóng R từ tín hiệu ECG; các chỉ số
thống kê, tần số và entropy từ tín hiệu $\mathrm{SpO_2}$; hoặc các đặc
trưng phi tuyến và miền tần số như năng lượng phổ, thông số Hjorth từ EEG.
Ngoài ra, các đặc trưng từ tín hiệu PPG và gia tốc như entropy, phương sai
hoặc số lượng chuyển động cũng đóng vai trò quan trọng trong việc phản ánh
mức độ rối loạn hô hấp trong giấc ngủ. Ngoài các đặc trưng truyền thống
trong miền thời gian và tần số, các đặc trưng hỗn hợp như biến đổi
wavelet đã chứng minh vai trò đặc biệt quan trọng trong việc mô tả
tín hiệu sinh lý một cách toàn diện hơn. Cụ thể, biến đổi wavelet
cho phép phân tích tín hiệu ở nhiều thang thời gian khác nhau, đồng thời
bảo toàn được cả thông tin về thời điểm và cấu trúc tần số của tín hiệu.
Điều này đặc biệt hữu ích trong bối cảnh tín hiệu sinh lý thường không
ổn định (non-stationary), như tín hiệu ECG, PPG hoặc tín hiệu gia tốc
trong quá trình theo dõi tư thế ngủ. Các hệ số wavelet thu được từ tín
hiệu gốc có thể phản ánh rõ ràng sự thay đổi chu kỳ hô hấp, chuyển động
cơ thể, cũng như các đặc điểm bất thường liên quan đến cơn ngưng thở khi
ngủ. Nhờ đó, việc trích xuất đặc trưng wavelet đóng góp quan trọng vào
hiệu suất của các mô hình phân loại tư thế ngủ và phát hiện OSA \cite{Sleep_Posture_Detection}.

\textbf{Gán nhãn (labeling)}
được thực hiện nhằm liên kết các phân đoạn tín hiệu với nhãn sự kiện
hô hấp tương ứng như “Apnea”, “Hypopnea”, hoặc phân mức độ nặng của OSA
như “Mild”, “Moderate”, “Severe”. Một số nghiên cứu còn mở rộng sang
các nhãn liên quan đến chất lượng tín hiệu (“Good” vs. “Poor”),
kiểu hô hấp (“Bình thường”, “Bất thường”), các nhãn liên quan đến tư thế ngủ.
Việc gán nhãn đúng đắn giúp huấn luyện mô hình
AI chính xác và đánh giá mức độ nghiêm trọng của OSA một cách hiệu quả.
Tùy theo thiết kế nghiên cứu, nhãn có thể được gán thủ công dựa trên
chuyên gia hoặc tự động đồng bộ với thiết bị tham chiếu như
camera, hệ thống PSG.

\subsubsection{Lựa chọn và huấn luyện mô hình}
Các kỹ thuật học máy và kiến trúc mạng nơ-ron nhân tạo đã được ứng dụng hiệu
quả trong các bài toán phân loại tư thế ngủ và chẩn đoán hội chứng ngưng thở
khi ngủ (OSA). Học máy (Machine Learning – ML) cung cấp một tập hợp đa dạng các
thuật toán cho phép khai thác mẫu hình từ dữ liệu cảm biến, hỗ trợ phát hiện
những thay đổi trong tư thế cơ thể và các rối loạn hô hấp liên quan đến giấc
ngủ. Trong khi đó, mạng nơ-ron nhân tạo (Artificial Neural Networks – ANN), đặc
biệt là các kiến trúc sâu như CNN, LSTM hoặc hybrid CNN-LSTM, thể hiện ưu thế
trong việc xử lý tín hiệu sinh lý phi tuyến, phức tạp, có độ biến thiên cao
theo thời gian như ECG, $\mathrm{SpO_2}$ hay tín hiệu gia tốc ba trục.

Trong số các \textbf{thuật toán học máy truyền thống} được sử dụng phổ biến,
Random Forest (RF) \cite{genuer2020random} nổi bật nhờ khả năng kháng chống lại
quá khớp và độ chính xác cao. Trong nghiên cứu \cite{wang2023ml_wearable}, Wang
và cộng sự đã ứng dụng RF để phân loại các trường hợp ngưng thở khi ngủ, đạt độ
chính xác 93.88\%, độ nhạy 89.93\% và độ đặc hiệu 91.8\%. Một nghiên cứu khác
\cite{yeo2022respiratory}, Yeo và cộng sự sử dụng RF cho nhiệm vụ phân loại sự
kiện hô hấp, thu được độ chính xác 83\%, độ nhạy 99\% và F1-score 81\%. Mặc dù
có sự khác biệt về nguồn dữ liệu và phương pháp trích chọn đặc trưng, RF vẫn
cho thấy hiệu quả vượt trội khi so sánh với các thuật toán khác như SVM, LDA
hay QDA \cite{wang2023ml_wearable}, \cite{yeo2022respiratory},
\cite{parbat2024multiscale}.

Bên cạnh đó, thuật toán SVM \cite{cortes1995svm} cũng đã được áp dụng nhằm xác
định siêu phẳng tối ưu để phân loại các nhóm trong không gian đặc trưng. Trong
nghiên cứu \cite{wang2023ml_wearable}, Wang cũng sử dụng thêm mô hình SVM và
đạt độ chính xác 88,28\%, độ đặc hiệu 91,69\% và độ nhạy 83,94\%, cho thấy hiệu
quả cao trong phát hiện ngưng thở khi ngủ, dù mô hình Random Forest thường có
kết quả cao hơn. Ở nghiên cứu \cite{yeo2022respiratory}, SVM đạt độ chính xác
83\% và hệ số Cohen’s kappa 0,53 trong phân loại sự kiện hô hấp theo từng phút.
Trong \cite{parbat2024multiscale}, SVM được huấn luyện trên tín hiệu ECG một
kênh, đạt độ chính xác 69,13\%, góp phần cải thiện hiệu suất của hệ thống phân
loại khi tích hợp trong mô hình tổ hợp. Những kết quả này cho thấy SVM vẫn là
một phương pháp có giá trị trong ứng dụng học máy cho chẩn đoán ngưng thở khi
ngủ.

K-Nearest Neighbors (KNN) \cite{cunningham2007knn} là một thuật toán khác cũng
thường xuyên được áp dụng trong các nghiên cứu về phát hiện ngưng thở khi ngủ
\cite{wang2023ml_wearable}, \cite{jeon2020realtime}. Dựa trên nguyên lý đo độ
tương đồng trong không gian đặc trưng, KNN phân loại một điểm dữ liệu mới dựa
trên nhãn của các điểm lân cận gần nhất. Wang và cộng sự đã dùng mô hình KNN xử
lý tín hiệu quang học PPG và đạt độ chính xác 85.06\%, với độ đặc hiệu 86.11\%
và độ nhạy 83.72\% \cite{wang2023ml_wearable}. Trong khi đó, nghiên cứu
\cite{jeon2020realtime} báo cáo hiệu quả vượt trội hơn với accuracy lên đến
95\%, đồng thời vẫn đảm bảo thời gian thực thi đáp ứng yêu cầu hệ thống. Thành
công này được cho là đến từ khả năng đo lường chính xác độ tương đồng giữa dữ
liệu quan sát và dữ liệu đã học, giúp mô hình KNN đưa ra dự đoán phù hợp với
mức độ nghiêm trọng của OSA.

Bên cạnh các thuật toán truyền thống, mô hình XGBoost \cite{chen2016xgboost}
cũng được đưa vào thử nghiệm trong nghiên cứu \cite{wang2023ml_wearable} nhằm
đánh giá khả năng phân loại các mức độ ngưng thở khi ngủ. Là một biến thể của
thuật toán boosting, XGBoost được thiết kế tối ưu cho hiệu suất tính toán và có
khả năng xử lý hiệu quả cả bài toán hồi quy và phân loại. Kết quả cho thấy
XGBoost đạt độ chính xác 82.05\%, độ đặc hiệu 84.91\% và độ nhạy 78.42\%, cho
thấy tiềm năng lớn của mô hình này trong ứng dụng lâm sàng, đặc biệt trong các
hệ thống đòi hỏi cân bằng giữa độ chính xác và tốc độ huấn luyện. Trong nghiên
cứu \cite{yeo2022respiratory}, thuật toán Linear Discriminant Analysis (LDA)
\cite{tharwat2017lda} được đánh giá là một phương pháp quan trọng. LDA sử dụng
trung bình và ma trận hiệp phương sai của từng lớp để xác định ranh giới quyết
định tối ưu, nhằm tối đa hóa sự phân biệt giữa các lớp và giảm thiểu phương sai
nội bộ. Trong bối cảnh nghiên cứu, LDA cho thấy hiệu quả vượt trội trong phát
hiện sự kiện hô hấp với độ chính xác 81\%, độ nhạy 88\%, độ đặc hiệu 79\% và
điểm F1 đạt 81\%.

\textbf{Học sâu (Deep learning - DL)}là một lĩnh vực thuộc học máy
tập trung vào việc khai thác các mạng nơ-ron nhân tạo nhiều lớp để
trích xuất đặc trưng và mô hình hóa dữ liệu phức tạp. Các mô hình học
sâu đã chứng minh hiệu quả trong việc phát hiện tư thế ngủ, đánh giá tình trạng OSA.
Học sâu cho phép phân tích các tín hiệu sinh lý không tuyến tính,
có nhiễu và mang tính thời gian, chẳng hạn như tín hiệu PPG, ECG,
SpO\textsubscript{2} và gia tốc kế.

Khác với các mô hình học máy truyền thống vốn đòi hỏi kỹ thuật trích xuất đặc
trưng thủ công, các mạng học sâu có khả năng tự động học các đặc trưng biểu
diễn từ dữ liệu đầu vào thô thông qua quá trình huấn luyện. Điều này đặc biệt
hữu ích trong phát hiện hội chứng ngưng thở khi ngủ (OSA – \textit{Obstructive
  Sleep Apnea}), nơi tín hiệu thu nhận từ thiết bị đeo thường biến thiên theo tư
thế, giai đoạn ngủ và tình trạng sinh lý của từng bệnh nhân.

Trong các ứng dụng chẩn đoán OSA, nhiều kiến trúc học sâu đã được đề xuất và
triển khai, bao gồm mạng nơ-ron tích chập (Convolutional Neural Networks –
CNN), mạng nơ-ron hồi tiếp (Recurrent Neural Networks – RNN) với các biến thể
như LSTM (Long Short-Term Memory) và GRU (Gated Recurrent Unit), mạng nơ-ron
truyền thẳng (Feedforward Neural Networks – FNN), và mạng perceptron đa tầng
(Multilayer Perceptron – MLP). Ngoài ra, các mô hình học chuyển tiếp (Transfer
Learning) sử dụng các kiến trúc sâu như ResNet và ResNeXt cũng được chứng minh
mang lại hiệu quả cao trong bối cảnh dữ liệu hạn chế \cite{osa_sanchez2025,
  wang2023ml_wearable, rossi2023sleep, olsen2024transfer}. Gần đây, các mô hình
kết hợp giữa học sâu và phương pháp phân cụm phân cấp (Hierarchical Deep
Clustering – HDC) cũng được áp dụng nhằm giảm chi phí tính toán và mở rộng khả
năng triển khai trên các thiết bị vi xử lý nhúng.

Trong \cite{rossi2023sleep}, Rossi và cộng sự đã phát triển một mô hình mạng
nơ-ron sâu (DNN) được phát triển để xử lý tín hiệu siêu âm thu từ cảm biến đeo
ngực, theo hướng kết hợp đa cảm biến. Mô hình được thiết kế cho bài toán phân
loại ba chiều: chất lượng tín hiệu, các mẫu hô hấp và các mẫu giấc ngủ. Mô hình
đạt độ chính xác 96\% trong phân biệt tín hiệu nhiễu và bình thường, với độ
chính xác cao hơn trong dự đoán mẫu hô hấp (0.93) so với mẫu giấc ngủ (0.76).
Trong \cite{olsen2024transfer}, một mạng nơ-ron tích chập sâu (CNN) được triển
khai nhằm phân loại các giai đoạn ngủ và phát hiện ngưng thở khi ngủ từ thiết
bị CST (consumer sleep technologies) đeo tay, sử dụng tín hiệu từ cảm biến gia
tốc và PPG. Mô hình gồm hai luồng xử lý riêng biệt, và kết quả cho thấy hiệu
suất được cải thiện khi sử dụng dữ liệu thô, đặc biệt trong phát hiện sự kiện
apnea trong giấc ngủ REM. Ji et al và cộng sự triển khai mô hình Long
Short-Term Memory (LSTM) – một dạng mạng nơ-ron hồi tiếp (RNN) – nhằm phân tích
chuỗi tín hiệu sinh lý phục vụ phát hiện hội chứng ngưng thở – giảm thở khi ngủ
(SAHS) \cite{ji2022airline}. Mô hình gồm ba lớp lặp LSTM kết hợp với bốn lớp
kết nối đầy đủ, có số nút lần lượt là 128, 64, 32 và 1. Kết quả cho thấy mô
hình đạt độ chính xác trung bình từ 84–85\%, khẳng định tính hiệu quả của kiến
trúc LSTM trong việc nhận dạng các đặc trưng liên quan từ dữ liệu tuần tự. Tổng
thể, các mô hình học sâu như CNN, LSTM và các biến thể kết hợp đã chứng minh
hiệu quả vượt trội trong việc phát hiện OSA từ các tín hiệu sinh lý đa dạng.
Tuy nhiên, thách thức về chi phí tính toán, dung lượng bộ nhớ và khả năng triển
khai thực tế trên thiết bị đeo yêu cầu các hướng nghiên cứu tối ưu hóa mô hình
và giảm độ phức tạp.

Tập trung vào mục tiêu phát hiện các hoạt động thường ngày và tư thế ngủ của
con người, rất nhiều nghiên cứu gần đây đã ứng dụng các phương pháp học máy và
trí tuệ nhân tạo để xây dựng hệ thống nhận dạng từ dữ liệu cảm biến đeo được.
\textit{Bảng \ref{tab:sleepml}} dưới đây tổng hợp một số nghiên cứu tiêu biểu
trong lĩnh vực này, bao gồm cả các mô hình học máy truyền thống (như cây quyết
định, KNN, SVM) và các phương pháp học sâu (CNN, LSTM). Các hệ thống được triển
khai với mục đích phân loại tư thế ngủ hoặc hoạt động thể chất, sử dụng nhiều
loại dữ liệu cảm biến khác nhau như gia tốc ba trục, tín hiệu quang học (PPG)
hoặc đặc trưng miền thời gian. Nhiều nghiên cứu cũng đã chú trọng đến việc
triển khai mô hình trên thiết bị nhúng (on-chip), nhằm hướng đến khả năng theo
dõi tại nhà trong thời gian thực với chi phí và mức tiêu thụ năng lượng thấp.

Sự phát triển nhanh chóng của trí tuệ nhân tạo (AI) trong lĩnh vực y học đã mở
ra nhiều hướng tiếp cận mới trong việc đánh giá tư thế ngủ và chẩn đoán OSA.
Các hệ thống AI đang dần chứng minh hiệu quả vượt trội trong việc xử lý dữ liệu
cảm biến lớn và phức tạp, từ đó cung cấp các phân tích chính xác về hành vi
giấc ngủ của bệnh nhân. Các mô hình học máy được huấn luyện trên tập dữ liệu
cảm biến từ accelerometer, gyroscope hoặc thiết bị đeo thông minh có thể tự
động phân loại các tư thế ngủ theo thời gian thực, với độ chính xác lên đến
trên 90\% trong nhiều nghiên cứu gần đây
\cite{Sleep_Posture_Detection}\cite{Vu2025SleepPosition}\cite{HOANG2025116309}.

\textbf{Tiny Machine Learning (TinyML)} là lĩnh vực nghiên cứu và ứng dụng các
mô hình học máy có kích thước nhỏ gọn, tiêu thụ năng lượng thấp,
được triển khai trực tiếp trên các thiết bị nhúng như vi điều khiển
(microcontrollers – MCU) hoặc thiết bị đeo (wearables) \cite{ray2021tinyml}.
Không giống như các mô hình học máy truyền thống thường yêu cầu nền
tảng phần cứng mạnh và tính toán trên cloud, TinyML cho phép xử lý dữ
liệu tại chỗ (on-device inference) mà không cần kết nối internet,
nhờ đó nâng cao tính riêng tư, độ phản hồi thời gian thực và khả năng
hoạt động ngoại tuyến.

\begin{table}[htbp]
  \centering
  \caption{Hiệu quả mô hình học máy và khả năng triển khai biên trong nhận diện tư thế ngủ}
  \label{tab:sleepml}
  \small
  \renewcommand{\arraystretch}{1.2}
  \resizebox{\textwidth}{!}{%
    \begin{tabular}{|c|p{2.2cm}|p{2.2cm}|p{2.7cm}|p{3.3cm}|c|c|p{1.2cm}|}
      \hline
      \textbf{Tài liệu}     & \textbf{Dữ liệu}      & \textbf{Nhiệm vụ}    & \textbf{Đặc trưng}            & \textbf{Mô hình}              & \textbf{Độ chính xác} & \textbf{Phần mềm} & \textbf{On-chip} \\
      \hline
      \cite{abdulsadig2023} & 18 đối tượng          & Tư thế ngủ           & 12 đặc trưng miền thời gian   & DT, Extra-Trees, LSTM-NN      & $>$98\%               & NM                & Có               \\
      \cite{Jeng}           & Không nêu             & Tư thế ngủ           & NM                            & RF, SVM                       & 85\%                  & Có                & Không            \\
      \cite{vu2023}         & 561.859 mẫu           & Tư thế ngủ           & NM                            & LSTM\_sq, CNN, MLP, LSTM\_con & $>$99\%               & Không             & Không            \\
      \cite{kwasnicki2018}  & 16 đối tượng          & Tư thế ngủ           & Trung bình, 3 trục            & Ngưỡng cố định                & 99.5\%                & Không             & Không            \\
      \cite{elnaggar2023}   & 5 đối tượng           & Tư thế ngủ           & NM                            & Ngưỡng cố định                & $>$99.2\%             & Không             & Không            \\
      \cite{gomes2021}      & 8 đối tượng           & Hoạt động người dùng & Trung bình, Độ lệch chuẩn (6) & KNN, RF, SVM                  & 97\%                  & Không             & Không            \\
      \cite{dao2022}        & Public + 20 private   & Hoạt động người dùng & 31 đặc trưng miền thời gian   & RF                            & 97\%                  & Có                & Không            \\
      \cite{souza2017}      & 10 đối tượng (public) & Hoạt động người dùng & 11 đặc trưng miền thời gian   & KNN, NB, SVM, CTree, RF       & 98\%                  & Không             & Không            \\
      \hline
      \multicolumn{8}{l}{\footnotesize NM = Không đề cập; DT = Decision Tree; CNN = Convolutional Neural Network; MLP = Multilayer Perceptron;}                                                           \\
      \multicolumn{8}{l}{\footnotesize LSTM = Long Short-Term Memory; RF = Random Forest; SVM = Support Vector Machine; NB = Naive Bayes; CTree = Conditional Inference Tree.}
    \end{tabular}
  }
\end{table}

Trong lĩnh vực chăm sóc sức khỏe, công nghệ \textbf{TinyML} (Tiny Machine
Learning) ngày càng được ứng dụng rộng rãi để phân tích các tín hiệu sinh lý
như nhịp tim, nhịp thở, chuyển động và tư thế ngủ. Với ưu điểm tiêu thụ năng
lượng thấp, chi phí triển khai rẻ và khả năng vận hành lâu dài trên phần cứng
hạn chế, các mô hình TinyML đặc biệt phù hợp cho các hệ thống theo dõi y tế tại
nhà, chẳng hạn như phát hiện hội chứng ngưng thở khi ngủ (OSA) bằng thiết bị
đeo không xâm lấn. Các thuật toán thường được sử dụng trong TinyML bao gồm các
biến thể nhẹ và được đơn giản hóa từ các mô hình học sâu như
\textit{Convolutional Neural Networks (CNN)}, \textit{Long Short-Term Memory
  (LSTM)}, cùng với các mô hình cây quyết định gọn nhẹ như \textit{Decision
  Tree}, \textit{Random Forest} hoặc \textit{Gradient Boosting}, vốn đã được tối
ưu hoá cho việc hoạt động trên nền tảng vi điều khiển có giới hạn tài nguyên
(MCU).

Dữ liệu trong Bảng~\ref{tab:sleepml} cho thấy sự đa dạng trong cách tiếp cận
bài toán nhận diện tư thế ngủ và hoạt động người dùng. Hầu hết các nghiên cứu
đạt độ chính xác cao (trên 95\%), ngay cả khi sử dụng các thuật toán đơn giản
như ngưỡng cố định hoặc mô hình học máy cổ điển như KNN, SVM và RF. Tuy nhiên,
một điểm đáng lưu ý là chỉ duy nhất nghiên cứu của Abdulsadig và cộng sự
\cite{abdulsadig2023} thực sự được triển khai trên phần cứng nhúng (on-chip),
chứng tỏ tính khả thi trong môi trường tài nguyên hạn chế. Các nghiên cứu còn
lại chủ yếu dừng ở mức mô phỏng phần mềm hoặc chạy trên máy tính hiệu năng cao,
chưa đáp ứng được yêu cầu triển khai thực tế trong các thiết bị đeo.

Đi sâu hơn, nhóm mô hình học sâu như CNN, LSTM hoặc kết hợp nhiều lớp
(LSTM\_sq, LSTM\_con, MLP) tuy đạt độ chính xác vượt trội (trên 99\%) như trong nghiên cứu của Vu et al. \cite{vu2023}, nhưng đều chưa tích hợp trực tiếp lên vi điều khiển do dung lượng bộ nhớ lớn và nhu cầu tính toán cao. Điều này đặt ra thách thức cho việc ứng dụng chúng trong môi trường thực tế như giấc ngủ tại nhà, nơi mà năng lượng, khả năng lưu trữ và kết nối đều bị hạn chế.

Ở chiều ngược lại, các mô hình đơn giản hơn như Decision Tree,
Random Forest hay ngưỡng cố định cho thấy hiệu quả không hề thua
kém khi được khai thác đúng đặc trưng.
Đặc biệt, việc sử dụng các đặc trưng miền thời gian
(mean, std, energy, entropy) — vốn dễ tính toán và
không cần FFT — giúp giảm đáng kể độ phức tạp tính toán.
Điều này rất phù hợp với triết lý thiết kế của TinyML:
đơn giản, hiệu quả và khả thi khi triển khai thực
tế trên các nền tảng hạn chế như MCU.

Một điểm sáng là khả năng cải thiện hiệu năng của mô hình bằng cách lựa chọn
đặc trưng phù hợp với tín hiệu đầu vào. Ví dụ, các đặc trưng trung bình và
phương sai theo trục trong các nghiên cứu \cite{gomes2021}, \cite{souza2017} đủ
mạnh để phân biệt các tư thế ngủ hoặc hoạt động cơ bản, mà không cần tới biểu
diễn phức tạp trong miền tần số hay wavelet.

Nhờ sự phát triển của các nền tảng hỗ trợ triển khai mô hình học máy như
\textbf{TensorFlow Lite for Microcontrollers}, \textbf{Edge Impulse}, và
\textbf{TinyML EON Compiler}, việc huấn luyện, chuyển đổi và triển khai các mô
hình chỉ yêu cầu vài kilobyte bộ nhớ đã trở nên khả thi. Điều này mở ra hướng
tiếp cận mới trong chẩn đoán y tế cá nhân hóa, thông qua thiết bị đeo thông
minh hoạt động liên tục tại nhà.

Một điểm mạnh nổi bật của các mô hình AI triển khai trên nền TinyML là khả năng
học và tự hiệu chỉnh theo dữ liệu thực tế. Nhờ vậy, hệ thống có thể phân biệt
hiệu quả giữa các tư thế ngủ cơ bản — nghiêng trái, nghiêng phải, nằm ngửa, và
nằm sấp — ngay cả khi có những sai lệch nhỏ về góc đặt thiết bị hoặc chuyển
động cơ thể không mong muốn. Hơn nữa, AI còn cho phép tích hợp dữ liệu tư thế
với các thông số sinh lý khác như nhịp tim, nhịp thở, độ bão hòa oxy máu
(SpO$_2$), và âm thanh để xây dựng mô hình chẩn đoán OSA đa chiều. Việc tổng
hợp đa nguồn tín hiệu này giúp hệ thống:
\begin{itemize}
  \item Phát hiện chính xác các giai đoạn ngưng thở và giảm thở (apnea/hypopnea),
  \item Phân tích tác động của từng tư thế ngủ đến mức độ hẹp đường thở,
  \item Ước lượng mức độ nghiêm trọng của OSA theo từng cá nhân.
\end{itemize}
Đây là một bước tiến quan trọng, hướng đến mục tiêu cá nhân hóa chẩn đoán và điều trị OSA – điều mà các phương pháp truyền thống như đa ký giấc ngủ (\textit{polysomnography – PSG}) còn nhiều hạn chế do chi phí cao, quy trình phức tạp và tính không đại diện cho điều kiện giấc ngủ tự nhiên.
Khi được triển khai trên các thiết bị đeo thông minh, hệ thống AI này cho phép theo dõi liên tục trong thời gian dài mà không gây xâm lấn hay ảnh hưởng đến chất lượng giấc ngủ của người dùng. Dữ liệu thu thập trong điều kiện sinh hoạt tự nhiên tại nhà có độ chính xác cao hơn, giúp nâng cao giá trị chẩn đoán và hỗ trợ quyết định điều trị chính xác hơn cho bác sĩ.

Cuối cùng, sự kết hợp giữa \textbf{AI}, \textbf{thiết bị đeo} và công nghệ
\textbf{điện toán biên (edge computing)} mang lại tiềm năng rất lớn cho các hệ
thống sàng lọc, chẩn đoán sớm và quản lý cá thể hóa OSA theo thời gian thực —
mở ra hướng phát triển bền vững cho y tế thông minh trong kỷ nguyên số.

Đây là một bước tiến quan trọng, hướng đến mục tiêu cá nhân hóa chẩn đoán và điều trị OSA – điều mà đa ký giấc ngủ (\textit{polysomnography – PSG}) truyền thống còn hạn chế do chi phí cao, quy trình phức tạp và tính không đại diện cho điều kiện ngủ tự nhiên. Khi được triển khai trên thiết bị đeo thông minh, hệ thống AI cho phép theo dõi liên tục, không xâm lấn trong bối cảnh sinh hoạt tại nhà, nhờ đó nâng cao độ tin cậy của dữ liệu và hỗ trợ quyết định điều trị chính xác hơn cho bác sĩ. Sự kết hợp giữa \textbf{AI}, \textbf{thiết bị đeo} và \textbf{điện toán biên (edge computing)} vì thế mở ra tiềm năng lớn cho sàng lọc, chẩn đoán sớm và quản lý OSA theo thời gian thực.

\noindent\textbf{Vì vậy, luận văn được tổ chức theo hai giai đoạn mạch lạc:}
(i) \emph{Đánh giá đặc trưng và mô hình trên dữ liệu thu thập} – xây dựng chuỗi xử lý từ tiền xử lý, phân đoạn theo cửa sổ, trích xuất đặc trưng đại diện (miền thời gian và tần số) đến so sánh các mô hình nhẹ (ngưỡng–hình học, LR, SVM, RF, NN nông). Tiêu chí lựa chọn không chỉ dựa trên độ chính xác/F1 vi mô–vĩ mô và ma trận nhầm lẫn cho từng tư thế, mà còn cân nhắc tính bền vững trước sai lệch gắn cảm biến, chi phí tính toán và khả năng co giãn khi giảm tần số lấy mẫu.
(ii) \emph{Triển khai on-chip (TinyML) trên vi điều khiển mục tiêu} – ánh xạ pipeline suy luận lên nền tảng Cortex-M4 với các tối ưu đặc thù phần cứng (quantization số nguyên, rút gọn đặc trưng, sử dụng FIFO/INT để giảm đánh thức CPU), bảo đảm ràng buộc bộ nhớ–độ trễ–năng lượng, đồng thời kiểm chứng sai lệch hiệu năng so với giai đoạn (i) ở mức chấp nhận được cho ứng dụng thực tế.

Cấu trúc hai giai đoạn này phản ánh lộ trình từ bằng chứng thuật toán trên dữ
liệu đến khả năng vận hành ngoài đời thực trên thiết bị đeo chi phí thấp, qua
đó hiện thực hóa mục tiêu cá thể hóa chẩn đoán và theo dõi OSA trong môi trường
tại nhà.

% \section{Cơ chế giả lập hành vi\label{mock_mechanism}} 
% % Từ khóa sử dụng: mock, mocking, mock data, HTTP Request, caller, callee, API method
% \input{chapters/examples/example_code_new}
% Quá trình thực thi kiểm thử cần được đảm bảo là độc lập và nhanh chóng \cite {clean_coder}. Để làm được điều này, chúng ta có thể áp dụng cơ chế giả lập hành vi cho một số hàm hoặc phương thức tương tác với thành phần bên ngoài như cơ sở dữ liệu, dịch vụ bên thứ ba, v.v. Cơ chế giả lập hành vi (\textit{\gls{mocking}}) được sử dụng để cài đặt các hàm hoặc phương thức với các hành vi mới. Thay vì truy cập các tài nguyên từ xa như trang Web hoặc cơ sở dữ liệu, các nhà phát triển hoặc người kiểm thử có thể thay thế hành vi mới của hàm/phương thức bằng cách sử dụng dữ liệu giả (\textit{\gls{mockdata}}). \Gls{mockdata} được cố ý chèn vào một phần trong mã nguồn. Nó thường được sử dụng như là kết quả của các phương thức hoặc hàm. Nó có nghĩa là những phương thức/hàm này được thay đổi hành vi để phù hợp với việc thực thi kiểm thử. Để đơn giản, thuật ngữ \textit {``\gls{mocked_method}"} dùng để chỉ một phương thức kết nối với các tài nguyên từ xa và phải được thay đổi hành vi. Sử dụng cơ chế \gls{mocking} có hai lợi ích chính là quá trình kiểm thử trở nên nhanh chóng và độc lập, điều này cần có trong các nguyên tắc FIRST \cite {clean_coder}. 

% Ưu điểm đầu tiên của việc sử dụng cơ chế \gls{mocking} là nhanh chóng. Kỹ thuật này làm giảm chi phí tính toán để thực thi dữ liệu thử nghiệm. Nếu không áp dụng cách thức này, việc kết nối với các tài nguyên từ xa có thể gặp phải một số sự cố do kết nối mạng kém hoặc không khả dụng. Thay vì đợi phản hồi từ các tài nguyên từ xa, các phương thức có thể trả về nhanh chóng \gls{mockdata}. Một lợi thế khác của việc sử dụng cơ chế \gls{mocking} là đảm bảo tính độc lập. Nó giúp duy trì tính nhất quán của cơ sở dữ liệu khi thực thi dữ liệu thử nghiệm nhiều lần. Khi một ứng dụng Web doanh nghiệp được triển khai, hầu hết các API có thể yêu cầu một số thay đổi tương tác với cơ sở dữ liệu. Tuy nhiên, trong môi trường thử nghiệm, việc thực thi thử nghiệm không được tác động đến cơ sở dữ liệu để duy trì tính nhất quán của dữ liệu gốc. Thay vì thực hiện hành vi thực tế, các phương thức có thể trả về \gls{mockdata} ngay lập tức. Do đó, việc thực thi thử nghiệm sẽ không bao giờ thực hiện bất kỳ cập nhật nào đối với cơ sở dữ liệu.

% Để làm rõ hơn cơ chế \gls{mocking} được sử dụng như thế nào trong thực tế, ví dụ trong Mã nguồn~\ref{api_example} và Mã nguồn~\ref{mock_example} thể hiện một trường hợp cần phải dùng tới cơ chế này. Ví dụ đầu tiên Mã nguồn~\ref{api_example} có API $``/search"$ lấy dữ liệu từ tài nguyên bên ngoài bằng cách gọi phương thức $get()$ (dòng \ref{lst_exp_start_uncover}). Bên cạnh đó, Mã nguồn~\ref{mock_example} trình bày một ca kiểm thử có sử dụng \gls{mocking} cho API $``/search"$  trong Mã nguồn~\ref{api_example}. 
% Để đơn giản hóa, nếu phương thức $m_1$ gọi phương thức $m_2$, $m_1$ và $m_2$ tương ứng được gọi là
% \textit{``caller"} và \textit{``callee"}.

% \input{chapters/examples/example_test_data}
% Thứ nhất, Mã nguồn~\ref{api_example} thể hiện một ví dụ cần phải sử dụng cơ chế \gls{mocking} khi thực thi kiểm thử. Ví dụ này có một phương thức chính ($searchMasterData()$) và hai phương thức phụ ($get()$ và $checkRequired()$). Chúng là những đại diện điển hình của mã nguồn dự án được sử dụng làm thực nghiệm trong Mục~\ref{experiment_section} Mỗi phương thức đều có những đặc điểm riêng biệt. Đầu tiên, phương thức chính ($searchMasterData()$) được đánh dấu với ký hiệu $@Post("search")$ cung cấp bởi thư viện NestJS (dòng \ref{declare_api_method}). Điều này có nghĩa là phương thức này tương ứng với một API. API này có thể được lựa chọn nằm trong môi trường kiểm thử. Phương thức này gọi tới hai phương thức khác: phương thức $get()$ để lấy kết quả phản hồi từ một cơ sở dữ liệu (dòng \ref{lst_exp_start_uncover}) và phương thức thứ hai $checkRequired()$ để kiểm tra lại tính hợp lệ của dữ liệu đầu vào (dòng \ref{lst_exp_check_require}). 
% Ngoài ra, phương thức đầu tiên ($get()$) kết nối với máy chủ cơ sở dữ liệu từ xa bằng cách sử dụng đối tượng $httpService$ với phương thức $post()$ để gửi POST Request (dòng \ref{call_http_service}). Phương thức này cần được thiết lập hành vi giả trong tệp kiểm thử. Liên quan đến vấn đề này, kiểu trả về của phương thức này có cấu trúc lớp $AxiousResponse$ bao gồm một số thuộc tính như là $data, headers,config, status$, và $statusText$ \footnote{https://github.com/axios/axios\#response-schema}. Những thuộc tính này cần được cung cấp trong \textit{mock data} để thỏa mãn yêu cầu về kiểu trả về của phương thức. Cuối cùng, phương thức $checkRequired()$ là một phương thức bình thường có nhiệm vụ là kiểm tra sự tồn tại của một thuộc tính đặc biệt trong đầu vào. Vì vậy, nó không cần thiết phải áp dụng cơ chế \gls{mocking} trong tệp thực thi kiểm thử.
% % The caller is an API that needs to be tested and it calls the callee which connects to a remote database.
% % As a result, the consistency of data could be impacted during test execution. Therefore, the actual implementation of this callee has to be replaced by using mock data

% Thứ hai, Mã nguồn~\ref{mock_example} trình bày ví dụ một tập lệnh cho một ca kiểm thử cho API $@Post("search")$ trong Mã nguồn~\ref{api_example}. Tập lệnh này có sử dụng cơ chế \gls{mocking} cho phương thức truy cập đến có sở dữ liệu  $get()$. Đây là ví dụ một khối lệnh viết bằng ngôn ngữ Typescript để xây dựng một ca kiểm thử cho một API trong ứng dụng NestJS. API được gọi với đầu là một HTTP Request có chứa dữ liệu kiểm thử ảnh hưởng đến luồng thực thi của chương trình. Khối lệnh này có cấu trúc bao gồm ba phần: Khai báo giá trị đầu vào (dòng \ref{input_declaration}), khai báo \textit{mock data}  (dòng \ref{mock_declare_response}-\ref{mock_spy}), và lời gọi API (dòng \ref{begin_test_driver}-\ref{end_test_driver}).
% Như đã đề cập ở trước đó, phương thức $get()$ kết nối tới máy chủ cơ sở dữ liệu và cần được thiết lập hành vi thay thế. Vì vậy, \textit{mock data} được cung cấp (dòng \ref{mock_declare_response}-\ref{mock_spy}). Ở khía cạnh đầu tiên, nếu cơ chế \gls{mocking} không được áp dụng, phương thức $get()$ sẽ gửi một POST Request tới máy chủ từ xa dẫn đến tốn thêm thời gian để đợi phản hồi. Thêm vào đó, nếu máy chủ đang không khả dụng, giá trị thuộc tính $status$ của biến $ret$ trong Mã nguồn~\ref{api_example} luôn luôn khác $200$. Điều này có nghĩa là biểu thức điều kiện $ret.status == 200$ luôn luôn nhận giá trị $false$ (dòng \ref{lst_exp_200} trong Mã nguồn~\ref{api_example}), khiến một số câu lệnh không thể được thực thi khi chạy kịch bản kiểm thử (dòng \ref{lst_exp_hidden_code},\ref{lst_exp_end_uncover} trong Mã nguồn~\ref{api_example}). 
% Ở khía cạnh khác, cơ chế \gls{mocking} cần được áp dụng để đảm bảo cơ sở dữ liệu không bị ảnh hưởng (dòng \ref{mock_spy}). \Gls{mockdata} của phương thức $get()$  là giá trị của biến $response$ bao gồm tất cả những thuộc tính cần thiết như là $data, headers,config, status$, và $statusText$ (dòng \ref{mock_declare_response}). Những giá trị này sẽ giúp chương trình thực thi nhiều câu lệnh hơn. 

% Trên thực tế, \gls{mockdata} thường được các nhà phát triển hoặc người thử nghiệm sửa đổi dựa trên kinh nghiệm của họ. Bởi vì luồng thực thi có thể phụ thuộc vào cách các phương thức được giả lập, \gls{mockdata} có thể ảnh hưởng đến phạm vi bao phủ. Do đó, các nhà phát triển hoặc người kiểm tra cần phải hiểu rõ ràng về mã nguồn để thiết lập \gls{mockdata} phù hợp nhằm đạt được độ phủ cao hơn.

% \section{Kiểm thử ứng dụng Web}
% Cách đơn giản nhất để kiểm thử một ứng dụng Web là kiểm thử viên sẽ thực hiện các thao tác nhấp chuột thủ công trên giao diện của hệ thống và đánh giá cách ứng dụng phản hồi. Đây là phương pháp kiểm thử hộp đen \cite{black_box_testing} vì kiểm thử viên không cần biết chi tiết nội hàm của chương trình ứng dụng. Họ chỉ cần quan tâm xem với một đầu vào cụ thể, ứng dụng có thực thi hành vi đúng như đặc tả hay không. Phương pháp kiểm thử này dễ dàng thực hiện được vì không cần bất cứ thiết lập nào trước đó. Tuy nhiên, nó có thể bị ảnh hưởng bởi những lỗi liên quan đến người thực hiện kiểm thử. Ngoài ra, quá trình này cũng tốn rất nhiều thời gian và công sức khi mà tổ hợp các kịch bản người dùng thực hiện trên giao diện là một con số rất lớn. Điều này trở nên thách thức hơn khi mã nguồn luôn luôn có sự thay đổi, quá trình kiểm thử hồi quy cần được thực hiện liên tục để kiểm tra lại các thành phần trước đó vẫn hoạt động đúng như ban đầu. Vì vậy, việc kiểm thử đầy đủ nếu chỉ dựa vào kiểm thử thủ công trên giao diện là không hiệu quả.

% Thay vì kiểm thử viên nhấp chuột thủ công để kiểm thử hệ thống, họ có thể viết các dữ liệu kiểm thử sử dụng trình điều khiển Web. Trình điều khiển Web thực hiện lần lượt các bước mô tả trong dữ liệu kiểm thử và kiểm tra hành vi của hệ thống. Quá trình thực thi các dữ liệu kiểm thử này có thể được tự động hóa cho nên nó có thể tiết kiệm thời gian cho kiểm thử viên ở giai đoạn thực thi hệ thống. Những dữ liệu kiểm thử có thể được tái sử dụng cho những lần kiểm thử hồi quy sau này. Tuy nhiên, về bản chất, việc xây dựng và viết mã lệnh cho các dữ liệu kiểm thử vẫn phải thực hiện thủ công. Đây là công việc rất tốn thời gian và nguồn nhân lực, đòi hỏi lập trình viên có kiến thức về trình điều khiển Web. Để kiểm thử đầy đủ cho một ứng dụng Web, số lượng dữ liệu kiểm thử là rất lớn. Vì vậy, trong thực tế, danh sách dữ liệu kiểm thử thường không đầy đủ dẫn đến một số lỗi tiềm ẩn trong chương trình không thể phát hiện và thường bị bỏ qua.

% Với những hạn chế như đã được để cập ở trên, việc sinh dữ liệu kiểm thử cần được tự động hóa sao cho đảm bảo tính hiệu quả để tiết kiệm thời gian và chi phí cho doanh nghiệp phát triển phần mềm. Đây cũng là một trong những mảng nghiên cứu khá là quan trọng, dành được nhiều sự quan tâm của các nhà nghiên cứu trong lĩnh vực công nghệ phần mềm. Việc kiểm thử cho ứng dụng Web hiện nay gặp phải một số thách thức \cite{web_testing_1, web_testing_2}. Hiện tại, quá trình nghiên cứu các phương pháp tự động hóa sinh dữ liệu kiểm thử cho ứng dụng Web cũng đã đạt được một số kết quả nhất định. Có thể kể đến một số dự án nổi bật như là Artemis\cite{artermis}, Crawljax \cite{crawljax}, và SymJS \cite{symjs}. Artemis là một công cụ hỗ trợ kiểm thử tự động cho ứng dụng Javascript, tập trung vào các ứng dụng đơn trang. Công cụ này sử dụng một số hằng số và giá trị ngẫu nhiên để sinh ra đầu vào cho dữ liệu kiểm thử. Tiếp theo, Crawljax là một công cụ thu thập thông tin và kiểm thử cho các ứng dụng Web Ajax. Nó có thể thực hiện trên ứng dụng Web có quy mô lớn nhưng chỉ sinh ra các giá trị ngẫu nhiên cho đầu vào. Cả hai công cụ này mặc dù có thể sinh dữ liệu kiểm thử tự động cho ứng dụng Web nhưng bộ dữ liệu kiểm thử không hiệu quả vì không phân tích sâu đến nội hàm các xử lý lô-gic của thành phần kiểm thử. Khác với hai công cụ trước đó, SymJS là công cụ có phân tích mã nguồn của thành phần kiểm thử trong ứng dụng, thu thập các toán tử có điều kiện và thực thi tượng trưng để sinh ra bộ các đầu vào đi qua các đường đi khác nhau trong chương trình. Tuy nhiên, hiện tại công cụ này mới chỉ hỗ trợ mã nguồn JavaScript phía người dùng. Có thể nói rằng SymJS đã bước đầu nghiên cứu các phương pháp kiểm thử hộp trắng cho các ứng dụng Web. Phương pháp kiểm thử hộp trắng từ lâu đã được ứng dụng để sinh tự động dữ liệu kiểm thử ở nhiều ngôn ngữ lâu đời như Java, C++, C\#, v.v. và đã đạt được một số kết quả khả quan. Bộ dữ liệu kiểm thử được sinh ra bởi phương pháp này có thể đạt độ phủ cao, thực thi qua nhiều thành phần có trong chương trình. Tuy nhiên, phương pháp này cũng vẫn tồn tại mộ số nhược điểm nhất định và chưa thể coi như là một giải pháp tổng thể cho tất cả các mã nguồn dự án phần mềm. Việc áp dụng phương pháp này như thế nào thì phải phụ thuộc vào bài toán cụ thể hoặc đặc trưng của mã nguồn được áp dụng. Thời điểm hiện tại vẫn chưa có nhiều nghiên cứu ứng dụng phương pháp kiểm thử hộp trắng cho ứng dụng Web.

% \section{Kiểm thử hộp trắng}
% Phương pháp được đề xuất trong luận văn này xây dựng dựa trên phương pháp kiểm thử dòng điều khiển. Đây là một trong những phương pháp kiểm thử hộp trắng đảm bảo tất cả các thành phần có trong mã nguồn đều được thực thi. Cụ thể, kiểm thử hộp trắng là phương pháp sinh dữ liệu kiểm thử dựa trên việc phân tích cấu trúc bên trong của mã nguồn \cite{software_testing, white_box_testing_2}. Nếu kiểm thử hộp đen cho phép phát hiện lỗi/khiếm khuyết có thể quan sát được thì kiểm thử hộp trắng có thể phát hiện những lỗi/khiếm khuyết tiềm ẩn bên trong chương trình/đơn vị phần mềm. Các lỗi này thường rất khó có thể phát hiện bằng kiểm thử hộp đen, tuy nhiên điều này không có nghĩa là kiểm thử hộp đen là không quan trọng. Mỗi phương pháp đều có những ưu nhược điểm và mục đích khác nhau, thường xuyên được sử dụng kết hợp với nhau trong quy trình kiểm thử nhằm đảm bảo phần mềm có chất lượng tốt nhất. Kiểm thử hộp trắng có các dữ liệu kiểm thử được sinh ra từ mã nguồn bằng các kỹ thuật phân tích phức tạp. Vì vậy, để có thể áp dụng được phương pháp này, các kỹ thuật viên không chỉ cần nắm rõ giải thuật mà còn cần có các kỹ năng và kiến thức tốt về ngôn ngữ lập trình, hiểu rõ được mã nguồn mới có thể đưa ra những cách giải quyết phù hợp. Do đó, việc áp dụng các phương pháp kiểm thử hộp trắng thường tốn nhiều thời gian và công sức, đặc biệt khi thành phần kiểm thử có kích thước lớn. Với lý do như vậy, các phương pháp kiểm thử hộp trắng thường được áp dụng trong pha kiểm thử đơn vị.

% Hai phương pháp được sử dụng trong kiểm thử hộp trắng là kiểm thử dòng điều khiển (Control Flow Testing - CFT) và kiểm thử dòng dữ liệu (Data Flow Testing - DFT) \cite{whitebox-testing}. Phương pháp kiểm thử dòng điều khiển tập trung kiểm thử tính đúng đắn của các giải thuật sử dụng trong thành phần cần kiểm thử. Phương pháp kiểm thử dòng dữ liệu quan tâm đến tính đúng đắn của việc sử dụng các biến dữ liệu trong thành phần kiểm thử. Luận văn này sử dụng phương pháp kiểm thử dòng điều khiển. Vì vậy, các kiến thức liên quan đến kiểm thử dòng điều khiển được trình bày chi tiết trong phần tiếp theo.
% % cần kiểm thử nhưng vẫn phát hiện được lỗi ngay từ giai đoạn đầu tiên trong quy trình phát triển phần mềm. Nhờ đó, các khiếm khuyết trong thiết kế và code được sửa chữa sớm, giảm thời gian và chi phí hoàn thiện sản phẩm. Đồng thời, hiệu suất phát triển cũng được nâng cao vì thiết kế được cải tiến, code có chất lượng tốt hơn, dễ bảo trì. Ngoài việc kiểm tra tài liệu (code reviews) và đánh giá cú pháp tự động, kiểm thử hộp trắng có thể được ứng dụng trong việc sinh dữ liệu kiểm thử thỏa mãn những tiêu chí đánh giá về độ phủ. Cụ thể trong phạm vi khóa luận này, phương pháp kiểm thử hộp trắng được áp dụng là xây dựng đồ thị luồng điều khiển đại diên cho cấu trúc chương trình và sử dụng tiêu chuẩn bao phủ nhánh của đồ thị để làm căn cứ đánh giá sự hiểu quả của giải pháp. 

% % % \section{Cây cú pháp trừu tượng}
% % % Cây cú pháp trừu tượng (Abstract Syntax Tree - AST) được sử dụng rộng rãi trong các trình biên dịch hoặc IDE. Với đầu vào là mã nguồn, các trình biên dịch/IDE này sẽ xây dựng AST tương ứng. AST là một cách biểu diễn cấu trúc mã nguồn dưới dạng cây. Mỗi một thành phần trong cây tương ứng với một thành phần mã nguồn như câu lệnh gán, khối lệnh điều kiện, biến, phép toán, v.v. Đối với một ngôn ngữ bất kỳ, AST
% % % Mỗi thành phần trong cây đều có các kiểu khác nhau được quy định bởi trình biên dịch. Ví dụ, trong CDT, kiểu IASTDeclSpecifier tương ứng với kiểu trả về của hàm hay kiểu biến. Kiểu IASTBinaryExpression tương ứng với dấu phép toán. Kiểu IASTName đại diện tên biến, tên hàm. IASTReturnStatement chính là câu lệnh return. 
% \section{Đồ thị dòng điều khiển}
% Như đã giới thiệu, phương pháp được sử dụng trong luận văn này là kiểm thử dựa trên dòng điều khiển. Tổng quan của phương pháp này là phân tích mã nguồn, xây dựng đồ thị dòng điều khiển và phân tích các biểu thức điều kiện có trong đồ thị đề sinh ra các giá trị hữu ích. Việc sinh dữ liệu kiểm thử dựa trên phân tích mã nguồn sẽ gặp rất nhiều khó khăn nếu chỉ thao tác với mã nguồn ở dạng văn bản đơn thuần. Vì vậy, chúng ta cần có một cấu trúc dữ liệu khác cũng có thể mô tả mã nguồn nhưng đơn giản để phân tích hơn. Đồ thị dòng điều khiển là một cấu trúc dữ liệu hỗ trợ giải quyết vấn đề này. Đồ thị dòng điều khiển (Control Flow Graph - \gls{CFG}) mô tả kịch bản thực thi của chương trình một cách trực quan, bao gồm các đỉnh là đại diện cho câu lệnh/nhóm câu lệnh và các cạnh là dòng điều khiển giữa các câu lệnh/nhóm câu lệnh đó \cite{CFG_definition}. Tất cả các đồ thị luồng điều khiển đều có đỉnh bắt đầu và đỉnh kết thúc đại diện cho trạng thái bắt đầu và trạng thái kết thúc của chương trình. Các cạnh là các mũi tên có hướng thể hiện thứ tự thực hiện của câu lệnh/nhóm câu lệnh. Cạnh nối hai đỉnh $i$ và $j$ theo hướng từ đỉnh $i$ đến đỉnh $j$ nghĩa là câu lệnh thứ $i$ được thực hiện trước câu lệnh thứ $j$.
% Về cơ bản, CFG bao gồm các thành phần chính là đỉnh bắt đầu, đỉnh xử lý, đỉnh quyết định, đỉnh kết nối và đỉnh kết thúc. 
% \begin{itemize}
%     \item Đỉnh bắt đầu: Đánh dấu thời điểm bắt đầu của chương trình, được thể hiện bằng hình tròn
%     \item Đỉnh xử lý: Đại diện cho các câu lệnh gán, khai báo và khởi tạo, được thể hiện bằng hình chữ nhật
%     \item Đỉnh quyết định: Đại diện cho câu lệnh điều khiển trong khối lệnh điều khiển rẽ nhánh, được thể hiện bằng hình thoi
%     % \item Đỉnh kết nối: Đại diện cho câu lệnh được thực hiện ngay sau các lệnh rẽ nhánh, có nhiều hơn hai đỉnh trỏ đến, được thể hiện bằng hình tròn
%     \item Đỉnh kết thúc: Đánh dấu thời điểm kết thúc của hàm, được thể hiện bằng hình tròn
% \end{itemize} 
% \begin{figure}[!ht]
% 		\centering
% % 		\setlength{\abovecaptionskip}{1pt plus 3pt minus 2pt}
%  		\includegraphics[width=\textwidth]{figures/cfg-control.pdf}
%  		\vspace*{-7mm}
% 		\caption{Các cấu trúc điều khiển phổ biến trong TypeScript}
% 		\label{cau-truc-dieu-khien}
% \end{figure}

% Hình~\ref{cau-truc-dieu-khien} mô tả các cấu trúc điều khiển chính có trong TypeScript được mô phỏng dưới dạng các đỉnh của CFG, bao gồm có cấu trúc điều khiển tuần tự, rẽ nhánh, vòng lặp \textit{for}, vòng lặp \textit{do…while}, vòng lặp \textit{ while…do}.

% \section{Các độ đo kiểm thử}
% Các độ đo kiểm thử thường được xác định là các quy tắc hoặc yêu cầu mà một tập hợp dữ liệu kiểm thử cần đáp ứng \cite{coverage_criteria}. Có một số độ đo phổ biến là bao phủ hàm (function coverage), bao phủ câu lệnh (statement coverage) và bao phủ nhánh (branch coverage). Bao phủ hàm là độ đo dễ đạt được nhất trong ba tiêu chí bao phủ này. Nó được đo bằng tỷ lệ phần trăm các hàm hoặc phương thức đã thực thi trên tổng số các hàm/phương thức có trong mã nguồn thử nghiệm. Bởi vì một hàm được thực thi có thể chứa các đoạn chưa được thực thi như các câu lệnh và các nhánh, một số lỗi bên trong một hàm có thể không được xem xét. Để giải quyết vấn đề này, quá trình kiểm tra phải được thực hiện với cả phạm vi bao phủ của câu lệnh và phạm vi bao phủ nhánh. Liên quan đến bao phủ câu lệnh, nó được biểu thị bằng tỷ lệ phần trăm các câu lệnh được thực thi trong tổng số các câu lệnh thuộc phạm vi kiểm thử. Nếu độ phủ câu lệnh đạt 100\%, thì bao phủ hàm/phương thức cũng đạt đến 100\%. Tuy nhiên, nó không thể xác nhận rằng tất cả các nhánh của điều kiện đều được thực thi. Vì vậy, độ phủ nhánh được đề xuất để đánh giá quá trình thử nghiệm một cách toàn diện hơn. Nó được đo bằng phần trăm các nhánh được thực thi trên tất cả các nhánh thuộc phạm vi kiểm thử. Nếu việc thực thi kiểm thử đạt được bao phủ nhánh tối đa, có thể đảm bảo rằng bao phủ câu lệnh và hàm cũng đạt đến giá trị lớn nhất. Vì vậy, bao phủ nhánh được sử dụng là độ đo cơ bản để đánh giá bộ dữ liệu kiểm thử.

% Công thức tổng quát để tính độ phủ theo các độ đo của $n$ tệp được trình bày trong Công thức \ref{coverage_equation}:
% \begin{equation} \label{coverage_equation}
% \begin{split}
%         e_c &= f(c, tested\ files) \\
%         &= \frac{\sum_{i=1}^n e_{i_c}}
%         {\sum_{i=1}^n t_{i_c}}*100 \\
%  \end{split}
% \end{equation}
% ,trong đó: $c$: loại độ đo bao phủ, bao gồm bao phủ hàm (\textit{function coverage}), bao phủ câu lệnh (\textit{statement coverage}), bao phủ nhánh (\textit{branch coverage})\\
% $e_{i_c}$: số lượng các thành phần được thực thi theo từng độ đo $c$ trong tệp thứ $i$. Thành phần được coi là các hàm, câu lệnh, và nhánh trong mã nguồn kiểm thử. \\
% $t_{i_c}$: số lượng tất cả các thành phần theo độ đo $c$ trong tệp thứ $i$

% Các tiêu chí bao phủ này được sử dụng để đánh giá hiệu quả của phương pháp được đề xuất trong việc tạo dữ liệu thử nghiệm. Nếu độ phủ tăng lên, nhiều thành phần trong mã nguồn được thực thi. Trong trường hợp các độ phủ không đạt 100 \%, các vấn đề sau có thể gặp phải. Thứ nhất, dữ liệu kiểm thử không thực thi toàn bộ các thành phần có trong mã nguồn. Do đó, có thể có một số lỗi tiềm ẩn không được phát hiện. Mặt khác, mã nguồn có thể chứa những câu lệnh không bao giờ có thể thực thi. Các nhà phát triển phải loại bỏ những đoạn mã này để tối ưu kích thước chương trình, tránh thực hiện các hành vi không đúng hoặc đơn giản hóa cấu trúc chương trình.

% % Trong kiểm thử hộp trắng nói chung và kiểm thử dòng điều khiển nói riêng, bài toán kiểm thử là sinh được bộ dữ liệu kiểm thử sao cho thỏa mãn các tiêu chuẩn cho trước. Các tiêu chuẩn này đã được thống nhất và định nghĩa bằng văn bản trong ISO \cite{iso_coverage}. Công thức tính toán độ đo theo các tiêu chuẩn này dựa trên mức độ bao phủ của chương trình với một tập dữ liệu kiểm thử cho trước. Tập dữ liệu kiểm thử có độ phủ cao sẽ đáng tin cậy hơn tập dữ liệu kiểm thử có độ phủ thấp. Mục tiêu là tập dữ liệu kiểm thử có số lượng tối thiểu nhưng đạt được độ phủ tối đa. Hiện nay, có nhiều tiêu chuẩn bao phủ khác nhau được sử dụng. Độ phủ của mỗi tiêu chuẩn đánh giá đều có công thức tính riêng nhưng về cơ bản sẽ được tính bằng tỉ lệ thành phần được kiểm thử trên tổng số các thành phần cần kiểm thử. Thành phần ở đây có thể là câu lệnh, nhánh chương trình, điểm quyết định, điều kiện con hoặc sự kết hợp giữa chúng. Độ đo này giúp các kỹ thuật viên kiểm soát và quản lý quá trình kiểm thử tốt hơn, có thể kiểm tra lại thành phần không được chạy qua hoặc bổ sung thêm dữ liệu kiểm thử trong trường hợp độ phủ thấp. Dưới đây là ba độ đo kiểm thử được sử dụng nhiều trong quy trình kiểm thử phần mềm \cite{Lee03}.
% % \begin{itemize}
% %     \item Độ phủ câu lệnh (statement coverage): mỗi câu lệnh được đi qua ít nhất một lần sau khi chạy bộ dữ liệu kiểm thử.
% %     \item Độ phủ nhánh (branch coverage): nhánh đúng và nhánh sai của mỗi đỉnh điều kiện có trong đồ thị dòng điều khiển được đi qua ít nhất một lần sau khi chạy bộ dữ liệu kiểm thử.
% %     \item Độ phủ điều kiện con (Modified Condition/Decision Coverage - MC/DC): các điều kiện con thuộc các đỉnh điều kiện phức tạp đều được thực hiện cả hai nhánh đúng và nhánh sai ít nhất một lần mỗi nhánh sau khi chạy bộ dữ liệu kiểm thử.
% % \end{itemize}

% % \section{Đường kiểm thử}
% % Bộ dữ liệu kiểm thử sinh ra dành cho một hàm bao gồm nhiều dữ liệu kiểm thử. Mỗi dữ liệu kiểm thử là một bộ giá trị đầu vào của tham số. Với một bộ giá trị đầu vào, chương trình của hàm sẽ chạy qua một số câu lệnh và dừng lại khi tới điểm kết thúc. Tập hợp các câu lệnh theo thứ tự thực hiện tạo thành một đường đi. Những đường đi được chọn để sinh dữ liệu kiểm thử  được gọi là đường kiểm thử. Để thống nhất khái niệm sử dụng trong suốt khóa luận, Định nghĩa 2.4 mô tả tổng quát một đường kiểm thử. Mỗi đường kiểm thử có thể bao gồm đầy đủ các câu lệnh khai báo, gán giá trị, khởi tạo và câu lệnh rẽ nhánh. Các đường đi khác nhau sẽ khác nhau ở số lượng, danh sách và thứ tự thực hiện các câu lệnh. Việc sinh dữ liệu kiểm thử tương ứng với đường kiểm thử chính là tìm kiếm bộ giá trị đầu vào sao cho khi thực thi, các nút điều kiện của đường đi đều được thỏa mãn. Trong thực tế, số lượng đường đi của chương trình có thể rất lớn dẫn đến việc sinh bộ dữ liệu kiểm thử cho tất cả các đường đi là không thể. Vì vậy, một số đường đi được chọn để sinh dữ liệu kiểm thử nhằm đáp ứng tiêu chí về độ phủ được gọi là tập đường kiểm thử.\\
% % \textbf{Định nghĩa 2.1}: Đường kiểm thử là một đường đi từ điểm bắt đầu đến điểm kết thúc của CFG, được biểu diễn bằng tập hợp các đỉnh từ $v_1$  đến $v_n$ sao cho cứ hai đỉnh cạnh nhau thì có cạnh nối theo hướng từ trái qua phải. Nếu cạnh ($v_i$, $v_j$) là nhánh sai thì biểu thức điều kiện tại đỉnh $v_i$ được viết dưới dạng phủ định $!v_i$.

% % Để có thể sinh được bộ dữ liệu kiểm thử thỏa mãn yêu cầu về tiêu chuẩn bao phủ, việc lựa chọn tập kiểm thử là một công đoạn không thể thiếu. Tuy nhiên, có hai vấn đề chúng ta cần phải đối mặt:
% % \vspace{-0.5cm}
% % \begin{itemize}
% %     \item Tính khả thi của đường đi: Một đường kiểm thử gọi là có khả khi nếu tồn tại một dữ liệu kiểm thử sao cho khi thực thi trong môi trường thật, tất cả các đỉnh của đường đi được duyệt qua. Ngược lại, đường kiểm thử gọi là không khả thi.
% %     \item 	Sự bùng nổ đường đi: với một hàm có kích thước lớn, nhiều vòng lặp hoặc các lệnh rẽ nhánh phức tạp, số lượng đường đi của chương trình có thể rất lớn. Việc sinh dữ liệu kiểm thử cho tất cả các đường đi để chắc chắn đạt độ phủ 100\% là không thể.
% % \end{itemize}
% % Mục tiêu của khóa luận này là xây dựng công cụ đầu tiên hỗ trợ sinh dữ liệu kiểm thử cho TypeScript, bắt đầu thử nghiệm với các hàm TypeScript kích thước vừa phải. Vì vậy, tập đường kiểm thử được lựa chọn là tập các đường đi có thể có của chương trình. Trong trường hợp tất cả các đường đi đều khả thi, độ bao phủ nhánh có thể đạt được là 100\%.

% % \section{Thư viện sử dụng}

% % \subsection{Thư viện phân tích mã nguồn TypeScript ``ts-morph''}
% % Phương pháp sinh dữ liệu kiểm thử tự động được đề xuất trong khóa luận này dựa trên việc thao tác với CFG của hàm. Việc xây dựng CFG như thế nào sẽ tùy biến theo từng tình huống bài toán. Đặc biệt đối với một ngôn ngữ mới như TypeScript, hiện tại không có thư viện nào có thể hỗ trợ giải quyết tác vụ này. Vì vậy, quá trình này được thực hiện thủ công dựa trên kỹ thuật phân tích mã nguồn và thiết kế cấu trúc dữ liệu mô hình hóa sao cho phù hợp với bài toán kiểm thử hiện tại. Phân tích mã nguồn thành cây cú pháp trừu tượng (Abstract Syntax Tree - AST) giúp việc xây dựng CFG trở nên đơn giản hơn. AST là một cây đại diện cho cấu trúc cú pháp trừu tượng của mã nguồn. Ngôn ngữ lập trình khác nhau có AST khác nhau.  Mỗi nút của cây biểu thị một cấu trúc có trong mã nguồn. AST thường được xây dựng bởi chính trình phân tích cú pháp của ngôn ngữ tương ứng trong quá trình biên dịch. Đối với các ngôn ngữ lâu đời, việc này có thể được thực hiện bởi một số thư viện khác. Do TypeScript là một ngôn ngữ mới nên chưa có công cụ nào hỗ trợ phân tích mã nguồn thành AST. Vì vậy, khóa luận này sử dụng chính trình biên dịch ngôn ngữ TypeScript của Microsoft để phân tích nội dung hàm. ``ts-morph''\footnote{\url{https://github.com/dsherret/ts-morph}} là một thư viện mở rộng từ trình biên dịch TypeScript, cung cấp các giao diện lập trình ứng dụng (Application Programming Interface - API) hỗ trợ người dùng có một cách dễ dàng hơn để điều hướng chương trình và thao tác với mã TypeScript.
% % Với sự hỗ trợ của ``ts-morph'', người sử dụng có đầy đủ các API để trích xuất thông tin cần thiết từ mã nguồn.  Các khối lệnh của thân hàm và các biểu thức  điều kiện đều có thể dễ dàng có được thông qua việc duyệt các đỉnh, hay gọi là $node$ của AST. Ngoài ra, thư viện cung cấp giao diện\footnote{\url{https://TypeScript-ast-viewer.com/}} để người dùng có thể theo dõi kết quả dưới dạng hình cây rất trực quan và dễ nhìn. Từ đó, việc thao tác với AST trở nên dễ dàng hơn.

% % %  Đối với TypeScript, các cấu trúc này có thể là lớp, hàm, thuộc tính, tham số, câu lệnh, v.v.

% % \subsection{Bộ giải hệ ràng buộc Z3}
% % Công cụ sinh dữ liệu kiểm thử cho mỗi đường kiểm thử bằng cách giải hệ ràng buộc ứng với tập các đỉnh điều kiện. Giải hệ ràng buộc nghĩa là quá trình tìm ra giải pháp cho một tập hợp các ràng buộc áp đặt bởi các phép toán điều kiện mà các biến phải thỏa mãn \cite{ref-constraints}. Do đó, một giải pháp là một tập hợp các giá trị cho các biến thỏa mãn tất cả các ràng buộc, đó là một điểm trong vùng khả thi.
% % Hiện nay, có nhiều thư viện, công cụ hỗ trợ việc giải hệ trong đó nổi bật là bộ giải Z3. Bộ giải Z3 được xây dựng chủ yếu bằng ngôn ngữ C++. Các ràng buộc cần được chuyển sang dạng chuẩn của Z3 để công cụ có thể tính toán và giải nghiệm. Z3 có thể giải hệ ràng buộc của các số nguyên, số thực, mảng và hàm tượng trưng. Đặc biệt trong phiên bản 4.8, bộ giải Z3 hỗ trợ giải một số ràng buộc liên quan đến chuỗi (string) \cite{z3_str_paper}. Điều này giúp việc tìm kiếm dữ liệu kiểm thử có tham số đầu vào kiểu chuỗi trở nên đơn giản hơn. Để có thể sử dụng Z3 giải nghiệm, bộ ràng buộc được lưu trong tệp và khởi chạy tiến trình bằng dòng lệnh:
% % \vspace{0.5cm}
% % \begin{lstlisting}
% % z3 -smt2 <file name>.smt2
% % \end{lstlisting}
% % Mã nguồn~\ref{constraints-file-example} là ví dụ một tệp constraints.smt2 hợp lệ làm đầu vào cho bộ giải Z3. Trong tệp, các biến sử dụng cần được khai báo bằng cú pháp \textit{declare-fun}. Sau đó, lệnh \textit{assert} được sử dụng để thêm các ràng buộc của hệ. Để kiểm tra hệ ràng buộc có nghiệm hay không, lệnh \textit{check-sat} được gọi. Kết quả trả về là \textit{sat} nếu có nghiệm và \textit{unsat} trong trường hợp không có nghiệm. Tập các giá trị của các biến thỏa mãn hệ ràng buộc được hiển thị bằng lệnh \textit{get-model}. Trong ví dụ này, hệ ràng buộc sử dụng ba biến tham số đầu vào là tvw\_s,  tvw\_a, tvw\_b và có ba ràng buộc được thêm vào câu lệnh \textit{assert} trong tệp \textit{constraints.smt2}. Mã nguồn~\ref{z3-result-example} là kết quả tương ứng sau khi giải hệ. Trong đó, các giá trị của các biến tìm được là  tvw\_a = 12,  tvw\_b = 11,  tvw\_s = "\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00". Như vậy, bộ giá trị (a, b, s) = \{12, 11, "\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00\textbackslash x00"\} là một nghiệm của hệ ràng buộc.
% % Nếu áp dụng với một đường kiểm thử cụ thể, các biến được khai báo trong hệ ràng buộc là các biến gọi đến trong các câu lệnh. Các đỉnh điều kiện sẽ được biểu diễn qua những biến này và chuẩn hóa thành những ràng buộc của hệ. Kết quả giải hệ là một dữ liệu kiểm thử thỏa mãn đường đi tương ứng. Trong trường hợp hệ ràng buộc của tất cả các đường đi đều giải được bỏi bộ giải Z3, tập các dữ liệu kiểm thử thu được phủ 100\% đường đi của CFG.

% % \vspace{0.5cm}
% % \begin{lstlisting}[caption=Ví dụ nội dung tệp đầu vào cho bộ giải Z3, label=constraints-file-example,captionpos=b]
% % (set-option :timeout 5000)
% % (declare-fun tvw_s () String)
% % (declare-fun tvw_a () Int)
% % (declare-fun tvw_b () Int)
% % (assert (> a b))
% % (assert (> b 10))
% % (assert (not (> (+ (str.len tvw_s) 1) 10)))
% % (check-sat)
% % (get-model)
% % \end{lstlisting}

% % \begin{lstlisting}[caption=Ví dụ kết quả giải hệ của Z3, label=z3-result-example, captionpos=b]
% % sat
% % (model
% %   (define-fun tvw_s () String
% %     "\x00\x00\x00\x00\x00")
% %   (define-fun tvw_b () Int
% %     11)
% %   (define-fun tvw_a () Int
% %     12)
% % )

% % \end{lstlisting}

% % \subsection{Mocha và Istanbul}
% % Để kiểm tra độ phủ đạt được với bộ dữ liệu kiểm thử đã được sinh tự động, công cụ có sử dụng Mocha trong việc thực thi mã nguồn. Mocha (Mocha Test Framework) là một bộ công cụ hỗ trợ kiểm thử dành cho JavaScript giàu tính năng chạy trên Nodejs và trong trình duyệt, giúp cho việc kiểm tra bất đồng bộ trở nên đơn giản và thú vị \cite{ref-mocha}. Các quy trình thực thi kiểm thử thực hiện bởi Mocha chạy ổn định, cho phép báo cáo linh hoạt và chính xác. Mocha có thể áp dụng với TypeScript thông qua một số bước cài đặt kỹ thuật. Ngoài ra,  Mocha cũng có thể kết hợp với một số thư viện để xuất báo cáo kiểm tra độ phủ (test coverage report). Ngoài việc cung cấp chức năng chạy kiểm thử với thao tác bằng tay, Mocha còn kèm theo bộ API để vận hành các bài kiểm tra tự động. Mocha có rất nhiều tính năng tuyệt vời, trong đó có một số tính năng nổi bật được kể đến là:
% % \begin{itemize}
% %     \item Hỗ trợ bất đồng bộ đơn giản
% %     \item Cung cấp đa dạng báo cáo
% %     \item Có thể chạy trong trình duyệt
% %     \item Tương thích với nhiều thư viện xác nhận (assertion library) Javascript
% %     \item Tương thích với mô hình phát triển phần mềm định hướng hành vi (Behaviour Driven Development - BDD) và mô hình phát triển phần mềm định hướng kiểm thử (Test Driven Development - TDD)
% % \end{itemize}
% % Với sự hỗ trợ của Mocha, các tệp kiểm thử được thực thi một cách nhanh chóng. Kết quả chạy kiểm thử được thống kê trực quan với số lượng dữ liệu kiểm thử thành công hay thất bại kèm theo vị trí cụ thể. Từ đó kỹ thuật viên nhanh chóng xác định được dữ liệu kiểm thử bị sai và dễ dàng sửa chữa.

% % Mocha chỉ hỗ trợ quá trình thực thi tệp kiểm thử và thống kê kết quả số lượng dữ liệu kiểm thử thành công hay thất bại. Tuy nhiên, để có thể biết được thống kê độ phủ mà bộ dữ liệu kiểm thử đạt được, Mocha cần kết hợp thêm một số thư viện bên ngoài. trong đó, được sử dụng nhiều nhất phải kể đến thư viện Istanbul \cite{ref-instanbul}. Đây là thư viện hỗ trợ sinh báo cáo độ phủ của quá trình kiểm thử đơn vị với nhiều định dạng khác nhau như HTML, XML, terminal output, JSON, v.v. Người dùng có thể lựa chọn kiểu báo cáo phù hợp với nhu cầu. Công cụ được phát triển trong khóa luận sử dụng báo cáo thể hiện dưới dạng HTML, bao gồm các thông tin về các độ phủ như số lượng hàm, câu lệnh, nhánh được thực thi. Đồng thời, báo cáo cũng nổi bật các đoạn mã không được chạy qua. Từ đó, kỹ thuật viên có thể phát hiện ra  được các đoạn mã không bao giờ được chạy để làm sạch mã nguồn hoặc bổ sung thêm dữ liệu kiểm thử mới để bộ dữ liệu kiểm thử hoàn thiện hơn.