
\section{Nghiên cứu, phát triển phần cứng \label{section_overview_propsed_method}}

Trong phần này, tác giả sẽ trình bày các nội dung bao gồm: nghiên cứu, lựa chọn
vi điều khiển và cảm biến phù hợp; từ đó tiến hành thiết kế sơ đồ nguyên lý, mô
phỏng mạch 3D và hoàn thiện sản phẩm.

\subsection{Vi xử lý}
\label{subsec:vi_xu_ly}

Với sự phát triển vượt bậc và đa dạng của công nghệ thiết kế và chế tạo, có rất
nhiều cấu hình phần cứng được nhiều nhóm tác giả lựa chọn phù hợp với các mục
đích khác nhau. Trong đó, \cite{p_1} các tác giả đã sử dụng máy tính đơn
Raspberry Pi để phát hiện 4 tư thế ngủ với sự lấy nhãn từ video theo dõi người
bệnh trong suốt quá trình lấy mẫu. Tác giả Kwasnicki và cộng sự đã sử dụng bộ
xử lý công suất thấp TI MSP430 và mô-đun RF Chipcon CC2420 cho truyền thông
không dây kết hợp với cảm biến gia tốc 3 trục ADXL330, con quay hồi chuyển đạt
được 99.5\% độ chính xác \cite{kwasnicki2018}. Nhóm của tác giả I.Yun đã phát
triển thiết bị theo dõi tư thế ngủ của trẻ nhỏ sử dụng vi xử lý ATmega328P-PU
kết hợp cảm biến gia tốc ADXL335 được đặt trên bụng \cite{p_3}. Trong nghiên
cứu của Abdulsadig và cộng sự, hệ thống thu thập dữ liệu được xây dựng dựa trên
một bo mạch tùy chỉnh tích hợp vi điều khiển nRF5232 ( tích hợp Bluetooth Low
Energy (BLE). Vi điều khiển này đảm nhiệm đồng thời cả việc lấy mẫu dữ liệu từ
cảm biến gia tốc ba trục LIS2DH12 với tần số 100 Hz và truyền dữ liệu không dây
theo thời gian thực \cite{Sleep_Posture_Detection, abdulsadig2023}. Trong
nghiên cứu của tác giả Vũ Hoàng Diệu , mô-đun ESP32 được lựa chọn làm đơn vị xử
lý trung tâm nhờ tích hợp bộ vi điều khiển hiệu năng cao, kết nối không dây
Wi-Fi và khả năng mở rộng linh hoạt \cite{vu2023}. Với thiết kế nhỏ gọn, chi
phí hợp lý và mức tiêu thụ điện năng thấp, ESP32 đáp ứng tốt yêu cầu của hệ
thống thu thập dữ liệu tư thế ngủ theo thời gian thực. Thiết bị không chỉ cho
phép truyền dữ liệu trực tiếp lên máy chủ hoặc nền tảng đám mây thông qua
Wi-Fi, mà còn hỗ trợ lưu trữ cục bộ trên thẻ nhớ microSD, đảm bảo tính liên tục
trong điều kiện mất kết nối mạng.

Qua phân tích các nghiên cứu trên có thể thấy rằng phần lớn các cấu hình phần
cứng có kích thước vẫn còn lớn (> 5cm), hoặc gặp giới hạn trong khả năng tích
hợp mô hình học máy tại thiết bị. Do đó, sau khi nghiên cứu, tác giả quyết định
lựa chọn vi điều khiển nRF52840 làm bộ điều khiển trung tâm \cite{nrf52840} với
các lý do sau:

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/NRF52840-QFA_SPL.jpg}
    \caption{Nordic NRF52840}
    \label{Nordic}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{images/nrf52840_feature.png}
    \caption{Các tính năng Nordic nRF52840}
    \label{Nornrf52840_featuredic}
\end{figure}

nRF52840 tích hợp bộ giao thức không dây Bluetooth năng lượng thấp hoạt động ở
băng tần 2.4 GHz và bộ xử lý trung tâm Arm Cortex-M4F chạy ở xung nhịp 64 MHz,
kèm bộ xử lý dấu phẩy động (FPU). Vi xử lý này được trang bị bộ nhớ 1 MB Flash
và 256 KB RAM phù hợp để triển khai các mô hình cho bài toán phân loại tư thế
ngủ. Ngoài khả năng hoạt động trong dải điện áp rộng từ +1.7 V đến +5.5 V
(tương thích với nguồn pin và USB), nRF52840 còn cung cấp các giao tiếp ngoại
vi phong phú: hai giao diện I2C, bốn SPI chủ (master), ba SPI tớ (slave), bốn
kênh điều chế xung (PWM) hỗ trợ EasyDMA, cùng với bộ định thời 32-bit, phù hợp
cho các ứng dụng đòi hỏi xử lý thời gian thực chính xác.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{images/nrf52840_schematic.png}
    \caption{Sơ đồ khối Nordic NRF52840}
    \label{nrf52840_schematic}
\end{figure}

Đặc biệt, nRF52840 có
một hệ sinh thái phần mềm đi kèm, bao gồm bộ công cụ phát triển (SDK) của Nordic Semiconductor
và nền tảng TensorFlow Lite for Microcontrollers, giúp rút ngắn thời gian phát triển và triển khai hệ
thống TinyML trực tiếp lên chip \cite{Nordic2021_tinyml}.
Hiện nay, nRF52840 cũng tích hợp trong nhiều bộ kit phát triển thương mại,
như Adafruit Circuit Playground Bluefruit,
SparkFun Pro nRF52840 Mini,
Seeed Studio XIAO.
Các bộ kit này cung cấp tài nguyên phần cứng và thư viện mã nguồn mở,
hỗ trợ kết nối BLE, USB, GPIO, SPI, I²C, cùng khả năng lập trình trực
tiếp qua môi trường Arduino IDE, PlatformIO hoặc Zephyr RTOS.
Nhờ đó, nRF52840 càng trở nên phổ biến trong các nghiên cứu và dự án về IoT,
thiết bị đeo thông minh và học máy tại biên.

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[height=4cm]{images/Seeed.jpg}
        \caption*{(a) Seeed Studio XIAO
        }
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[height=4cm]{images/adafruit.jpg}
        \caption*{(b) Adafruit Circuit Playground Bluefruit}
    \end{minipage}
    \caption{Một số bộ kit phát triển dựa trên vi điều khiển Nordic nRF52840}
    \label{fig:nrf52840_devkits}
\end{figure}

% Kiến trúc ARM có nhiều dòng vi xử lý khác nhau, được phát triển và nâng cấp
% liên tục nhằm đáp ứng nhu cầu đa dạng trong lĩnh vực công nghệ nhúng. Trong đó,
% dòng Cortex-M thuộc kiến trúc ARMv7 đã trở thành nền tảng phổ biến cho các hệ
% thống nhúng sử dụng vi điều khiển nhờ vào hiệu suất cao, khả năng mở rộng và
% mức tiêu thụ năng lượng tối ưu. Dòng Cortex-M bao gồm nhiều phiên bản như
% Cortex-M0, Cortex-M0+, Cortex-M1, Cortex-M3, Cortex-M4 và Cortex-M7, mỗi phiên
% bản được thiết kế để phục vụ cho các mức độ yêu cầu hiệu năng khác nhau
% \cite{arm_cortex_m_comparison}. Các vi xử lý thuộc họ Cortex-M chủ yếu được ứng
% dụng trong các hệ thống nhúng thời gian thực, nơi yêu cầu sự cân bằng giữa hiệu
% suất xử lý, tiêu thụ năng lượng và chi phí. Một số vi xử lý ARM khác, không
% thuộc họ Cortex-M, được sử dụng trong các thiết bị hiệu suất cao như điện thoại
% thông minh và máy tính bảng, vốn yêu cầu cấu hình phần cứng mạnh hơn và khả
% năng xử lý đa tác vụ cao hơn. Theo tài liệu \cite{cortexM4}, vi xử lý Cortex-M4
% là một bộ xử lý 32-bit sử dụng kiến trúc tập lệnh rút gọn (RISC), được xây dựng
% theo kiến trúc Harvard, trong đó bus dữ liệu và bus lệnh được tách biệt nhằm
% tối ưu hiệu suất truy xuất bộ nhớ. Vi xử lý này hỗ trợ đầy đủ cả tập lệnh
% Thumb-1 (16-bit) và Thumb-2 (hỗn hợp 16/32-bit), mang lại sự linh hoạt trong mã
% hóa lệnh và tiết kiệm không gian bộ nhớ chương trình.

% Về hiệu năng, Cortex-M4 đạt từ 1,25 đến 1,95 DMIPS/MHz (Dhrystone Million
% Instructions Per Second per MHz), cho thấy khả năng xử lý hiệu quả trong các
% ứng dụng nhúng yêu cầu độ chính xác và độ phản hồi thời gian thực cao. Bên cạnh
% đó, vi xử lý hỗ trợ tối đa 240 tín hiệu ngắt, bao gồm cả ngắt không thể bị chặn
% (Non-Maskable Interrupts - NMI), cùng khả năng cấu hình từ 8 đến 256 mức ưu
% tiên ngắt, giúp hệ thống hoạt động ổn định trong môi trường có nhiều sự kiện
% cạnh tranh đồng thời. Ngoài ra, hiện nay ứng dụng trí tuệ nhân tạo (AI) tại
% thiết bị biên (Edge AI) đang ngày càng phổ biến, đặc biệt trong các lĩnh vực
% như nhà thông minh, thiết bị đeo, giám sát an ninh và công nghiệp 4.0. Với khả
% năng xử lý tín hiệu số (DSP) và hỗ trợ các mạng nơ-ron nhỏ gọn, các vi xử lý
% Cortex-M, đặc biệt là dòng Cortex-M4, đang được khai thác để triển khai các mô
% hình học sâu nhẹ (tinyML) ngay trên vi điều khiển
% \cite{electronics11162545}\cite{applicationCortexM4}.

% \begin{figure}[htbp]
%     \centering
%     \includegraphics[width=0.8\textwidth]{images/cortexM4.png}
%     \caption{Thành phần chính của vi điều khiển Cortex-M4}
%     \label{cortexM4}
% \end{figure}

% Kết nối bus được mô tả trong Hình~\ref{cortexM4} cho phép truyền dữ liệu đồng
% thời trên nhiều bus khác nhau, đồng thời cung cấp khả năng quản lý truyền dữ
% liệu hiệu quả, chẳng hạn như sử dụng bộ đệm ghi và điều khiển hướng bit hoạt
% động (bit-banding). Hệ thống cũng có thể bao gồm các cầu bus (bus bridges) nhằm
% kết nối nhiều loại bus vào một mạng duy nhất sử dụng chung không gian bộ nhớ.
% Ngoài ra, bộ xử lý được trang bị hệ thống hỗ trợ gỡ lỗi tích hợp, bao gồm khả
% năng kiểm soát gỡ lỗi, thiết lập điểm ngắt (breakpoint) chương trình và điểm
% theo dõi dữ liệu (watchpoint). Khi xảy ra sự kiện gỡ lỗi, hệ thống có thể tạm
% dừng trạng thái hoạt động của lõi xử lý để phục vụ việc phân tích và xử lý lỗi.

% Bên cạnh đó, kiến trúc Cortex-M4 tích hợp Bộ điều khiển ngắt vectored lồng nhau
% (Nested Vectored Interrupt Controller - NVIC) với khả năng hỗ trợ lên đến 240
% tín hiệu yêu cầu ngắt, bao gồm cả ngắt không chắn được (NMI). NVIC hỗ trợ xử lý
% ngắt lồng nhau một cách tự động bằng cách so sánh mức ưu tiên giữa các yêu cầu
% ngắt với mức ưu tiên hiện tại đang được xử lý.

% Đối với các ứng dụng yêu cầu tiết kiệm năng lượng, hệ thống còn được trang bị bộ đánh thức ngắt (Wake-up Interrupt Controller - WIC), cho phép đưa bộ vi điều khiển vào chế độ nghỉ bằng cách tắt hầu hết các thành phần không cần thiết, đồng thời duy trì khả năng đánh thức hệ thống khi phát hiện một yêu cầu ngắt. Ngoài ra, cơ chế bảo vệ bộ nhớ cũng được tích hợp nhằm đảm bảo an toàn cho hệ thống, ví dụ như chỉ cho phép truy cập đọc tại một số vùng bộ nhớ hoặc ngăn người dùng truy cập vào các vùng dữ liệu đặc quyền của hệ điều hành hoặc ứng dụng hệ thống.

\subsection{Cảm biến \label{section_overview_propsed_method}}
\label{subsec:cam_bien}

Trong quá trình ngủ, các chuyển động thân thể chủ yếu là chuyển động chậm, với
biên độ nhỏ và ít mang tính đột ngột \cite{Wang2018_slidingwindow}. Trong giai
đoạn ngủ REM, cơ thể gần như bất động. Do đó, việc ghi nhận chính xác các thay
đổi tư thế ngủ đòi hỏi cảm biến có độ nhạy cao. Như đã trình bày trong Chương
I, các cảm biến gia tốc MEMS sử dụng nguyên lý điện dung hiện đang được ứng
dụng rộng rãi trong giám sát tư thế và chuyển động khi ngủ nhờ vào đặc điểm nổi
bật là tần số lấy mẫu phù hợp và đặc biệt là độ nhạy cao với mọi loại chuyển
động.

Sau khi đã khảo sát, cảm biến gia tốc Bosch BMI270 được lựa chọn cho hệ thống
nhận diện tư thế ngủ với các lý do sau:

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.75\textwidth, keepaspectratio]{images/BMi270.png}
    \vspace*{-5mm}
    \caption{Bosch BMI270}
    \label{Bosch_BMI270}
\end{figure}

Thứ nhất, độ chính xác và dải đo linh hoạt: BMI270 tích hợp gia tốc kế ba trục
độ phân giải cao 16-bit với các dải đo linh hoạt ±2g, ±4g, ±8g và ±16g, cho
phép ghi nhận chính xác cả chuyển động chậm và biên độ nhỏ trong khi ngủ.

Thứ hai, mức tiêu thụ năng lượng thấp và khả năng hoạt động ổn định: cảm biến
tiêu thụ trung bình chỉ khoảng 685 µA khi hoạt động bình thường, đồng thời được
trang bị bộ quản lý năng lượng tích hợp hỗ trợ nhiều chế độ tiết kiệm điện khác
nhau. Điều này cho phép thiết bị hoạt động lâu dài trên nền tảng phần cứng công
suất thấp mà không ảnh hưởng đến hiệu năng đo.

Thứ ba, tốc độ lấy mẫu và thời gian đáp ứng nhanh: BMI270 hỗ trợ tốc độ lấy mẫu
(ODR) từ 0.7Hz đến 1.6 kHz cho gia tốc kế, phù hợp bài toán phân loại giấc ngủ
yêu cầu tần số lấy mẫu thấp ~ 10Hz.

Thứ tư, khả năng chống nhiễu và hiệu chuẩn tự động: cảm biến có cơ chế bù sai
số và bù độ nhạy theo thời gian thực, giúp giảm sai lệch khi hoạt động lâu dài.
Tính năng bù sai lệch cho gia tốc kế đảm bảo độ ổn định cao của dữ liệu đo.
Ngoài ra, cảm biến còn tích hợp thêm bộ lọc thông thấp.

Cuối cùng, tích hợp tính năng thông minh được lập trình trong các thanh ghi
riêng được Google chứng nhận tương thích với hệ điều hành Wear OS và hỗ trợ
phát hiện chuyển động tự động: BMI270 có khả năng phát hiện các trạng thái như
phát hiện có chuyển động (any motion), không có chuyển động (no motion) hoặc di
chuyển các thiết bị đeo ở cổ tay (wrist wear wakeup). Các tính năng này có thể
được tận dụng để giảm tải tính toán cho bộ vi điều khiển, chỉ kích hoạt mô hình
học máy khi có thay đổi tư thế đáng kể, qua đó tiết kiệm năng lượng và tăng
tuổi thọ pin

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.75\textwidth, keepaspectratio]{images/bmi270_block.png}
    \vspace*{-5mm}
    \caption{Sơ đồ khối Bosch BMI270}
    \label{bmi270_block}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\textwidth, keepaspectratio]{images/bmi270_pin.png}
    \vspace*{-5mm}
    \caption{Sơ đồ chân Bosch BMI270}
    \label{bmi270_pin}
\end{figure}

\subsection{Bluetooth năng lượng thấp}

Với mục tiêu tối ưu hóa năng lượng và đảm bảo khả năng hoạt động lâu dài cho
thiết bị đeo sử dụng pin, BLE được lựa chọn làm chuẩn kết nối không dây chính
trong hệ thống phần cứng. So với các giao thức khác, BLE tỏ ra vượt trội nhờ
mức tiêu thụ năng lượng rất thấp, tốc độ khởi tạo kết nối nhanh và khả năng
tương thích rộng rãi với hầu hết các thiết bị di động hiện nay
\cite{BLE_compare}.

Các công nghệ truyền thông không dây khác đều bộc lộ những hạn chế đối với
thiết bị phân loại tư thế ngủ. Wi-Fi, có ưu thế về băng thông, lại tiêu thụ
năng lượng cao và phụ thuộc vào internet. Bluetooth cổ điển, vốn được thiết kế
cho các ứng dụng truyền tải dữ liệu dung lượng lớn như âm thanh, cũng đòi hỏi
năng lượng cao hơn nhiều so với BLE. ZigBee, hiệu quả trong các mạng cảm biến
nhà thông minh nhờ cấu trúc lưới, lại thiếu sự hỗ trợ trên điện thoại và đòi
hỏi gateway riêng.

Ngoài ra, BLE còn được hỗ trợ trên vi điều khiển nRF52840 đã chọn ở phần trên.
Nhờ sự kết hợp này, hệ thống có thể duy trì khả năng truyền dữ liệu ổn định,
tiết kiệm năng lượng, và đáp ứng tốt yêu cầu hoạt động liên tục trong quá trình
giám sát tư thế ngủ.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ble.png}
    \caption{Các kiểu kết nối không dây trong họ chip nRF52}
    \label{ble}
\end{figure}

\subsubsection*{Các thành phần, chức năng}

BLE là giao thức kết nối không dây được thiết kế chuyên biệt cho các ứng dụng
năng lượng thấp, hoạt động ở băng tần ISM 2.4 GHz, hỗ trợ thông lượng ứng dụng
lên đến 1.4 Mbps \cite{BluetoothSIG2019_Core5}. BLE hiện được hỗ trợ phổ biến
trên hầu hết các hệ điều hành như iOS, Android, macOS, Windows và Linux, cũng
như trong các thiết bị di động hiện đại.

Về mặt bảo mật, BLE tích hợp các cơ chế mã hóa và xác thực nhằm đảm bảo tính bí
mật, toàn vẹn của dữ liệu. Bluetooth 5 là bước phát triển đột phá tiếp theo kể
từ khi BLE được giới thiệu trong chuẩn Bluetooth 4.0, mang đến hàng loạt cải
tiến đáng kể giúp mở rộng phạm vi ứng dụng và nâng cao hiệu suất hệ thống. Quan
trọng hơn, chế độ này còn giúp giảm đáng kể mức tiêu thụ năng lượng. Từ đó kéo
dài thời gian hoạt động của thiết bị hoặc cho phép sử dụng các nguồn năng lượng
nhỏ hơn \cite{BLE}. Đặc biệt, chế độ Long Range mở rộng đáng kể phạm vi truyền
thông của BLE, cho phép các thiết bị duy trì kết nối trong toàn bộ không gian
trong nhà.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/gatt.drawio.png}
    \caption{Cấu trúc của GATT}
    \label{gatt}
\end{figure}

BLE tổ chức logic giao tiếp dựa trên mô hình hồ sơ thuộc tính tổng quá (Generic
Attribute Profile - GATT). GATT quy định cách hai thiết bị BLE trao đổi dữ liệu
thông qua các đơn vị logic: dịch vụ (services) và đặc tính (characteristics).
Giao thức nền tảng là Attribute Protocol (ATT). Mỗi dịch vụ, đặc tính được định
danh bằng mã định danh duy nhất (UUID) 16-bit hoặc 128-bit, với quyền truy cập
như chỉ đọc, chỉ ghi, hoặc hỗ trợ thông báo.

Một điểm quan trọng trong mô hình GATT là tính kết nối độc quyền: tại một thời
điểm, thiết bị ngoại vi chỉ có thể duy trì một kết nối duy nhất với thiết bị
trung tâm. Khi kết nối được thiết lập, thiết bị ngừng quảng cáo, điều này hạn
chế khả năng kết nối đồng thời từ nhiều thiết bị.

Ngoài ra, vi xử lý nRF52840 còn hỗ trợ Bluetooth Mesh, cho phép thiết lập mạng
lưới nhiều nút. Mỗi nút trong mạng có thể đóng vai trò chuyển tiếp, cho phép dữ
liệu lan truyền đến các vùng rộng hơn theo mô hình phân tán. Điều này phù hợp
với các ứng dụng IoT quy mô đa cảm biến đặt tại nhiều nơi khác nhau.

\subsection{Thiết kế mạch nguyên lý}

Sau khi đã lựa chọn được vi điều khiển, cảm biến của hệ thống phần cứng phân
loại tư thế ngủ. Trong phần này, tác giả sẽ trình bày về thiết kế sơ đồ nguyên
lý cho mạch thông qua những câu hỏi: Các thành phần trong cần thiết để phục vụ
cho bài toán phân loại tư thế ngủ là gì? Chúng được kết nối với nhau như thế
nào? và chi tiết từng thành phần đó là gì?

Từ đó, tác giả từng bước nghiên cứu và hoàn thiện thiết kế sơ đồ nguyên lý.

\subsubsection*{Mục tiêu}

Bám sát vào yêu cầu đã trình bày từ các phần trước là phần cứng nhỏ gọn, tính
di dộng cao, tiêu thụ năng lượng ít, giá thành phù hợp tác giả đã nghiên cứu và
đưa ra hệ thống cần các thành phần sau: 01) Khối điều khiển: có chức năng xử lý
toàn bộ logic trong mạch, kết nối được với các thiết bị khác như điện thoại
thông qua BLE và đặc biệt, đủ hiệu năng để triển khai các mô hình học máy. 02)
Khối cảm biến: có nhiệm vụ thu thập dữ liệu sinh lý bao gồm 2 cảm biến chính là
gia tốc (đã được trình bày các phần trên) và thêm cảm biến âm thanh để phục vụ
bài toán xác định tiếng ngáy của nhóm. 03) Khối nguồn: có nhiệm vụ ổn áp về
đúng dải điện áp tương thích, lọc nhiễu, bảo vệ dòng 04) Khối nạp và gỡ lỗi: có
nhiệm vụ nạp mã chương trình vào vi điều khiển 05) Khối hiển thị: có nhiệm vụ
đưa ra thông báo khi có phát hiện bất thường. Kích thước của mạch là hình tròn,
có đường kính không quá 4cm. Đây chính là những mục tiêu điểm tiên quyết để coi
là đạt được mục tiêu trong phần này.

\subsubsection{Khối điều khiển}

Với yêu cầu quan trọng đối điều khiển thì vi điều khiển nRF52840 được chọn hoàn
toàn có thể đáp ứng các tiêu trí đã nêu trong phần~\ref{subsec:vi_xu_ly} để làm
vi điều khiển của mạch. Tuy nhiên để đáp ứng đủ các yêu cầu của khối điều khiển
thì vẫn đang thiếu các thành phần như khối thu phát tín hiệu vô tuyến bao gồm
ăng ten, mạch phối hợp trở khánh, bộ dao động tinh thể và bộ đếm định thời nhằm
duy trì hoạt động ổn định trong các chế độ năng lượng thấp.

Sau khi tìm hiểu, tác giả quyết định lựa chọn module U-blox NINA-B306 để đảm
nhiệm các nhiệm vụ của khối điều khiển \cite{uBlox2019_NINA_B3}.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{images/ninab306.png}
    \caption{U-blox NINA-B306}
    \label{ninab306}
\end{figure}

Mô-đun NINA-B306 được phát triển dựa trên vi điều khiển Nordic nRF52840, tích
hợp ăng-ten PCB nội bộ được cấp phép từ Abracon ngay trên bảng mạch của mô-đun.
Ngoài ra, NINA-B306 được thiết kế với dải điện áp hoạt động chuẩn hóa từ 1.7 V
đến 3.6 V, thấp hơn so với giới hạn tối đa 5.5 V của vi điều khiển nRF52840,
nhằm tối ưu hiệu suất năng lượng.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/ninab306_block.png}
    \caption{Sơ đồ khối U-blox NINA-B306}
    \label{ninab306_block}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/ninab306_pin.png}
    \caption{Sơ đồ chân U-blox NINA-B306}
    \label{ninab306_pin}
\end{figure}

\subsubsection{Khối cảm biến}
Như đã đề cập chi tiết ở phần~\ref{subsec:cam_bien}, cảm biến gia tốc Bosch
BMi270 được lựa chọn để thu thập tín hiệu gia tốc cho bài toán phân loại tư thế
ngủ.

Ngoài ra, việc hướng tới việc xác định chứng ngưng thở khi ngủ OSA thì nhóm có
bổ sung thêm cảm biến âm thanh STMicroelectronics MP34DT06J. Cảm biến MP34DT06J
là microphone MEMS kỹ thuật số định hướng đa hướng có kích thước siêu nhỏ gọn
và tiêu thụ năng lượng thấp. Ngoài ra MP34DT06J là cảm biến số có tỷ lệ tín
hiệu trên nhiễu (SNR) 64 dB và độ nhạy -26 dBFS ± 1 dB, đảm bảo chất lượng thu
âm ổn định. Thiết bị được đóng gói theo chuẩn SMD top-port, có che chắn EMI
(Electromagnetic Interference), và được đảm bảo hoạt động ổn định trong dải
nhiệt độ mở rộng từ –40 °C đến +85 °C và kèm thêm điện áp đầu vào 1.8V hoàn
toàn phù hợp với các thông số của vi điều khiển.

Tuy nhiên, trong khuôn khổ luận văn này tác giả không đề cập sâu vào cảm biến
này để tập trung tối đa vào dữ liệu cảm biến gia tốc cho bài toán phân loại tư
thế ngủ.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/mp34DT06J.png}
    \caption{STM MP34DT06J}
    \label{mp34DT06J}
\end{figure}

\subsubsection{Khối nguồn, nạp và gỡ lỗi, hiển thị}
Ba khối chức năng này được thiết kế nhằm đảm bảo sự ổn định và khả năng vận
hành tin cậy của toàn bộ hệ thống phần cứng.

Đối với khối nguồn, hệ thống được xác định có hai nguồn cung cấp chính
gồm nguồn từ cổng USB và nguồn từ pin Li-Polymer. Điện áp đầu vào của
toàn mạch được xác định ở mức 3.3 V để tương thích với các linh kiện và
vi điều khiển. Sau khi nghiên cứu, tác giả sử dụng bộ chuyển đổi hạ áp
(step-down converter) tích hợp mạch điều khiển MP2322GQH,
cho phép giảm điện áp đầu vào từ 5 V (USB) hoặc 3.7 V (pin Li-Polymer)
xuống mức ổn định 3.3 V với hiệu suất cao.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/MP2322GQH.png}
    \caption{Sơ đồ khối IC MP2322GQH, dải đầu vào 3V–22V, dòng tải tối đa 1A, hiệu suất cao, tần số chuyển mạch 1.25MHz (Monolithic Power Systems)}
    \label{fig:MP2322GQH}
\end{figure}

Bên cạnh đó, nguồn USB còn được bổ sung các thành phần hỗ trợ như diode bảo vệ
ngược dòng, tụ lọc nhiễu cao tần và bù tín hiệu, cùng điện trở xả tĩnh điện,
nhằm đảm bảo an toàn và giảm nhiễu điện từ trong quá trình vận hành.

Đối với khối hiển thị, hệ thống sử dụng bốn đèn LED khác màu bố trí tại rìa của mạch, có nhiệm vụ thông báo kết quả tư thế được phân loại, trạng thái hoạt động của hệ thống như nguồn, kết nối, truyền dữ liệu hoặc lỗi, giúp người dùng và kỹ sư dễ dàng theo dõi tình trạng thiết bị.

Với khối nạp và gỡ lỗi, tác giả triển khai hai phương thức nạp bao gồm: (1) Qua
Serial Wire Debug (SWD); (2) Cơ chế Bootloader thông qua kết nối USB. Sự kết
hợp này giúp nâng cao tính linh hoạt và khả năng mở rộng trong quá trình phát
triển phần mềm, đồng thời giảm thiểu thời gian thử nghiệm.

\subsubsection{Mạch nguyên lý}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/schematic.png}
    \caption{Sơ đồ nguyên lý}
    \label{fig:schematic}
\end{figure}

Sau khi xác định các linh kiện, các yêu cầu về điện áp, kiểu dữ liệu đầu vào,
đầu ra của các thành phần kể trên, tác giả tiến hành vẽ nguyên lý mạch thông
qua phần mềm Altium Designer.

Mạch được thiết kế hình tròn kích thước đường kính 3cm, 2 lớp đúng với định
hướng của nhóm.

Kết quả được thể hiện tại Hình~\ref{fig:schematic}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/pcd_dong_top.png}
        \label{fig:pcb_dong_top}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/pcb_dong_bottom.png}
        \label{fig:pcb_dong_bottom}
    \end{subfigure}
    \caption{Bố trí mạch in hai mặt của bo mạch: (a) lớp trên; (b) lớp dưới}
    \label{fig:pcb_dong}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/pcb_3d_top.png}
        \label{fig:pcb_3d_top}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/pcb_3d_bottom.png}
        \label{fig:pcb_3d_bottom}
    \end{subfigure}
    \caption{Mô hình mạch 3D: (a) lớp trên; (b) lớp dưới}
    \label{fig:pcb_3d}
\end{figure}

Sau khi hoàn thiện thiết kế, tác giả thực hiện đặt in mạch, hàn lắp các linh
kiện theo sơ đồ nguyên lý, và tiến hành kiểm tra hoạt động của các khối chức
năng trên bo mạch để đánh giá tính ổn định và độ tin cậy của hệ thống.

Hình~\ref{fig:mach} là kết quả mạch đã hoàn thiện.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/mach.png}
    \caption{Mạch hoàn chỉnh}
    \label{fig:mach}
\end{figure}

\newpage

\section{Hệ thống phần mềm}
Phần này trình bày tổng quan kiến trúc hệ thống phần mềm bao gồm: lập trình
phần cứng để đọc giá trị cảm biến, cấu hình BE ; phát triển ứng dụng di động
làm cầu nối giữa phần cứng và hệ thống đám mây, cùng với máy chủ và cơ sở dữ
liệu lưu trữ dữ liệu. Nội dung cũng đề cập đến các yêu cầu chức năng, phi chức
năng và thiết kế hệ thống ở mức cao nhằm đảm bảo khả năng triển khai thực tế và
mở rộng trong tương lai.

\subsection{Lập trình phần cứng}

Ở giai đoạn này, tác giả tiến hành lập trình phần cứng bằng cách sử dụng các framework và thư viện do hãng cung cấp.
Cách tiếp cận này cho phép khai thác hầu hết các phương thức tương tác với phần cứng, cộng đồng hỗ trợ lớn đồng thời giúp rút ngắn đáng kể thời gian phát triển và giảm thiểu sai sót trong quá trình lập trình.
Tuy nhiên, để có thể kiểm soát toàn diện các chức năng của hệ thống cũng như tối ưu hóa mức tiêu thụ năng lượng, trong tương lai tác giả dự định sẽ chuyển sang phương pháp lập trình ở mức thanh ghi.

\subsubsection{Cấu hình vi xử lý và cảm biến}
Bước đầu tiên để giao tiếp với phần cứng, tác giả lựa chọn phương án thông qua
USB và Bootloader. Bootloader của Arduino Nano được nạp vào vi điều khiển bằng
giao thức Serial Wire Debug (SWD), cho phép thiết lập môi trường lập trình ban
đầu và hỗ trợ việc tải chương trình trực tiếp từ máy tính thông qua cổng USB.

Việc đọc các giá trị cảm biến thông qua thư viện SparkFun BMI270 Arduino
Library \cite{SparkFun_BMI270_Library}. Đây là thư viện mã nguồn mở do SparkFun
phát triển đóng vai trò như một lớp trừu tượng, cho phép vi điều khiển giao
tiếp trực tiếp với cảm biến Bosch BMI270. Thư viện cung cấp đầy đủ các hàm để
cấu hình dải đo, tần số lẫy mẫu và chế độ năng lượng tiêu thụ.

\input{chapters/examples/cauhinh_accelerometer.tex}

Phần cấu hình được thể hiện trong mã nguồn~\ref{lst:cauhinh_accelerometer} Việc
gọi hàm \texttt{imu.beginI2C()} nhằm thiết lập kênh truyền
I\textsuperscript{2}C và xác nhận sự hiện diện của thiết bị. Tần số lấy mẫu
được đặt ở 12,5 Hz và dải đo ở mức ±2g nhằm tối ưu độ phân giải cho các dao
động nhỏ khi ngủ ở người. Việc thiết lập cấu hình qua hàm \texttt{setConfig()}
và xác thực lại bằng \texttt{getConfig()} thể hiện nguyên tắc kiểm chứng hai
chiều nhằm chắc chắn các cấu hình đã được đặt trên phần cứng.

\newpage

\subsubsection{Cấu hình BLE}

Quá trình khởi tạo, kết nối và truyền lên thiết bị trung tâm bao gồm các bước
sau: bao gồm: tạo bản tin quảng bá (advertising), thiết lập cơ chế kết nối/ngắt
kết nối, cũng như định nghĩa UUID của dịch vụ và đặc tính theo mô hình
\gls{GATT}.

\input{chapters/examples/cauhinh_ble.tex}

\usetikzlibrary{positioning}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
            every node/.style={font=\footnotesize, align=center},
            process/.style={rectangle, draw, rounded corners,
                    minimum width=4cm, minimum height=1cm,
                    fill=blue!10, inner sep=5pt},
            arrow/.style={->, thick}
        ]
        \matrix[column sep=0mm, row sep=0.7cm] {
            \node[process] (init) {Khởi tạo BLE \& BMI270};                                                \\
            \node[process] (config) {Cấu hình cảm biến \\ ODR = 12.5 Hz, Range = $\pm$2g}; \\
            \node[process] (connect) {Kết nối thiết bị trung tâm qua BLE};                                 \\
            \node[process] (send) {Đọc \& gửi dữ liệu $x$, $y$, $z$};       \\
            \node[process] (loop) {Lặp chu kỳ 100 ms};                                                     \\
        };

        \foreach \i/\j in {init/config, config/connect, connect/send, send/loop}
        \draw[arrow] (\i) -- (\j);
    \end{tikzpicture}
    \caption{Sơ đồ tóm tắt quy trình hoạt động BLE–BMI270 của đoạn mã nguồn~\ref{lst:ble_bmi270}}
    \label{fig:ble_bmi270_shortflow}
\end{figure}

Thứ nhất, khởi tạo BLE, kích hoạt truyền thông BLE với tên hiển thị là
Master\_2025\_BLE, thiết lập cấu trúc dịch vụ GATT với hai UUID cho service và
characteristic. Trong đó characteristic được phép đọc, ghi và phát tín hiệu.

Thứ hai, khởi tạo cảm biến BMI270 và cấu hình.

Thứ ba, tạo kết nối với thiết bị trung tâm, khi tín hiệu quảng bá được phản
hồi. Sau khi kết nối thành công, phần cứng lấy được thông tin của thiết bị
trung tâm ở đây là ứng dụng điện thoại. Đây một bước xác thực cần thiết để chỉ
cho phép thiết bị trung tâm nào được lập trình sẵn.

Thứ tư, thu nhận dữ liệu cảm biến ba trục (x, y, z) từ BMI270. Các giá trị gia
tốc được đọc và chuẩn hóa trước khi truyền. Việc chuẩn hóa ở đây gồm tách dấu
và phần nguyên - phần thập phân để giảm kích thước gói tin mà vẫn đảm bảo độ
chính xác khi tái lập lại.

Cuối cùng, truyền dữ liệu định dạng byte qua BLE thông qua characteristic đã
định nghĩa. Mỗi gói tin gồm chín byte chứa đầy đủ thông tin về hướng và biên độ
gia tốc trên ba trục, được gửi chu kỳ 100 ms, bảo đảm tốc độ lấy mẫu ổn định
(10 Hz) phục vụ phân tích tư thế trong thời gian thực.

Việc chuẩn hóa 5 giai đoạn này có ưu điểm có thể bóc tách cho mục đích khác
nhau, tối ưu cho từng giai đoạn. Việc này để bảo code mạch lạc và dễ bảo trì.

\subsubsection{Lọc nhiễu bằng bộ lọc Kalman}

Trong phần phân tích các bộ lọc cũng như từ thực nghiệm tác giả thấy, khi có
những chuyển động đột ngột gia tốc cao có gây ra sai lệnh giá trị thu được.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/z_kalman.png}
    \caption{So sánh tín hiệu trục Z trước và sau lọc Kalman}
    \label{fig:z_kalman}
\end{figure}

Hình~\ref{fig:z_kalman} trình bày so sánh tín hiệu gia tốc thu được trên trục Z
giữa hai trạng thái: dữ liệu thô và dữ liệu sau khi qua bộ lọc Kalman. Có thể
quan sát thấy, trong vùng được khoanh tròn, tín hiệu thô (đường màu xanh) xuất
hiện một giá trị đột biến âm với biên độ lớn, thể hiện hiện tượng trôi tín hiệu
tạm thời do nhiễu cảm biến hoặc rung động ngoài mong muốn.

Sau khi áp dụng bộ lọc Kalman, đường tín hiệu (đường màu cam) trở nên mượt hơn
và ổn định, đồng thời loại bỏ được phần lớn sai lệch ngắn hạn. Kết quả này
chứng tỏ bộ lọc Kalman không chỉ thực hiện vai trò giảm nhiễu mà còn có khả
năng ước lượng trạng thái thật của hệ thống thông qua mô hình dự đoán – cập
nhật liên tục. Việc lọc này đặc biệt quan trọng trong bối cảnh dữ liệu thu từ
cảm biến gia tốc dùng cho nhận diện tư thế ngủ, bởi vì sai số đột biến dù chỉ
trong một khoảng ngắn cũng có thể dẫn đến phân loại sai tư thế trong mô hình
học máy.

Ngoài ra, vùng sai lệch này cũng cho thấy hạn chế của tín hiệu thô khi cảm biến
được gắn trên cơ thể người, nơi dao động nhỏ do hô hấp, chuyển động tự nhiên
hoặc thay đổi điểm đặt có thể gây ra nhiễu. Việc sử dụng Kalman giúp hiệu
chỉnh, đảm bảo giá trị đo được bám sát quỹ đạo thật của chuyển động. Tuy nhiên,
bộ lọc Kalman có thể làm giảm giá trị biên tại các đỉnh. Vấn đề này được tác
giả xem xét không ảnh hưởng nhiều đến toàn bộ bài toán phân loại tư thế ngủ. Lý
do là vì bộ đặc trưng không sử dụng trực tiếp các giá trị đỉnh này mà là một
cửa sổ mẫu và các thống kê trong cửa sổ đó.

\subsection{Phần mềm thu thập, lưu trữ}

Phần mềm trong nghiên cứu này không chỉ đơn thuần là công cụ trực quan hoá dữ
liệu cảm biến, mà còn được thiết kế như một mắt xích trọng yếu trong toàn bộ
quy trình từ thu thập, truyền tải, lưu trữ, cho đến huấn luyện và triển khai mô
hình học máy. Cách tiếp cận này đảm bảo rằng dữ liệu thu nhận từ môi trường
thực tế được xử lý nhất quán, có khả năng tái sử dụng và dễ dàng tích hợp với
các hệ thống khác.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/architecture_software.png}
    \caption{Kiến trúc tổng thể của hệ thống}
    \label{fig:architecture_software}
\end{figure}
Hình~\ref{fig:architecture_software} mô tả tổng quan các thành phần cần thiết trong luận văn và kết nối giữa chúng.
Để đưa ra kết quả phân loại tư thế ngủ dữ liệu từ cảm biến có thể có 2 hướng đi. Thứ nhất, dữ liệu từ cảm biến thông qua vi điều khiển đẩy lên ứng dụng di động
(BLE) sau đó được lưu trữ hoặc được suy luận trên máy chủ đám mây rồi trả về kết quả tại ứng dụng di động.
Thứ hai. dữ liệu từ cảm biến sau khi được đọc từ vi điều khiển thì được suy luận ngay tại biên và hiển thị kết quả thông qua các con đèn led.
Cả 2 cách đều được tác giả nghiên cứu và triển khai trong luận văn này.

\subsubsection{Ứng dụng di dộng}
Được coi như 1 cổng kết nối (gateway) trong điện toán đám mây
có nhiệm vụ gom các tín hiệu từ cảm biến gia tốc hoặc có thể mở
rộng đa cảm biến khác, hiển thị chúng theo thời gian thực và chuyển
lên máy chủ đám mây.

Dựa trên yêu cầu bài toán, tác giả xác định được các yêu cầu của phần mềm như
Bảng~\ref{tab:app_features}. Ngoài ra, các yêu cầu phi chức năng cũng được tác
giả chú ý như là bảo mật thông tin, thời gian phản hồi hệ thống.

\begin{table}[htbp]
    \centering
    \caption{Các nhóm chức năng chính của ứng dụng}
    \label{tab:app_features}
    \begin{tabularx}{\textwidth}{|l|l|X|}
        \hline
        \textbf{Nhóm} & \textbf{Chức năng}             & \textbf{Mô tả}                                                                \\ \hline
        \multirow{2}{*}{Xác thực}
                      & Đăng ký                        & Người dùng đăng kí thông tin và xác thực qua email, sđt                       \\ \cline{2-3}
                      & Đăng nhập                      & Sử dụng tài khoản mật khẩu đã được đăng ký để đăng nhập vào hệ thống          \\ \cline{2-3}
                      & Quên mật khẩu                  & Lấy lại tài khoản của người dùng                                              \\ \hline
        \multirow{2}{*}{Ứng dụng}
                      & Kết nối Bluetooth              & Kết nối ứng dụng với phần cứng thông qua BLE                                  \\ \cline{2-3}
                      & Chọn cảm biến                  & Lựa chọn cảm biến như (gia tốc, âm thanh)                                     \\ \cline{2-3}
                      & Câu hỏi STOPBANG, Epworth      & Trả lời câu hỏi STOP BANG để đánh giá OSA và hiển thị lịch sử các lần trả lời \\ \cline{2-3}
                      & Theo dõi thông tin từ cảm biến & Hiển thị dữ liệu thời gian thực thông qua các biểu đồ                         \\ \cline{2-3}
                      & Chatbot y tế                   & Chatbot xây dựng trên bộ câu hỏi 2000 câu về y học giấc ngủ và công nghệ RAG  \\ \hline                                                          \\ \hline
    \end{tabularx}
\end{table}

\subsubsection*{Kiến trúc phần mềm}
Ứng dụng di động được viết bằng ngôn ngữ DART trên nền tảng Flutter.
Vì sao lại chọn Dart mà không phải là các ngôn ngữ thuần túy như Java hay
Swift? Nói chung, tác giả chọn Dart trên nền tảng Flutter lý do chính là có thể
tạo ra hai phiên bản trên Android và IOS trên cùng một bộ mã chương trình.
Ngoài ra, việc khởi tạo dự án nhanh, cú pháp thân thiện với người lập trình
hơn, kèm cộng đồng đông đảo làm giảm đáng kể thời gian phát triển.

Để ứng dụng dễ kiểm thử và nâng cấp, tác giả tìm hiểu và lựa chọn nguyên tắc thiết kế
BLoC. Nó hoạt động dựa trên nguyên tắc nhận sự kiện đầu vào từ giao diện gồm trạng thái và dữ liệu đầu vào, xử lý trong khối BLOC như gọi lên máy chủ trung tâm
và trả lại dữ liệu. Qua đó, luồng dữ liệu trở nên rõ ràng. Cấu trúc tổng thể của kiến trúc
BLoC gồm ba lớp chính được mô tả trong Hình~\ref{flutter}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/flutter.png}
    \caption{Cấu trúc kiến trúc BLoC trong ứng dụng Flutter}
    \label{flutter}
\end{figure}

Mã nguồn của toàn bộ ứng dụng di động tác giả sẽ để dưới phần mục lục. Còn
trong khuôn khổ luận văn nay, tác giả sẽ giải thích chức năng chính là kết nối
phần cứng, hiển thị và chuyển dữ liệu lên máy chủ trung tâm.

\newpage

\textbf{Đầu tiên, kết nối và nhận dữ liệu BLE}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
            every node/.style={font=\footnotesize, align=center},
            process/.style={rectangle, draw, rounded corners,
                    minimum width=4cm, minimum height=1cm,
                    fill=blue!10, inner sep=5pt},
            arrow/.style={->, thick}
        ]
        \matrix[column sep=0mm, row sep=0.7cm] {
            \node[process] (init) {Yêu cầu cấp quyền Bluetooth từ thiết bị thật};                 \\
            \node[process] (finding) {Tìm kiểm các thiết bị BLE ngoại vi};                        \\
            \node[process] (connect) {Thiết lập kết nối với phần cứng qua tên Master\_2025\_BLE}; \\
            \node[process] (choosing) {Chọn đúng dịch vụ và đặc trưng theo UUID};                 \\
            \node[process] (notify) {Bắn tín hiệu theo dõi};
            \node[process] (present) {Hiển thị dữ liệu và đẩy lên máy chủ trung tâm};             \\
        };

        \foreach \i/\j in {init/finding, finding/connect, connect/choosing, choosing/notify, notify/present}
        \draw[arrow] (\i) -- (\j);
    \end{tikzpicture}
    \caption{Sơ đồ kết nối và nhận dữ liệu của ứng dụng di động}
    \label{fig:mobile_ble}
\end{figure}

\input{chapters/examples/flutter_ble}

Mã~\ref{flutterBle} thể hiện: từ kết nối BLE, truy xuất đặc tính gia tốc, đọc
giá trị nhị phân thô từ thiết bị, đến việc chuẩn hoá và gửi dữ liệu lên
backend. Trong đoạn mã này, dữ liệu dạng \texttt{Uint8List} nhận từ cảm biến
được tách và chuyển đổi thành ba thành phần tương ứng với ba trục gia tốc. Dữ
liệu sau khi được xử lý sẽ được đóng gói theo định dạng \texttt{JSON} và gửi
đến máy chủ thông qua phương thức POST, sử dụng thư viện \texttt{http} trong
Flutter.

\input{chapters/examples/format_data_ble.tex}

Sau khi kết nối BLE được thiết lập thành công, ứng dụng truy xuất đối tượng đặc
tính cảm biến (characteristic instance) và liên tục gửi yêu cầu đọc
(\texttt{read}) đến vi điều khiển. Thiết bị phản hồi bằng cách trả về dữ liệu
cảm biến dưới dạng mảng \texttt{UInt8}. Các giá trị này được ứng dụng giải mã,
chuyển đổi sang dạng số thực tương ứng với gia tốc trên ba trục (X, Y, Z), và
gắn nhãn thời gian thực.

Quá trình xử lý này được thực hiện trong một vòng lặp có kiểm soát độ trễ ngắn
nhằm đảm bảo khả năng cập nhật liên tục nhưng vẫn tối ưu hiệu suất hệ thống.

Định dạng dữ liệu BLE được chuẩn hoá như trong Mã~\ref{format_ble},
với trường \texttt{"value"} là chuỗi liên tục các
giá trị cảm biến (phân tách bằng ký tự đặc biệt) và trường
\texttt{"customer"} để định danh người dùng.

Việc tối ưu hóa cả quá trình đọc BLE và đẩy dữ liệu HTTP theo lô như vậy giúp
giảm độ trễ, tránh tình trạng nghẽn băng thông, đồng thời vẫn đảm bảo độ chính
xác và toàn vẹn của dữ liệu cảm biến.

Ngoài các chức năng thu thập và truyền dữ liệu cảm biến, ứng dụng còn tích hợp
các công cụ hỗ trợ đánh giá y học lâm sàng ban đầu nhằm phục vụ cho việc sàng
lọc và phân loại nguy cơ mắc hội chứng ngưng thở khi ngủ (OSA). Trong đó, ba
thành phần quan trọng được triển khai bao gồm:

\noindent\textbf{01)} Bộ câu hỏi \textbf{STOP-BANG}: Đây là một bảng sàng lọc lâm sàng được sử dụng phổ biến trong y học giấc ngủ để đánh giá nguy cơ mắc OSA. Dữ liệu từ bảng này được lưu trữ cùng với dữ liệu cảm biến và đóng vai trò như đầu vào bổ sung cho các mô hình học máy dự đoán chỉ số AHI (Apnea-Hypopnea Index).

\vspace{0.5em}
\noindent\textbf{02)} Thang điểm \textbf{Epworth Sleepiness Scale (ESS)}: Tác giả triển khai thêm bảng câu hỏi ESS nhằm đánh giá mức độ buồn ngủ ban ngày của người dùng. Thang điểm này giúp phát hiện tình trạng buồn ngủ quá mức và có thể hỗ trợ phân tầng nguy cơ trong mô hình phân loại rối loạn giấc ngủ.

\vspace{0.5em}
\noindent\textbf{03)} Đánh giá \textbf{BMI (Body Mass Index)}: BMI được tự động tính toán dựa trên chiều cao và cân nặng người dùng nhập vào. Chỉ số này đóng vai trò là một trong các yếu tố nguy cơ chính trong chẩn đoán OSA, đặc biệt khi kết hợp cùng STOP-BANG.

Ngoài ra, nhằm cải thiện trải nghiệm người dùng và hỗ trợ trả lời câu hỏi liên
quan đến giấc ngủ, tác giả phát triển thêm tính năng \textbf{chatbot y học giấc
    ngủ} dựa trên kỹ thuật \textbf{Retrieval-Augmented Generation (RAG)}. Chatbot
này được xây dựng từ cơ sở dữ liệu gồm hơn 2000 câu hỏi và câu trả lời chuyên
sâu liên quan đến giấc ngủ được biên tập bởi GS.TS Dương Quý Sỹ, bao gồm cả tài
liệu lâm sàng, nghiên cứu khoa học và các hướng dẫn thực hành. Người dùng có
thể đặt câu hỏi tự nhiên như “Tôi có nên lo nếu ngủ ngáy liên tục?” hoặc
“STOP-BANG > 5 có ý nghĩa gì?”, và chatbot sẽ phản hồi dựa trên kiến thức được
truy xuất từ tài liệu nền và được tổng hợp lại bằng mô hình ngôn ngữ.

Hệ thống RAG kết hợp khả năng truy vấn ngữ nghĩa từ tập văn bản lớn (document
retrieval) và khả năng sinh văn bản linh hoạt từ mô hình ngôn ngữ lớn (LLM), từ
đó cung cấp các câu trả lời chính xác, có căn cứ và dễ hiểu cho người dùng
không chuyên.

\textbf{Tính năng quản lý người dùng} cũng được mở rộng. Người dùng có thể
tạo tài khoản một lần và sử dụng lại trong các lần đăng nhập sau. Cơ chế này
giúp rút ngắn thao tác, đồng thời vẫn đảm bảo tính bảo mật và khả năng khôi
phục dữ liệu khi quên tài khoản hoặc mật khẩu. Dữ liệu người dùng
(câu hỏi, chỉ số BMI, lịch sử cảm biến) được liên kết thống nhất qua một
ID định danh duy nhất, hỗ trợ tốt cho việc phân tích, theo dõi tiến triển
và huấn luyện mô hình học máy cá nhân hoá trong tương lai.

Có thể thấy rằng, việc đáp ứng đầy đủ các \textbf{yêu cầu chức năng} mới chỉ
đảm bảo hệ thống thực hiện được các nhiệm vụ cốt lõi đã đề ra, chẳng hạn như
thu thập dữ liệu, hiển thị tín hiệu hay quản lý hồ sơ người dùng. Tuy nhiên,
trong bối cảnh triển khai thực tiễn, điều này là chưa đủ. Một hệ thống có thể
hoạt động đúng chức năng nhưng sẽ nhanh chóng trở nên khó sử dụng hoặc thậm chí
thất bại nếu thiếu đi các \textbf{yêu cầu phi chức năng} quan trọng. Những yêu
cầu này bao gồm độ tin cậy khi vận hành liên tục trong môi trường thực tế, tính
bảo mật nhằm bảo vệ dữ liệu y tế nhạy cảm, khả năng mở rộng để thích ứng với số
lượng người dùng tăng dần, cũng như hiệu năng xử lý để đảm bảo dữ liệu được
truyền tải theo thời gian thực. Do đó, chỉ khi cả hai nhóm yêu cầu được quan
tâm song song và được tích hợp hài hòa ngay từ giai đoạn thiết kế, hệ thống mới
vừa đáp ứng đúng mục tiêu nghiên cứu, vừa có tính khả thi và bền vững khi ứng
dụng trong y tế lâm sàng và cộng đồng.

\subsection{Thiết kế và xây dựng hệ thống lưu trữ}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/cloud.png}
    \caption{Mô hình tích hợp giữa mạng cảm biến và cấu trúc dữ liệu đám mây}
    \label{cloud}
\end{figure}

Trong hệ thống đề xuất, dữ liệu cảm biến giữ vai trò trung tâm trong việc huấn
luyện và triển khai các mô hình trí tuệ nhân tạo (\textit{AI}). Do giới hạn bộ
nhớ của vi điều khiển và thiết bị đầu cuối, giải pháp lưu trữ dữ liệu trên nền
tảng đám mây trở thành lựa chọn tất yếu. Không chỉ giúp vượt qua hạn chế về
dung lượng, cloud còn loại bỏ rào cản về địa lý, cho phép chia sẻ và phân tích
dữ liệu từ bất kỳ đâu có kết nối Internet. Để bảo đảm hiệu quả, kiến trúc lưu
trữ được phân chia thành ba khối chức năng chính: \textbf{máy chủ xử lý},
\textbf{tầng bộ nhớ đệm (cache)}, và \textbf{cơ sở dữ liệu lưu trữ}.

\textbf{(i) Máy chủ xử lý.}
Máy chủ được triển khai trên nền tảng \texttt{Node.js} và vận hành trong hạ tầng
Amazon Web Services (AWS), thể hiện một sự lựa chọn chiến lược trong thiết kế kiến trúc hệ thống.
Trong bối cảnh các ứng dụng IoT y tế tạo ra luồng dữ liệu liên tục và khối lượng lớn,
việc sử dụng Node.js với mô hình bất đồng bộ (asynchronous, event-driven) cho phép máy chủ xử lý đồng thời
nhiều kết nối mà không cần tiêu tốn tài nguyên theo kiểu đa luồng truyền thống.
Điều này đặc biệt quan trọng khi hệ thống cần thu nhận dữ liệu từ nhiều thiết bị đeo cùng lúc
trong các nghiên cứu lâm sàng quy mô lớn, vốn tiềm ẩn nguy cơ quá tải nếu không có cơ chế tối ưu.

Một nguyên tắc cốt lõi của thiết kế máy chủ là \textit{batch processing}. Thay
vì gửi từng gói dữ liệu riêng lẻ, hệ thống tích luỹ các gói tin thành lô 1000
mẫu trước khi truyền tới backend. Cách tiếp cận này không chỉ giảm số lượng yêu
cầu HTTP, mà còn tối ưu băng thông, giảm độ trễ mạng và hạ thấp chi phí vận
hành trên cloud. Từ góc độ khoa học dữ liệu, xử lý theo lô cũng giúp bảo toàn
tính toàn vẹn của chuỗi thời gian, cho phép phân tích tín hiệu gia tốc
(\texttt{x, y, z}) đi kèm mốc thời gian (\texttt{timestamp}) một cách nhất
quán. Đây là yếu tố then chốt để đảm bảo tính tái lập (reproducibility) của các
thí nghiệm và độ tin cậy của mô hình học máy huấn luyện từ dữ liệu đó.

Máy chủ còn được trang bị cơ chế \textit{retry logic} để tăng tính bền bỉ
(resilience) của hệ thống trước những sự cố mạng thường gặp trong môi trường
thực tế. Thay vì chấp nhận mất gói dữ liệu, hệ thống sẽ thử gửi lại nhiều lần;
chỉ khi thất bại liên tục quá 10 lần mới thông báo lỗi và tạm dừng tiến trình
lưu trữ. Cơ chế này phản ánh nguyên tắc thiết kế quan trọng trong các hệ thống
y tế: \textit{“fail-safe and fault-tolerant”}, tức là ngay cả khi gặp lỗi, hệ
thống vẫn đảm bảo không gây ra sai lệch dữ liệu, đồng thời cung cấp tín hiệu rõ
ràng cho người vận hành.

Tóm lại, tầng máy chủ không chỉ đơn thuần là nơi tiếp nhận dữ liệu từ thiết bị,
mà còn là lớp điều phối trung tâm, kết hợp giữa hiệu quả tính toán (nhờ kiến
trúc bất đồng bộ của Node.js), khả năng mở rộng linh hoạt (nhờ hạ tầng AWS), và
các cơ chế bảo đảm tính toàn vẹn dữ liệu (batch processing và retry logic).
Thiết kế này cho thấy một hướng tiếp cận hệ thống phân tán trong lĩnh vực IoT y
tế, nơi yêu cầu vừa đáp ứng tải dữ liệu cao, vừa bảo đảm chất lượng khoa học và
tính khả thi triển khai trong môi trường lâm sàng.

\textbf{(ii) Bộ nhớ đệm (cache).}
Trong kiến trúc hệ thống IoT y tế, tầng cache giữ vai trò chiến lược như một lớp
trung gian giữa ứng dụng và cơ sở dữ liệu, không chỉ để lưu tạm dữ liệu khi mất kết nối
mạng, mà còn để tối ưu hiệu năng và giảm áp lực cho backend.
Nếu ứng dụng gửi trực tiếp từng gói dữ liệu lên cơ sở dữ liệu, hệ thống sẽ phải xử lý
một lượng lớn yêu cầu nhỏ lẻ, gây nghẽn băng thông và tăng độ trễ phản hồi.
Đặc biệt với dữ liệu cảm biến liên tục theo thời gian thực, chiến lược này dễ dẫn đến
tình trạng “request storm” khiến máy chủ và cơ sở dữ liệu bị quá tải.
Việc bổ sung một lớp cache giúp gom dữ liệu thành lô,
tối ưu băng thông truyền tải và đồng thời cung cấp cơ chế \textit{write-back}
tới cơ sở dữ liệu khi mạng ổn định.

Ý nghĩa của tầng cache không chỉ dừng ở việc lưu trữ tạm thời.
Nó còn là thành phần bảo đảm \textbf{tính liên tục dịch vụ (service continuity)}:
người dùng vẫn có thể quan sát dữ liệu cảm biến theo thời gian thực ngay cả khi mất mạng,
và hệ thống sẽ tự động đồng bộ dữ liệu sau khi kết nối được khôi phục.
Điều này đặc biệt quan trọng trong nghiên cứu y học giấc ngủ tại nhà,
nơi mà gián đoạn kết nối Internet là tình huống phổ biến.
Từ góc nhìn lâm sàng, sự hiện diện của cache giúp giảm thiểu nguy cơ mất dữ liệu,
một yếu tố có thể ảnh hưởng trực tiếp tới độ tin cậy của mô hình học máy huấn luyện trên dữ liệu đó.

Trong giai đoạn mở rộng, tầng cache có thể triển khai bằng các hệ thống bộ nhớ
đệm phân tán như \texttt{Redis} hoặc \texttt{Memcached}, hỗ trợ hàng nghìn truy
vấn đồng thời và cho phép xử lý dữ liệu theo cơ chế \textit{publish/subscribe}.
Ở mức độ cao hơn, tầng cache có thể kết hợp với hàng đợi thông điệp
(\textit{message queue}) như \texttt{RabbitMQ} hoặc \texttt{Kafka}, nhằm điều
phối luồng dữ liệu giữa ứng dụng và backend. Giải pháp này đặc biệt hữu ích khi
hệ thống mở rộng tới hàng trăm hoặc hàng nghìn thiết bị đeo cùng hoạt động,
giúp cân bằng tải, tránh tình trạng \textit{data race}, và tăng tính ổn định
tổng thể.

Tóm lại, tầng cache không chỉ là một cơ chế tối ưu hiệu năng, mà còn là
\textbf{cấu phần bảo đảm tính tin cậy và khả năng mở rộng} của toàn bộ hệ
thống. Nếu coi máy chủ là trung tâm điều phối và cơ sở dữ liệu là nền tảng lưu
trữ, thì tầng cache chính là “vùng đệm an toàn” giúp hệ thống hấp thụ sự biến
động của môi trường mạng và duy trì hoạt động ổn định trong mọi kịch bản triển
khai.

\textbf{(iii) Cơ sở dữ liệu lưu trữ.}
Trong các hệ thống IoT y tế, đặc biệt là khi dữ liệu cảm biến và dữ liệu lâm sàng cùng tồn tại,
không một mô hình cơ sở dữ liệu đơn lẻ nào có thể đáp ứng tối ưu tất cả yêu cầu.
Do đó, kiến trúc lưu trữ được thiết kế theo hướng \textbf{lai (hybrid storage architecture)},
kết hợp cả NoSQL (MongoDB Atlas) và SQL (MySQL), nhằm tận dụng thế mạnh riêng của từng loại hình.

Với dữ liệu cảm biến thời gian thực, \textbf{MongoDB Atlas} thể hiện ưu thế
vượt trội nhờ khả năng lưu trữ phi cấu trúc, phân tán trên nhiều cụm máy chủ và
hỗ trợ mở rộng theo chiều ngang (\textit{horizontal scaling}). Đặc thù của dữ
liệu gia tốc là liên tục, khối lượng lớn, và thay đổi nhanh, do đó cơ chế đánh
chỉ mục theo \texttt{timestamp} cùng với tính năng TTL (Time-To-Live index) của
MongoDB giúp tối ưu hóa truy vấn, giảm dung lượng lưu trữ. Điều này mang lại ý
nghĩa khoa học quan trọng: cho phép xử lý tín hiệu theo chuỗi thời gian mà
không bị nhiễu bởi dữ liệu cũ, đồng thời bảo đảm tính nhất quán khi huấn luyện
mô hình học máy.

Trong khi đó, \textbf{MySQL} được sử dụng để quản lý các dữ liệu có cấu trúc ổn
định và đòi hỏi tính toàn vẹn quan hệ, chẳng hạn như thông tin định danh người
dùng, mật khẩu mã hoá, kết quả bảng điểm STOP-BANG, thang điểm Epworth, chỉ số
BMI, và tiền sử bệnh nền. Việc sử dụng hệ quản trị quan hệ cho phép đảm bảo
\textbf{tính ràng buộc (constraints)} giữa các bảng và duy trì độ chính xác dữ
liệu trong các thao tác xác thực, phân quyền và theo dõi tiến triển y khoa. Từ
góc nhìn triển khai lâm sàng, đây là điều kiện tiên quyết để hệ thống đáp ứng
được các quy chuẩn bảo mật dữ liệu y tế (ví dụ HIPAA hoặc các tiêu chuẩn tương
tự).

Do đó, kiến trúc lai chính là sự cân bằng giữa \textbf{tính linh hoạt} và
\textbf{tính toàn vẹn}, vừa bảo đảm hiệu năng, vừa bảo đảm tính tin cậy khi ứng
dụng trong môi trường y tế.

\textbf{Mở rộng về sau}, khi khối lượng dữ liệu ngày càng gia tăng và đa dạng hoá về nguồn gốc
(cảm biến đeo, hồ sơ bệnh án điện tử, dữ liệu hình ảnh y tế), hệ thống có thể được mở rộng
thành một \textbf{datalake} trên nền tảng cloud.
Khác với cơ sở dữ liệu truyền thống chỉ lưu dữ liệu đã chuẩn hóa, datalake cho phép lưu trữ
song song dữ liệu có cấu trúc, bán cấu trúc và phi cấu trúc, mở ra khả năng phân tích hợp nhất
trên toàn bộ phổ dữ liệu. Điều này mang lại giá trị chiến lược cho các nghiên cứu y học giấc ngủ,
vì cho phép liên kết dữ liệu tư thế ngủ với dữ liệu sinh học khác (EEG, SpO$_2$, nhịp tim)
trong các nghiên cứu đa trung tâm.

Song song, việc tích hợp các công cụ phân tích và trực quan hóa như
\textbf{Microsoft Power BI} giúp chuyển đổi dữ liệu thô thành báo cáo và biểu
đồ động, hỗ trợ các bác sĩ và nhà nghiên cứu ra quyết định kịp thời. Power BI
không chỉ đơn thuần là công cụ hiển thị, mà còn là một lớp phân tích trung
gian, cho phép truy vấn dữ liệu từ cả MySQL, MongoDB và datalake, sau đó biểu
diễn các chỉ số quan trọng theo thời gian thực. Đây chính là cầu nối giữa
\textbf{dữ liệu lớn (big data)} và \textbf{tri thức y khoa}, tạo ra tác động
trực tiếp đến chất lượng chẩn đoán và theo dõi bệnh nhân.

Ở mức độ khái quát hơn, việc lựa chọn kiến trúc lưu trữ lai kết hợp mở rộng sang datalake
và trực quan hóa bằng Power BI phản ánh xu hướng thiết kế hệ thống y tế hiện đại:
\textit{“data-centric and insight-driven architecture”}.
Không chỉ dừng ở việc thu thập và lưu trữ dữ liệu, hệ thống còn tiến tới
khai thác tri thức từ dữ liệu để hỗ trợ chẩn đoán, dự báo nguy cơ
và nâng cao chất lượng chăm sóc sức khỏe cộng đồng.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{images/flow_http.png}
    \caption{Lưu đồ thuật toán lưu trữ dữ liệu cảm biến}
    \label{flow_http}
\end{figure}

Lưu đồ thuật toán lưu trữ dữ liệu được thể hiện trong Hình~\ref{flow_http}, bao
gồm hai nhánh xử lý nhằm đảm bảo tính liên tục dịch vụ và độ tin cậy dữ liệu.
\textit{(i)} Khi người dùng không có kết nối mạng, hệ thống vẫn duy trì liên
kết BLE và hiển thị tín hiệu thời gian thực; dữ liệu được lưu tạm ở phía thiết
bị/ứng dụng thay vì đẩy lên cloud. \textit{(ii)} Khi người dùng đã đăng nhập và
có Internet, ứng dụng chuyển sang chế độ đồng bộ theo lô: mỗi 1000 mẫu được gộp
thành một batch để gửi lên máy chủ. Cơ chế này vừa giảm overhead giao thức, vừa
bảo toàn tính liên tục của chuỗi thời gian để phục vụ phân tích tín hiệu. Trong
trường hợp thao tác gửi thất bại liên tiếp quá 10 lần, hệ thống chủ động phát
cảnh báo và tạm ngừng quá trình lưu trữ nhằm bảo đảm tính nhất quán
(consistency) và tránh sai lệch dữ liệu.

\subsection{Học máy trong phân loại tư thế ngủ}
Học máy ngày càng được xem là công cụ hiệu quả trong việc phân loại tư thế ngủ
dựa trên dữ liệu cảm biến. Các thuật toán học máy cho phép phát hiện và nhận
diện tư thế với độ chính xác cao hơn so với các phương pháp truyền thống. Nhờ
đó, chúng tạo nền tảng quan trọng cho việc phát triển các hệ thống giám sát
giấc ngủ thông minh, hỗ trợ sàng lọc và chẩn đoán hội chứng ngưng thở khi ngủ.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/hocmay_time.png}
    \caption{Phân bố thời gian thực hiện đối với dự án học máy}
    \label{hocmay_time}
\end{figure}

Hình~\ref{hocmay_time} trình bày phân bố thời gian tương đối giữa các công đoạn
trong quá trình triển khai một dự án học máy thực tế. Dữ liệu trong biểu đồ cho
thấy rằng phần lớn thời gian không nằm ở bước huấn luyện mô hình, mà được dành
cho các công việc tiền xử lý dữ liệu - chiếm đến hơn 60\% tổng thời gian. Cụ
thể, hai hoạt động tốn thời gian nhất là \textbf{làm sạch dữ liệu} và
\textbf{gán nhãn dữ liệu}, mỗi hoạt động chiếm 25\% tổng thời lượng thực hiện.
Tiếp theo là \textbf{bổ sung dữ liệu} (15\%) và \textbf{phân tích dữ liệu}
(10\%). Bốn công đoạn này là nền tảng quyết định chất lượng đầu vào, ảnh hưởng
trực tiếp đến độ chính xác và khả năng tổng quát hóa của mô hình sau khi huấn
luyện.

Trong khi đó, các bước thường được quan tâm trong các tài liệu học thuật như
huấn luyện mô hình (10\%), phát triển thuật toán (3\%) và tinh chỉnh mô hình
(5\%) lại chiếm tỷ trọng thấp hơn. Giai đoạn vận hành thực tế (deployment) cũng
chỉ chiếm khoảng 2\%, tuy nhiên vẫn đóng vai trò quan trọng trong việc chuyển
giao ứng dụng ra ngoài môi trường thử nghiệm.

Sự phân bố này phản ánh đặc điểm phổ biến trong các dự án học máy với dữ liệu
thực tế từ cảm biến: chất lượng mô hình phụ thuộc chủ yếu vào dữ liệu và quy
trình xử lý trước huấn luyện. Do đó, việc đầu tư thời gian vào xử lý dữ liệu là
hoàn toàn cần thiết và hợp lý.

Tổng quan về các bước xây dựng hệ thống học máy cho bài toán phân loại tư thế
ngủ đã được trình bày tại Chương~\ref{chapter:1-introduction}. Trong mục này,
tác giả đi sâu vào phân tích các thuật toán học máy đã được lựa chọn, lý do lựa
chọn, đặc điểm cấu trúc của từng mô hình, cũng như hiệu quả của chúng trong bối
cảnh bài toán sử dụng dữ liệu cảm biến gia tốc ba trục.

\textbf{Hồi quy Logistic (Logistic Regression - LR)} là một trong những thuật toán
cơ bản và phổ biến nhất trong học máy, đặc biệt phù hợp với các
bài toán phân loại nhị phân. Về mặt cấu trúc, LR tương tự như hồi
quy tuyến tính ở chỗ sử dụng tổ hợp tuyến tính giữa các đặc trưng
đầu vào và trọng số, tuy nhiên kết quả đầu ra được đưa qua một hàm
kích hoạt phi tuyến gọi là \textbf{hàm logistic (sigmoid)}
để ánh xạ về miền giá trị $[0, 1]$ \cite{cramer2002logistic}:

\begin{equation}
    \sigma(z) = \frac{1}{1 + e^{-z}}, \quad \text{với } z = \mathbf{w}^T \mathbf{x} + b
\end{equation}

Trong đó, $\mathbf{w}$ là vector trọng số, $\mathbf{x}$ là vector đặc trưng đầu
vào, và $b$ là hệ số điều chỉnh (bias). Giá trị $\sigma(z)$ thể hiện xác suất
điểm dữ liệu $\mathbf{x}$ thuộc lớp 1. Nếu xác suất này lớn hơn ngưỡng (thường
là 0.5), mô hình phân loại $\mathbf{x}$ thuộc lớp dương.

Mặc dù đơn giản và dễ triển khai, hồi quy logistic nguyên thủy chỉ phù hợp với
các bài toán phân loại nhị phân. Để mở rộng cho bài toán phân loại đa lớp
(multiclass classification), có thể sử dụng biến thể \textbf{Softmax
    Regression}, trong đó mô hình ước lượng xác suất đầu ra theo phân phối softmax:

\begin{equation}
    P(y = j \mid \mathbf{x}) = \frac{e^{\mathbf{w}_j^T \mathbf{x}}}{\sum_{k=1}^{K} e^{\mathbf{w}_k^T \mathbf{x}}}
\end{equation}

Trong đó, $K$ là tổng số lớp, $\mathbf{w}_j$ là vector trọng số tương ứng với
lớp $j$.

Trong khuôn khổ đề tài này, Logistic Regression được lựa chọn nhờ ưu điểm về
đơn giản, hiệu quả tính toán và kích thước mô hình nhỏ gọn (< 5 KB), cho phép
triển khai trực tiếp trên các vi điều khiển như \texttt{nRF52840}. Mặc dù độ
chính xác có thể thấp hơn một số mô hình phức tạp hơn như Random Forest hoặc
Gradient Boosting, LR vẫn đảm bảo hiệu năng chấp nhận được trong bối cảnh hệ
thống nhúng giới hạn tài nguyên.

\textbf{Máy vector hỗ trợ (Support Vector Machine - SVM)} là một thuật
toán học có giám sát, đặc biệt hiệu quả cho các bài toán phân loại nhị
phân với biên ranh giới rõ ràng \cite{cortes1995svm}. Ý tưởng chính của SVM là tìm kiếm một
\textbf{mặt siêu phẳng (hyperplane)} trong không gian đặc trưng để phân
chia các điểm dữ liệu thành hai lớp sao cho biên phân cách giữa các lớp
là lớn nhất.

Trong không gian hai chiều, mặt siêu phẳng tương ứng với một đường thẳng; trong
không gian ba chiều, đó là một mặt phẳng; và trong không gian nhiều chiều hơn,
nó là một siêu mặt phẳng tổng quát. SVM chọn mặt siêu phẳng sao cho khoảng cách
(margin) từ nó đến các điểm dữ liệu gần nhất của mỗi lớp - gọi là
\textbf{support vectors} - là tối đa. Bài toán tối ưu hóa trong SVM có thể biểu
diễn như sau:

\begin{equation}
    \min_{\mathbf{w}, b} \frac{1}{2} \|\mathbf{w}\|^2 \quad
    \text{subject to } \quad y_i(\mathbf{w}^T \mathbf{x}_i + b) \geq 1, \quad \forall i
\end{equation}

Trong đó, $\mathbf{w}$ là vector trọng số, $b$ là hệ số bias, và
$(\mathbf{x}_i, y_i)$ là tập dữ liệu huấn luyện.

Hình~\ref{svm} minh hoạ khái niệm mặt siêu phẳng và các support vectors trong
không gian hai chiều.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{images/svm.png}
    \caption{Minh họa mặt siêu phẳng phân tách hai lớp trong SVM}
    \label{svm}
\end{figure}
Ưu điểm nổi bật của SVM là khả năng xử lý hiệu quả trong không gian
đặc trưng cao. Thêm vào đó, SVM có thể mở rộng cho các bài toán
không tuyến tính thông qua việc sử dụng các hàm kernel, chẳng hạn như
\textbf{Gaussian RBF kernel} hoặc \textbf{polynomial kernel},
giúp ánh xạ dữ liệu vào không gian mới nơi mà việc phân tách tuyến tính
trở nên khả thi.

Tuy nhiên, SVM cũng tồn tại một số hạn chế. Khi dữ liệu không thể phân tách
tuyến tính rõ ràng hoặc chứa nhiều nhiễu, hiệu quả phân loại có thể suy giảm
đáng kể. Ngoài ra, chi phí tính toán trong giai đoạn huấn luyện tăng nhanh theo
kích thước tập dữ liệu, điều này làm cho SVM trở nên khó triển khai trong các
hệ thống có tài nguyên hạn chế hoặc yêu cầu thời gian thực, như thiết bị nhúng
hoặc biên.

Một khái niệm quan trọng trong SVM là \textbf{biên (margin)} - khoảng cách giữa
mặt siêu phẳng và các điểm dữ liệu gần nhất thuộc hai lớp. Mặt siêu phẳng tối
ưu là mặt phẳng có biên lớn nhất, và chỉ những điểm nằm gần sát biên mới ảnh
hưởng đến việc xác định mặt siêu phẳng, được gọi là \textbf{các vector hỗ trợ
    (support vectors)}. Các điểm này hỗ trợ việc xác định biên phân cách và trực
tiếp ảnh hưởng đến hàm quyết định (decision function) của mô hình. Bài toán tối
ưu hoá của SVM tìm ra các trọng số và bias sao cho biên được cực đại.

Để mở rộng cho các bài toán phân loại đa lớp, có thể áp dụng hai kỹ
thuật phổ biến: \textbf{one-vs-one} và \textbf{one-vs-rest}, được minh
hoạ trong Hình~\ref{svm_ovso} và Hình~\ref{ovsr}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{images/svm_ovso.png}
    \caption{Chiến lược phân loại đa lớp bằng phương pháp One-vs-One}
    \label{svm_ovso}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{images/ovsr.png}
    \caption{Chiến lược phân loại đa lớp bằng phương pháp One-vs-Rest}
    \label{ovsr}
\end{figure}

\textbf{One-vs-One (OvO):} Trong phương pháp này, một mô hình SVM được
huấn luyện cho mỗi cặp lớp. Với $K$ lớp, tổng cộng $\frac{K(K-1)}{2}$
mô hình con được huấn luyện. Mỗi mô hình học cách phân biệt giữa hai
lớp cụ thể và bỏ qua các lớp còn lại. Trong quá trình dự đoán, một cơ
chế bỏ phiếu (voting) được sử dụng để xác định lớp cuối cùng.

\textbf{One-vs-Rest (OvR):} Phương pháp này huấn luyện một mô hình cho
mỗi lớp, trong đó mô hình học cách phân biệt giữa một lớp cụ thể và
phần còn lại. Với $K$ lớp, ta có $K$ mô hình. Trong quá trình suy luận,
mô hình đưa ra xác suất hoặc độ tin cậy, và lớp có giá trị cao nhất
sẽ được chọn.

Cả hai chiến lược OvO và OvR đều giúp mở rộng SVM từ mô hình phân loại nhị phân
thành phân loại đa lớp hiệu quả, nhưng mỗi phương pháp đều có ưu và nhược điểm
riêng về thời gian huấn luyện, độ phức tạp tính toán và hiệu năng phân loại.

\textbf{Rừng ngẫu nhiên (Random Forest - RF)} là một mô hình học có
giám sát thuộc nhóm thuật toán tổ hợp (ensemble learning),
được xây dựng dựa trên nền tảng của
\textbf{Cây quyết định (Decision Tree)} \cite{breiman2001random}.
Khác với việc sử dụng một cây duy nhất như trong Decision Tree
truyền thống, Random Forest xây dựng một tập hợp gồm nhiều cây
quyết định độc lập, mỗi cây học trên một phần khác nhau của dữ liệu và
không sử dụng toàn bộ tập thuộc tính. Dự đoán cuối cùng của mô hình
được xác định thông qua cơ chế biểu quyết (voting) hoặc trung bình hoá
(trong bài toán hồi quy).

Ý tưởng chính của Random Forest nhằm giảm thiểu hiện tượng
\textbf{quá khớp (overfitting)} thường gặp trong Decision Tree đơn lẻ.
Khi xây dựng một cây quyết định mà không giới hạn độ sâu,
cây có xu hướng học thuộc hoàn toàn dữ liệu huấn luyện,
dẫn đến khả năng tổng quát kém trên tập kiểm thử.
RF khắc phục điều này bằng cách đưa vào hai cơ chế ngẫu nhiên chính:

\vspace{0.5em}
\noindent\textbf{1) Lấy mẫu bootstrap:} Mỗi cây được huấn luyện trên
một tập con của dữ liệu ban đầu, được chọn ngẫu nhiên có lặp lại
(bootstrap sampling). Như vậy, một phần dữ liệu được bỏ qua,
làm tăng tính đa dạng giữa các cây.

\vspace{0.5em}
\noindent\textbf{2) Lựa chọn ngẫu nhiên tập thuộc tính:} Tại mỗi nút
phân chia của cây, chỉ một tập con ngẫu nhiên của các thuộc tính được
xem xét để chọn điểm chia tốt nhất. Điều này làm giảm sự tương quan
giữa các cây trong rừng.

Do các cây trong Random Forest được huấn luyện trên những tập dữ liệu và tập
thuộc tính khác nhau, mỗi cây đơn lẻ có thể có sai số lớn (high bias hoặc
underfitting). Tuy nhiên, việc tổng hợp kết quả của nhiều cây giúp giảm phương
sai (variance), cải thiện khả năng tổng quát hoá. Nhờ đó, Random Forest đạt
được sự cân bằng giữa bias và variance - một trong những đặc điểm lý tưởng của
mô hình học máy tốt.

Một đặc điểm quan trọng khác là \textbf{tính ổn định} của RF đối với nhiễu và
dữ liệu không cân bằng, cùng với khả năng \textbf{đánh giá mức độ quan trọng
    của đặc trưng (feature importance)} thông qua chỉ số Gini hoặc entropy trung
bình trên toàn bộ cây.

Tuy nhiên, mô hình Random Forest có kích thước lớn do lưu trữ nhiều cây quyết
định, mỗi cây có thể có độ sâu đáng kể. Điều này khiến RF khó triển khai trực
tiếp trong môi trường hạn chế tài nguyên như các vi điều khiển hoặc thiết bị
đeo (wearables). Trong nghiên cứu này, RF được sử dụng như một mô hình tham
chiếu mạnh về độ chính xác, nhưng chưa phải là lựa chọn phù hợp cho triển khai
biên (TinyML).

\textbf{Học tăng cường (Gradient Boosting - GB)} là một phương pháp học
có giám sát thuộc nhóm thuật toán tổ hợp (ensemble learning),
trong đó nhiều mô hình yếu (weak learners) - thường là các cây quyết định có độ sâu nông -
được kết hợp theo cách tuần tự để tạo thành một mô hình mạnh hơn \cite{chen2016xgboost}.

Khác với Random Forest - nơi các cây được xây dựng song song và độc lập -
Gradient Boosting xây dựng mô hình theo từng bước lặp (iteration), mỗi cây tiếp
theo được huấn luyện để sửa lỗi còn lại từ mô hình trước đó. Cụ thể, tại mỗi
vòng lặp $t$, mô hình hiện tại $F_t(x)$ được cập nhật bằng cách cộng thêm một
cây mới $h_t(x)$ được huấn luyện để xấp xỉ gradient âm của hàm mất mát:

\begin{equation}
    F_{t+1}(x) = F_t(x) + \gamma h_t(x)
\end{equation}

Trong đó, $\gamma$ là hệ số học (learning rate), điều chỉnh mức đóng góp của
cây mới vào tổng thể mô hình.

Một trong những đặc điểm quan trọng của GB là khả năng \textbf{tối ưu hoá trực
    tiếp một hàm mất mát bất kỳ}, chẳng hạn như hàm log-loss trong bài toán phân
loại, hoặc hàm bình phương sai số (MSE) trong bài toán hồi quy. Nhờ đó, GB
thường đạt độ chính xác rất cao, đặc biệt trên các bài toán với dữ liệu có quan
hệ phi tuyến và có nhiều đặc trưng tương tác phức tạp.

Tuy nhiên, Gradient Boosting cũng có những hạn chế rõ rệt. Do các cây được xây
dựng tuần tự phụ thuộc lẫn nhau, GB thường mất nhiều thời gian huấn luyện hơn
so với Random Forest. Hơn nữa, mô hình nhạy cảm với nhiễu và dữ liệu nhiễu sẽ
dễ dàng bị mô hình "học theo", dẫn đến hiện tượng quá khớp (overfitting) nếu
không áp dụng kỹ thuật regularization hoặc early stopping.

Trong nghiên cứu này, tác giả sử dụng \textbf{GB} để phân loại tư thế ngủ đạt
độ chính xác cao nhất, điều này đúng trên toàn bộ kịch bản thử nghiệm. Tuy
nhiên, do số lượng cây lớn và trọng số tổng thể cao (trên 500~KB), Gradient
Boosting chưa phù hợp để triển khai trực tiếp trên các thiết bị vi điều khiển
hạn chế tài nguyên. Thay vào đó, mô hình này được sử dụng để thiết lập ngưỡng
hiệu năng tham chiếu (baseline) trong môi trường huấn luyện trên máy chủ hoặc
máy tính cá nhân.

\textbf{Mạng nơ-ron nhân tạo (Artificial Neural Network - ANN)} là một
mô hình học sâu mô phỏng cấu trúc hoạt động của hệ thần kinh sinh học,
trong đó các nơ-ron nhân tạo (artificial neurons) được tổ chức thành nhiều
lớp (layers) và kết nối với nhau qua các trọng số (weights) \cite{jain1996}.
Trong nghiên cứu này, tác giả sử dụng kiến trúc \textbf{Multilayer Perceptron (MLP)} -
một loại mạng nơ-ron đơn giản gồm ít nhất ba lớp: lớp đầu vào (input layer),
một hoặc nhiều lớp ẩn (hidden layers) và lớp đầu ra (output layer).

Mỗi nơ-ron trong lớp ẩn thực hiện một tổ hợp tuyến tính giữa các đầu vào, sau
đó áp dụng một hàm kích hoạt phi tuyến như hàm ReLU (Rectified Linear Unit):

\begin{equation}
    f(x) = \max(0, x)
\end{equation}

Đầu ra của mạng được tính thông qua lan truyền tiến (forward propagation),
và mô hình được huấn luyện bằng cách tối thiểu hóa một hàm mất mát
(loss function), chẳng hạn như hàm binary cross-entropy trong phân
loại nhị phân, thông qua thuật toán lan truyền ngược (backpropagation) và
phương pháp tối ưu như \texttt{Adam} hoặc \texttt{SGD}.

Ưu điểm chính của mạng nơ-ron là khả năng học các quan hệ phi tuyến
phức tạp và tự động trích xuất đặc trưng từ dữ liệu. Khác với các mô
hình tuyến tính như LR hoặc SVM, ANN có thể biểu diễn các ranh giới
phân lớp không tuyến tính và phù hợp với các bài toán tín hiệu cảm
biến có nhiễu, biến đổi theo thời gian hoặc không gian.

Tuy nhiên, ANN cũng tồn tại nhiều thách thức trong thực tế triển khai: 01) Lựa
chọn tham số 02) Yêu cầu tính toán cao 03) Khó giải thích: ANN hoạt động như
một hộp đen, khó hiểu về mặt trực quan so với cây quyết định hoặc hồi quy
logistic.

Trong đề tài này, tác giả sử dụng một kiến trúc MLP đơn giản gồm hai lớp ẩn với
số lượng nơ-ron tương đối nhỏ $(8, 4)$ và hàm kích hoạt ReLU, được huấn luyện
bằng thuật toán tối ưu \texttt{Adam} với tốc độ học ban đầu là $0.01$.

\textbf{Convolutional Neural Network (CNN)} là một mô hình học sâu được
thiết kế chuyên biệt để xử lý các loại dữ liệu có cấu trúc lưới,
chẳng hạn như ảnh hai chiều hoặc tín hiệu chuỗi thời gian một chiều.
Không giống như mạng neural truyền thống, CNN sử dụng phép tích chập
để trích xuất tự động các đặc trưng cục bộ trong dữ liệu, từ đó giảm
thiểu đáng kể nhu cầu tiền xử lý và cải thiện hiệu quả học biểu diễn
\cite{lecun2015deep}.

Một kiến trúc CNN điển hình bao gồm các tầng tích chập (convolutional layers),
tiếp theo là các hàm kích hoạt phi tuyến như ReLU và các tầng giảm mẫu (pooling
layers). Sau các tầng này, các đặc trưng được đưa vào một hoặc nhiều tầng kết
nối đầy đủ (fully connected layers) để thực hiện phân loại. Quá trình này cho
phép CNN học được cả đặc trưng cục bộ lẫn toàn cục trong tín hiệu đầu vào.

Tuy nhiên, trong khuôn khổ của nghiên cứu này, mục tiêu chính không chỉ là đạt
độ chính xác tối đa mà còn là đánh giá ảnh hưởng của các đặc trưng (features)
trên miền thời gian và miền tần số đối với hiệu suất của mô hình học máy nên
tác giả quyết định chọn LR, SVM, RF, GB, NN để tiến hành thử nghiệm. Để thực
hiện điều đó, tác giả xây dựng tám kịch bản khác nhau tương ứng với các tổ hợp
đặc trưng và kích thước cửa sổ khác nhau. Việc huấn luyện và đánh giá trên
nhiều kịch bản đòi hỏi một mô hình đủ linh hoạt, dễ kiểm soát về kích thước và
thời gian huấn luyện.

