Dựa trên các cơ sở lý thuyết tại chương I, trong chương này, luận văn sẽ trình
bày về phương pháp nghiên cứu và phát triển hệ thống thu thập, xử lý và lưu trữ
dữ liệu cảm biến gia tốc. Từ bộ dữ liệu thu thập, sẽ tiến hành trích xuất đặc
trưng, đề xuất mô hình học máy phù hợp và thiết lập các kịch bản để đánh giá
các mô hình đề xuất đó.
\section{Nghiên cứu, phát triển phần cứng }

Trong phần này sẽ có các nội dung bao gồm: nghiên cứu, lựa chọn vi điều khiển
và cảm biến phù hợp; từ đó tiến hành thiết kế sơ đồ mạch, mô phỏng mạch 3D và
hoàn thiện sản phẩm.

\subsection{Vi xử lý}
\label{subsec:vi_xu_ly}

Với sự phát triển vượt bậc và đa dạng của công nghệ thiết kế và chế tạo, có rất
nhiều cấu hình phần cứng được nhiều nhóm tác giả lựa chọn phù hợp với các mục
đích khác nhau. Trong đó, \cite{p_1} các tác giả đã sử dụng máy tính đơn
Raspberry Pi để phát hiện 4 tư thế ngủ với sự lấy nhãn từ video theo dõi người
bệnh trong suốt quá trình lấy mẫu. Tác giả Kwasnicki và cộng sự đã sử dụng bộ
xử lý công suất thấp TI MSP430 và mô-đun RF Chipcon CC2420 cho truyền thông
không dây kết hợp với cảm biến gia tốc ba trục ADXL330, con quay hồi chuyển đạt
được 99.5\% độ chính xác \cite{kwasnicki2018}. Nhóm của tác giả I.Yun đã phát
triển thiết bị theo dõi tư thế ngủ của trẻ nhỏ sử dụng vi xử lý ATmega328P-PU
kết hợp cảm biến gia tốc ADXL335 được đặt trên bụng \cite{p_3}. Trong nghiên
cứu của Abdulsadig và cộng sự, hệ thống thu thập dữ liệu được xây dựng dựa trên
một bo mạch tùy chỉnh tích hợp vi điều khiển nRF5232. Vi điều khiển này đảm
nhiệm đồng thời cả việc lấy mẫu dữ liệu từ cảm biến gia tốc ba trục LIS2DH12
với tần số 100 Hz và truyền dữ liệu không dây theo thời gian thực \cite{
    abdulsadig2023, Sleep_Posture_Detection}. Trong nghiên cứu của tác giả Vũ Hoàng
Diệu, mô-đun ESP32 được lựa chọn làm đơn vị xử lý trung tâm nhờ tích hợp bộ vi
điều khiển hiệu năng cao, kết nối không dây Wi-Fi đáp ứng tốt yêu cầu của hệ
thống thu thập dữ liệu tư thế ngủ theo thời gian thực \cite{vu2023}. Thiết bị
không chỉ cho phép truyền dữ liệu trực tiếp lên máy chủ hoặc nền tảng đám mây
thông qua Wi-Fi, mà còn hỗ trợ lưu trữ cục bộ trên thẻ nhớ microSD, đảm bảo
tính liên tục trong điều kiện mất kết nối mạng.

Qua phân tích các nghiên cứu trên có thể thấy rằng phần lớn các cấu hình phần
cứng có kích thước vẫn còn lớn hoặc gặp giới hạn trong khả năng tích hợp mô
hình học máy tại thiết bị. Vì vậy, trong khuôn khổ luận văn sẽ sử dụng vi điều
khiển nRF52840 làm bộ điều khiển trung tâm \cite{nrf52840} với các lý do sau:

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/nrf52840_feature.png}
    \caption{Các tính năng Nordic nRF52840}
    \label{Nornrf52840_featuredic}
\end{figure}

nRF52840 tích hợp bộ giao thức không dây Bluetooth năng lượng thấp hoạt động ở
băng tần 2.4~GHz và bộ xử lý trung tâm Arm Cortex-M4F chạy ở xung nhịp 64~MHz,
kèm bộ xử lý dấu phẩy động (FPU). Vi xử lý này được trang bị bộ nhớ 1~MB Flash
và 256~kb RAM phù hợp để triển khai các mô hình cho bài toán phân loại tư thế
ngủ. Ngoài khả năng hoạt động trong dải điện áp rộng từ +1.7~V đến +5.5~V
(tương thích với nguồn pin và USB), nRF52840 còn cung cấp các giao tiếp ngoại
vi phong phú: hai giao diện I2C, bốn SPI chủ (master), ba SPI tớ (slave), bốn
kênh điều chế xung (PWM) hỗ trợ EasyDMA, cùng với bộ định thời 32-bit, phù hợp
cho các ứng dụng đòi hỏi xử lý thời gian thực chính xác
Hình~\ref{nrf52840_schematic}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/nrf52840_schematic.png}
    \caption{Sơ đồ khối Nordic NRF52840}
    \label{nrf52840_schematic}
\end{figure}

Đặc biệt, nRF52840 có
một hệ sinh thái phần mềm đi kèm, bao gồm bộ công cụ phát triển (SDK) của Nordic Semiconductor
và nền tảng TensorFlow Lite for Microcontrollers, giúp rút ngắn thời gian phát triển và triển khai hệ
thống TinyML trực tiếp lên chip \cite{Nordic2021_tinyml}.
Hiện nay, nRF52840 cũng tích hợp trong nhiều bộ kit phát triển thương mại,
như Adafruit Circuit Playground Bluefruit,
SparkFun Pro nRF52840 Mini,
Seeed Studio XIAO.
Các bộ kit này cung cấp tài nguyên phần cứng và thư viện mã nguồn mở,
hỗ trợ kết nối BLE, USB, GPIO, SPI, I²C, cùng khả năng lập trình trực
tiếp qua môi trường Arduino IDE, PlatformIO hoặc Zephyr RTOS.
Nhờ đó, nRF52840 càng trở nên phổ biến trong các nghiên cứu và dự án về IoT,
thiết bị đeo thông minh và học máy tại biên.

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[height=4cm]{images/Seeed.jpg}
        \caption*{(a) Seeed Studio XIAO
        }
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[height=4cm]{images/adafruit.jpg}
        \caption*{(b) Adafruit Circuit Playground Bluefruit}
    \end{minipage}
    \caption{Một số bộ kit phát triển dựa trên vi điều khiển Nordic nRF52840}
    \label{fig:nrf52840_devkits}
\end{figure}

% Kiến trúc ARM có nhiều dòng vi xử lý khác nhau, được phát triển và nâng cấp
% liên tục nhằm đáp ứng nhu cầu đa dạng trong lĩnh vực công nghệ nhúng. Trong đó,
% dòng Cortex-M thuộc kiến trúc ARMv7 đã trở thành nền tảng phổ biến cho các hệ
% thống nhúng sử dụng vi điều khiển nhờ vào hiệu suất cao, khả năng mở rộng và
% mức tiêu thụ năng lượng tối ưu. Dòng Cortex-M bao gồm nhiều phiên bản như
% Cortex-M0, Cortex-M0+, Cortex-M1, Cortex-M3, Cortex-M4 và Cortex-M7, mỗi phiên
% bản được thiết kế để phục vụ cho các mức độ yêu cầu hiệu năng khác nhau
% \cite{arm_cortex_m_comparison}. Các vi xử lý thuộc họ Cortex-M chủ yếu được ứng
% dụng trong các hệ thống nhúng thời gian thực, nơi yêu cầu sự cân bằng giữa hiệu
% suất xử lý, tiêu thụ năng lượng và chi phí. Một số vi xử lý ARM khác, không
% thuộc họ Cortex-M, được sử dụng trong các thiết bị hiệu suất cao như điện thoại
% thông minh và máy tính bảng, vốn yêu cầu cấu hình phần cứng mạnh hơn và khả
% năng xử lý đa tác vụ cao hơn. Theo tài liệu \cite{cortexM4}, vi xử lý Cortex-M4
% là một bộ xử lý 32-bit sử dụng kiến trúc tập lệnh rút gọn (RISC), được xây dựng
% theo kiến trúc Harvard, trong đó bus dữ liệu và bus lệnh được tách biệt nhằm
% tối ưu hiệu suất truy xuất bộ nhớ. Vi xử lý này hỗ trợ đầy đủ cả tập lệnh
% Thumb-1 (16-bit) và Thumb-2 (hỗn hợp 16/32-bit), mang lại sự linh hoạt trong mã
% hóa lệnh và tiết kiệm không gian bộ nhớ chương trình.

% Về hiệu năng, Cortex-M4 đạt từ 1,25 đến 1,95 DMIPS/MHz (Dhrystone Million
% Instructions Per Second per MHz), cho thấy khả năng xử lý hiệu quả trong các
% ứng dụng nhúng yêu cầu độ chính xác và độ phản hồi thời gian thực cao. Bên cạnh
% đó, vi xử lý hỗ trợ tối đa 240 tín hiệu ngắt, bao gồm cả ngắt không thể bị chặn
% (Non-Maskable Interrupts - NMI), cùng khả năng cấu hình từ 8 đến 256 mức ưu
% tiên ngắt, giúp hệ thống hoạt động ổn định trong môi trường có nhiều sự kiện
% cạnh tranh đồng thời. Ngoài ra, hiện nay ứng dụng trí tuệ nhân tạo (AI) tại
% thiết bị biên (Edge AI) đang ngày càng phổ biến, đặc biệt trong các lĩnh vực
% như nhà thông minh, thiết bị đeo, giám sát an ninh và công nghiệp 4.0. Với khả
% năng xử lý tín hiệu số (DSP) và hỗ trợ các mạng nơ-ron nhỏ gọn, các vi xử lý
% Cortex-M, đặc biệt là dòng Cortex-M4, đang được khai thác để triển khai các mô
% hình học sâu nhẹ (tinyML) ngay trên vi điều khiển
% \cite{electronics11162545}\cite{applicationCortexM4}.

% \begin{figure}[htbp]
%     \centering
%     \includegraphics[width=0.8\textwidth]{images/cortexM4.png}
%     \caption{Thành phần chính của vi điều khiển Cortex-M4}
%     \label{cortexM4}
% \end{figure}

% Kết nối bus được mô tả trong Hình~\ref{cortexM4} cho phép truyền dữ liệu đồng
% thời trên nhiều bus khác nhau, đồng thời cung cấp khả năng quản lý truyền dữ
% liệu hiệu quả, chẳng hạn như sử dụng bộ đệm ghi và điều khiển hướng bit hoạt
% động (bit-banding). Hệ thống cũng có thể bao gồm các cầu bus (bus bridges) nhằm
% kết nối nhiều loại bus vào một mạng duy nhất sử dụng chung không gian bộ nhớ.
% Ngoài ra, bộ xử lý được trang bị hệ thống hỗ trợ gỡ lỗi tích hợp, bao gồm khả
% năng kiểm soát gỡ lỗi, thiết lập điểm ngắt (breakpoint) chương trình và điểm
% theo dõi dữ liệu (watchpoint). Khi xảy ra sự kiện gỡ lỗi, hệ thống có thể tạm
% dừng trạng thái hoạt động của lõi xử lý để phục vụ việc phân tích và xử lý lỗi.

% Bên cạnh đó, kiến trúc Cortex-M4 tích hợp Bộ điều khiển ngắt vectored lồng nhau
% (Nested Vectored Interrupt Controller - NVIC) với khả năng hỗ trợ lên đến 240
% tín hiệu yêu cầu ngắt, bao gồm cả ngắt không chắn được (NMI). NVIC hỗ trợ xử lý
% ngắt lồng nhau một cách tự động bằng cách so sánh mức ưu tiên giữa các yêu cầu
% ngắt với mức ưu tiên hiện tại đang được xử lý.

% Đối với các ứng dụng yêu cầu tiết kiệm năng lượng, hệ thống còn được trang bị bộ đánh thức ngắt (Wake-up Interrupt Controller - WIC), cho phép đưa bộ vi điều khiển vào chế độ nghỉ bằng cách tắt hầu hết các thành phần không cần thiết, đồng thời duy trì khả năng đánh thức hệ thống khi phát hiện một yêu cầu ngắt. Ngoài ra, cơ chế bảo vệ bộ nhớ cũng được tích hợp nhằm đảm bảo an toàn cho hệ thống, ví dụ như chỉ cho phép truy cập đọc tại một số vùng bộ nhớ hoặc ngăn người dùng truy cập vào các vùng dữ liệu đặc quyền của hệ điều hành hoặc ứng dụng hệ thống.

\subsection{Cảm biến}
\label{subsec:cam_bien}

Trong quá trình ngủ, các chuyển động thân thể chủ yếu là chuyển động chậm, với
biên độ nhỏ và ít mang tính đột ngột \cite{Wang2018_slidingwindow}. Trong giai
đoạn ngủ REM, cơ thể gần như bất động. Do đó, việc ghi nhận chính xác các thay
đổi tư thế ngủ đòi hỏi cảm biến có độ nhạy cao. Như đã trình bày trong Chương
I, các cảm biến gia tốc MEMS kiểu điện dung hiện đang được ứng dụng rộng rãi
trong giám sát tư thế và chuyển động khi ngủ nhờ vào đặc điểm nổi bật là tần số
lấy mẫu phù hợp và đặc biệt là độ nhạy cao với mọi loại chuyển động.

Sau khi đã khảo sát, cảm biến gia tốc Bosch BMI270 được lựa chọn cho hệ thống
nhận diện tư thế ngủ với các lý do sau:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth, keepaspectratio]{images/BMi270.png}
    \caption{Bosch BMI270}
    \label{Bosch_BMI270}
\end{figure}

Thứ nhất, độ chính xác và dải đo linh hoạt: BMI270 tích hợp cảm biến gia tốc ba
trục độ phân giải cao 16-bit với các dải đo linh hoạt ±2g, ±4g, ±8g và ±16g,
cho phép ghi nhận chính xác cả chuyển động chậm và biên độ nhỏ trong khi ngủ.

Thứ hai, mức tiêu thụ năng lượng thấp và khả năng hoạt động ổn định: cảm biến
tiêu thụ trung bình chỉ khoảng 685 µA khi hoạt động bình thường, đồng thời được
trang bị bộ quản lý năng lượng tích hợp hỗ trợ nhiều chế độ tiết kiệm điện khác
nhau. Điều này cho phép thiết bị hoạt động lâu dài trên nền tảng phần cứng công
suất thấp mà không ảnh hưởng đến hiệu năng đo.

Thứ ba, tốc độ lấy mẫu và thời gian đáp ứng nhanh: BMI270 hỗ trợ tốc độ lấy mẫu
(ODR) từ 0.7~Hz đến~1.6 kHz cho cảm biến gia tốc, phù hợp bài toán phân loại
giấc ngủ yêu cầu tần số lấy mẫu thấp (10~Hz).

\begin{figure}[]
    \centering
    \includegraphics[width=0.75\textwidth, keepaspectratio]{images/bmi270_block.png}
    \caption{Sơ đồ khối Bosch BMI270}
    \label{bmi270_block}
\end{figure}

Thứ tư, khả năng chống nhiễu và hiệu chuẩn tự động: cảm biến có cơ chế bù sai
số và bù độ nhạy theo thời gian thực, giúp giảm sai lệch khi hoạt động lâu dài.
Tính năng bù sai lệch cho cảm biến gia tốc đảm bảo độ ổn định cao của dữ liệu
đo. Ngoài ra, cảm biến còn tích hợp thêm bộ lọc thông thấp
Hình~\ref{bmi270_block}.

Cuối cùng, tích hợp tính năng thông minh được lập trình trong các thanh ghi
riêng được Google chứng nhận tương thích với hệ điều hành Wear OS và hỗ trợ
phát hiện chuyển động tự động: BMI270 có khả năng phát hiện các trạng thái như
phát hiện có chuyển động (any motion), không có chuyển động (no motion) hoặc di
chuyển các thiết bị đeo ở cổ tay (wrist wear wakeup). Các tính năng này có thể
được tận dụng để giảm tải tính toán cho bộ vi điều khiển, chỉ kích hoạt mô hình
học máy khi có thay đổi tư thế đáng kể, qua đó tiết kiệm năng lượng và tăng
tuổi thọ pin.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth, keepaspectratio]{images/bmi270_pin.png}
    \vspace*{-5mm}
    \caption{Sơ đồ chân Bosch BMI270}
    \label{bmi270_pin}
\end{figure}

\subsection{Bluetooth năng lượng thấp}

Các công nghệ truyền thông không dây khác đều bộc lộ những hạn chế đối với
thiết bị phân loại tư thế ngủ. Wi-Fi, có ưu thế về băng thông, lại tiêu thụ
năng lượng cao và phụ thuộc vào internet. Bluetooth cổ điển, vốn được thiết kế
cho các ứng dụng truyền tải dữ liệu dung lượng lớn như âm thanh, cũng đòi hỏi
năng lượng cao hơn so với BLE. ZigBee, hiệu quả trong các mạng cảm biến nhà
thông minh nhờ cấu trúc lưới, lại thiếu sự hỗ trợ trên điện thoại và đòi hỏi
gateway riêng. Với mục tiêu tối ưu hóa năng lượng và đảm bảo khả năng hoạt động
lâu dài cho thiết bị đeo sử dụng pin, BLE được lựa chọn làm chuẩn kết nối không
dây chính trong hệ thống phần cứng. So với các giao thức khác, BLE tỏ ra vượt
trội nhờ mức tiêu thụ năng lượng rất thấp, tốc độ khởi tạo kết nối nhanh và khả
năng tương thích rộng rãi với hầu hết các thiết bị di động hiện nay
\cite{BLE_compare}.

Ngoài ra, BLE còn được hỗ trợ trên vi điều khiển nRF52840 đã chọn ở phần trên.
Nhờ sự kết hợp này, hệ thống có thể duy trì khả năng truyền dữ liệu ổn định,
tiết kiệm năng lượng, và đáp ứng tốt yêu cầu hoạt động liên tục trong quá trình
giám sát tư thế ngủ.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ble.png}
    \caption{Các kiểu kết nối không dây trong họ chip nRF52}
    \label{ble}
\end{figure}

\subsubsection*{Các thành phần, chức năng}

BLE là giao thức kết nối không dây được thiết kế chuyên biệt cho các ứng dụng
năng lượng thấp, hoạt động ở băng tần ISM 2.4~GHz, hỗ trợ thông lượng ứng dụng
lên đến 1.4 Mbps \cite{BluetoothSIG2019_Core5}. BLE hiện được hỗ trợ phổ biến
trên hầu hết các hệ điều hành như iOS, Android, macOS, Windows và Linux, cũng
như trong các thiết bị di động hiện đại.

Về mặt bảo mật, BLE tích hợp các cơ chế mã hóa và xác thực nhằm đảm bảo tính bí
mật, toàn vẹn của dữ liệu. Bluetooth 5 là bước phát triển đột phá tiếp theo kể
từ khi BLE được giới thiệu trong chuẩn Bluetooth 4.0, mang đến hàng loạt cải
tiến đáng kể giúp mở rộng phạm vi ứng dụng và nâng cao hiệu suất hệ thống. Quan
trọng hơn, chế độ này còn giúp giảm đáng kể mức tiêu thụ năng lượng \cite{BLE}.
Đặc biệt, chế độ Long Range mở rộng đáng kể phạm vi truyền thông của BLE, cho
phép các thiết bị duy trì kết nối trong toàn bộ không gian trong nhà.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{images/gatt.drawio.png}
    \caption{Cấu trúc của GATT}
    \label{gatt}
\end{figure}

BLE tổ chức logic giao tiếp dựa trên mô hình hồ sơ thuộc tính tổng quá
\gls{gatt}. GATT quy định cách hai thiết bị BLE trao đổi dữ liệu thông qua các
đơn vị logic: dịch vụ (services) và đặc tính (characteristics). Giao thức nền
tảng là Attribute Protocol (ATT). Mỗi dịch vụ, đặc tính được định danh bằng mã
định danh duy nhất (UUID) 16-bit hoặc 128-bit, với quyền truy cập như chỉ đọc,
chỉ ghi, hoặc hỗ trợ thông báo. Trong mô hình GATT là tính kết nối độc quyền:
tại một thời điểm, thiết bị ngoại vi chỉ có thể duy trì một kết nối duy nhất
với thiết bị trung tâm. Khi kết nối được thiết lập, thiết bị ngừng quảng cáo,
điều này hạn chế khả năng kết nối đồng thời từ nhiều thiết bị.

Ngoài ra, một điểm sáng nữa là Bluetooth Mesh, cho phép thiết lập mạng lưới
nhiều nút. Mỗi nút trong mạng có thể đóng vai trò chuyển tiếp, cho phép dữ liệu
lan truyền đến các vùng rộng hơn theo mô hình phân tán. Điều này phù hợp với
các ứng dụng IoT quy mô đa cảm biến đặt tại nhiều nơi khác nhau.

\subsection{Thiết kế mạch}

Sau khi đã lựa chọn được vi điều khiển, cảm biến của hệ thống phần cứng phân
loại tư thế ngủ. Trong phần này, luận văn sẽ trình bày về thiết kế sơ đồ nguyên
lý cho mạch thông qua những câu hỏi: Các thành phần trong cần thiết để phục vụ
cho bài toán phân loại tư thế ngủ là gì? Chúng được kết nối với nhau như thế
nào? và chi tiết từng thành phần đó là gì?

Để đảm bảo các yêu cầu đặt ra, hệ thống cần
các thành phần sau: 01) Khối điều khiển: có chức năng xử lý toàn bộ logic trong
mạch, kết nối được với các thiết bị khác như điện thoại thông qua BLE và đặc
biệt, đủ hiệu năng để triển khai các mô hình học máy; 02) Khối cảm biến: có
nhiệm vụ thu thập dữ liệu sinh lý bao gồm 2 cảm biến chính là gia tốc (đã được
trình bày các phần trên) và thêm cảm biến âm thanh để phục vụ bài toán xác định
tiếng ngáy của nhóm; 03) Khối nguồn: có nhiệm vụ ổn áp về đúng dải điện áp
tương thích, lọc nhiễu, bảo vệ dòng; 04) Khối nạp và gỡ lỗi: có nhiệm vụ nạp mã
chương trình vào vi điều khiển; 05) Khối hiển thị: có nhiệm vụ đưa ra thông báo
khi có phát hiện bất thường. Kích thước của mạch là hình tròn, có đường kính
không quá 4~cm. Đây chính là những đầu mục tiên quyết để coi là đạt được mục
tiêu trong phần này.

\subsubsection{Khối điều khiển}

Với yêu cầu quan trọng đối điều khiển thì vi điều khiển nRF52840 được chọn hoàn
toàn có thể đáp ứng các tiêu trí đã nêu trong phần~\ref{subsec:vi_xu_ly} để làm
vi điều khiển của mạch. Tuy nhiên để đáp ứng đủ các yêu cầu của khối điều khiển
thì vẫn đang thiếu các thành phần như khối thu phát tín hiệu vô tuyến bao gồm
ăng ten, mạch phối hợp trở khánh, bộ dao động tinh thể và bộ đếm định thời nhằm
duy trì hoạt động ổn định trong các chế độ năng lượng thấp.

Sau khi tìm hiểu, trong khuôn khổ luận văn sẽ sử dụng module U-blox NINA-B306
để đảm nhiệm các nhiệm vụ của khối điều khiển \cite{uBlox2019_NINA_B3}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/ninab306_block.png}
    \caption{Sơ đồ khối U-blox NINA-B306}
    \label{ninab306_block}
\end{figure}

Mô-đun NINA-B306 được phát triển dựa trên vi điều khiển Nordic nRF52840, tích
hợp ăng-ten PCB nội bộ được cấp phép từ Abracon ngay trên bảng mạch của mô-đun
Hình~\ref{ninab306_block}. Ngoài ra, NINA-B306 được thiết kế với dải điện áp
hoạt động chuẩn hóa từ 1.7 V đến 3.6 V, thấp hơn so với giới hạn tối đa 5.5 V
của vi điều khiển nRF52840, nhằm tối ưu hiệu suất năng lượng.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/ninab306_pin.png}
    \caption{Sơ đồ chân U-blox NINA-B306}
    \label{ninab306_pin}
\end{figure}

Sơ đồ chân thể hiện cấu trúc bố trí tối ưu với hơn 50 chân GPIO đa chức năng,
bao gồm các kênh analog, các đường truyền debug (SWD, TRACE) và các chân nguồn
được phân bố đối xứng, góp phần tăng cường độ ổn định tín hiệu và giảm nhiễu
điện từ Hình~\ref{ninab306_pin}.

\subsubsection{Khối cảm biến}
Như đã đề cập chi tiết ở phần~\ref{subsec:cam_bien}, cảm biến gia tốc Bosch
BMI270 được lựa chọn để thu thập tín hiệu gia tốc cho bài toán phân loại tư thế
ngủ. Ngoài ra, việc hướng tới việc xác định chứng ngưng thở khi ngủ OSA thì
nhóm có bổ sung thêm cảm biến âm thanh STMicroelectronics MP34DT06J. Cảm biến
MP34DT06J là microphone MEMS kỹ thuật số định hướng đa hướng có kích thước siêu
nhỏ gọn và tiêu thụ năng lượng thấp. Ngoài ra, MP34DT06J là cảm biến số có tỷ
lệ tín hiệu trên nhiễu (SNR) 64 dB và độ nhạy -26 dBFS ± 1 dB, đảm bảo chất
lượng thu âm ổn định. Thiết bị được đóng gói theo chuẩn SMD top-port và được
đảm bảo hoạt động ổn định trong dải nhiệt độ mở rộng từ -40 °C đến +85 °C và
kèm thêm điện áp đầu vào 1.8V hoàn toàn phù hợp với các thông số của vi điều
khiển. Tuy nhiên, trong khuôn khổ luận văn này sẽ không đề cập sâu vào cảm biến
này để tập trung tối đa vào dữ liệu cảm biến gia tốc cho bài toán phân loại tư
thế ngủ.

\subsubsection{Khối nguồn, nạp và gỡ lỗi, hiển thị}
Ba khối chức năng này được thiết kế nhằm đảm bảo sự ổn định và khả năng vận
hành tin cậy của toàn bộ hệ thống phần cứng. Đối với khối nguồn, hệ thống được
xác định có hai nguồn cung cấp chính gồm nguồn từ cổng USB và nguồn từ pin
Li-Polymer. Điện áp đầu vào của toàn mạch được xác định ở mức 3.3 V để tương
thích với các linh kiện và vi điều khiển. Ngoài ra, luận văn sử dụng một bộ
chuyển đổi hạ áp (step-down converter) tích hợp mạch điều khiển MP2322GQH để ổn
định nguồn đầu vào tại 3.3 V Hình~\ref{fig:MP2322GQH}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/MP2322GQH.png}
    \caption{Sơ đồ khối IC MP2322GQH, dải đầu vào 3~V - 22~V, dòng tải tối đa 1~A, hiệu suất cao, tần số chuyển mạch 1.25~MHz}
    \label{fig:MP2322GQH}
\end{figure}

Bên cạnh đó, nguồn USB còn được bổ sung các thành phần hỗ trợ như diode bảo vệ
ngược dòng, tụ lọc nhiễu cao tần và bù tín hiệu, cùng điện trở xả tĩnh điện,
nhằm đảm bảo an toàn và giảm nhiễu điện từ trong quá trình vận hành.

Đối với khối hiển thị, hệ thống sử dụng bốn đèn LED khác màu bố trí tại rìa của mạch, có nhiệm vụ thông báo kết quả tư thế được phân loại, trạng thái hoạt động của hệ thống như nguồn, kết nối, truyền dữ liệu hoặc lỗi, giúp người dùng và kỹ sư dễ dàng theo dõi tình trạng thiết bị.

Với khối nạp và gỡ lỗi, hai phương thức chính để nạp bao gồm: (1) Qua Serial
Wire Debug (SWD); (2) Cơ chế Bootloader thông qua kết nối USB. Sự kết hợp này
giúp nâng cao tính linh hoạt và khả năng mở rộng trong quá trình phát triển
phần mềm, đồng thời giảm thiểu thời gian thử nghiệm.

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/schematic.png}
    \caption{Sơ đồ mạch}
    \label{fig:schematic}
\end{figure}

\subsubsection{Sơ đồ mạch}

Sau khi xác định các linh kiện, các yêu cầu về điện áp, kiểu dữ liệu đầu vào,
đầu ra của các thành phần kể trên, sơ đồ mạch sẽ được xây dựng thông qua phần
mềm Altium Designer. Mạch được thiết kế hình tròn kích thước đường kính 3~cm,
2~lớp đúng với định hướng của nhóm. Kết quả được thể hiện tại
Hình~\ref{fig:schematic}

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/pcd_dong_top.png}
        \label{fig:pcb_dong_top}
        \caption{lớp trên}

    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/pcb_dong_bottom.png}
        \label{fig:pcb_dong_bottom}
        \caption{lớp dưới}

    \end{subfigure}
    \caption{Bố trí mạch in hai mặt của bo mạch}
    \label{fig:pcb_dong}
\end{figure}

Sau khi hoàn thiện thiết kế, công đoạn tiếp theo là thực hiện hàn, lắp các linh
kiện theo sơ đồ mạch, và tiến hành kiểm tra hoạt động của các khối chức năng
trên bo mạch để đánh giá tính ổn định và độ tin cậy của hệ thống.

\begin{figure}
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/pcb_3d_top.png}
        \caption{lớp trên}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.5\textwidth]{images/pcb_3d_bottom.png}
        \caption{lớp dưới}

    \end{subfigure}
    \caption{Mô hình mạch 3D}
    \label{fig:pcb_3d}
\end{figure}

\newpage

\section{Hệ thống phần mềm}
Phần này trình bày tổng quan kiến trúc hệ thống phần mềm bao gồm: lập trình
phần cứng để đọc giá trị cảm biến, cấu hình BLE; phát triển ứng dụng di động
làm cầu nối giữa phần cứng và hệ thống đám mây, cùng với máy chủ và cơ sở dữ
liệu lưu trữ dữ liệu. Nội dung cũng đề cập đến các yêu cầu chức năng, phi chức
năng và thiết kế hệ thống ở mức cao nhằm đảm bảo khả năng triển khai thực tế và
mở rộng trong tương lai.

\subsection{Lập trình phần cứng}

Ở bước này, nhóm ưu tiên lập trình phần cứng bằng cách sử dụng các framework và thư viện do hãng cung cấp.
Cách tiếp cận này cho phép khai thác hầu hết các phương thức tương tác với phần cứng, cộng đồng hỗ trợ lớn đồng thời giúp rút ngắn đáng kể thời gian phát triển và giảm thiểu sai sót trong quá trình lập trình.
Tuy nhiên, để có thể kiểm soát toàn diện các chức năng của hệ thống cũng như tối ưu hóa mức tiêu thụ năng lượng, trong tương lai sẽ chuyển sang phương pháp lập trình ở mức thấp.

\subsubsection{Cấu hình vi xử lý và cảm biến}
Bước đầu tiên, nạp Bootloader của Arduino Nano vào vi điều khiển bằng giao thức
Serial Wire Debug (SWD). Điều này cho phép thiết lập môi trường lập trình ban
đầu và hỗ trợ việc tải chương trình trực tiếp từ máy tính thông qua cổng USB.

Việc đọc các giá trị cảm biến thông qua thư viện SparkFun BMI270 Arduino
Library \cite{SparkFun_BMI270_Library}. Đây là thư viện mã nguồn mở do SparkFun
phát triển đóng vai trò như một lớp trừu tượng, cho phép vi điều khiển giao
tiếp trực tiếp với cảm biến Bosch BMI270. Thư viện cung cấp đầy đủ các hàm để
cấu hình dải đo, tần số lẫy mẫu và chế độ năng lượng tiêu thụ.

\input{chapters/examples/cauhinh_accelerometer.tex}

Phần cấu hình được thể hiện trong mã nguồn~\ref{lst:cauhinh_accelerometer}.
Việc gọi hàm \texttt{imu.beginI2C()} nhằm thiết lập kênh truyền
I\textsuperscript{2}C và xác nhận sự hiện diện của thiết bị. Tần số lấy mẫu
được đặt ở 12.5 Hz và dải đo ở mức ±2g nhằm tối ưu độ phân giải cho các dao
động nhỏ khi ngủ ở người. Việc thiết lập cấu hình qua hàm \texttt{setConfig()}
và xác thực lại bằng \texttt{getConfig()} thể hiện nguyên tắc kiểm chứng hai
chiều nhằm chắc chắn các cấu hình đã được đặt trên phần cứng.

\subsubsection{Cấu hình BLE}

Quá trình khởi tạo, kết nối và truyền lên thiết bị trung tâm bao gồm các bước
sau: tạo bản tin quảng bá (advertising), thiết lập cơ chế kết nối/ngắt kết nối,
cũng như định nghĩa UUID của dịch vụ và đặc tính theo mô hình \gls{gatt}.

\input{chapters/examples/cauhinh_ble.tex}

\usetikzlibrary{positioning}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
            every node/.style={font=\footnotesize, align=center},
            process/.style={rectangle, draw, rounded corners,
                    minimum width=4cm, minimum height=1cm,
                    fill=blue!10, inner sep=5pt},
            arrow/.style={->, thick}
        ]
        \matrix[column sep=0mm, row sep=0.7cm] {
            \node[process] (init) {Khởi tạo BLE \& BMI270};                                                \\
            \node[process] (config) {Cấu hình cảm biến \\ ODR = 12.5 Hz, Range = $\pm$2g}; \\
            \node[process] (connect) {Kết nối thiết bị trung tâm qua BLE};                                 \\
            \node[process] (send) {Đọc \& gửi dữ liệu $x$, $y$, $z$};       \\
            \node[process] (loop) {Lặp chu kỳ 100 ms};                                                     \\
        };

        \foreach \i/\j in {init/config, config/connect, connect/send, send/loop}
        \draw[arrow] (\i) -- (\j);
    \end{tikzpicture}
    \caption{Sơ đồ tóm tắt quy trình hoạt động BLE-BMI270 của đoạn mã nguồn~\ref{lst:ble_bmi270}}
    \label{fig:ble_bmi270_shortflow}
\end{figure}

Thứ nhất, khởi tạo BLE, kích hoạt truyền thông BLE với tên hiển thị là
Master\_2025\_BLE, thiết lập cấu trúc dịch vụ GATT với hai UUID cho service và
characteristic. Trong đó characteristic được phép đọc, ghi và phát tín hiệu.

Thứ hai, khởi tạo cảm biến BMI270 và cấu hình.

Thứ ba, tạo kết nối với thiết bị trung tâm, khi tín hiệu quảng bá được phản
hồi. Sau khi kết nối thành công, phần cứng lấy được thông tin của thiết bị
trung tâm ở đây là ứng dụng điện thoại. Đây một bước xác thực cần thiết để chỉ
cho phép thiết bị trung tâm nào được lập trình sẵn.

Thứ tư, thu nhận dữ liệu cảm biến ba trục (x, y, z) từ BMI270. Các giá trị gia
tốc được đọc và chuẩn hóa trước khi truyền. Việc chuẩn hóa ở đây gồm tách dấu
và phần nguyên - phần thập phân để giảm kích thước gói tin mà vẫn đảm bảo độ
chính xác khi tái lập lại.

Cuối cùng, truyền dữ liệu định dạng byte qua BLE thông qua characteristic đã
định nghĩa. Mỗi gói tin gồm 9 byte chứa đầy đủ thông tin về hướng và biên độ
gia tốc trên ba trục, được gửi chu kỳ 100 ms, bảo đảm tốc độ lấy mẫu ổn định
(10 Hz) phục vụ phân tích tư thế trong thời gian thực.

Việc chuẩn hóa 5 giai đoạn này có ưu điểm có thể bóc tách cho mục đích khác
nhau, tối ưu cho từng giai đoạn, đảm bảo code mạch lạc và dễ bảo trì.

\subsubsection{Lọc nhiễu bằng bộ lọc Kalman}

Trong phần phân tích các bộ lọc cũng như từ thực nghiệm nhận thấy, khi có những
chuyển động đột ngột gia tốc cao có thể gây ra sai lệnh giá trị cảm biến.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\textwidth]{images/z_kalman.png}
    \caption{So sánh tín hiệu trục Z trước và sau lọc Kalman}
    \label{fig:z_kalman}
\end{figure}

Hình~\ref{fig:z_kalman} trình bày so sánh tín hiệu gia tốc thu được trên trục Z
giữa hai trạng thái: dữ liệu thô và dữ liệu sau khi qua bộ lọc Kalman. Có thể
quan sát thấy, trong vùng được khoanh tròn, tín hiệu thô (đường màu xanh) xuất
hiện một giá trị đột biến âm với biên độ lớn, thể hiện hiện tượng trôi tín hiệu
tạm thời do nhiễu cảm biến hoặc rung động ngoài mong muốn.

Sau khi áp dụng bộ lọc Kalman, đường tín hiệu (đường màu cam) trở nên mượt hơn
và ổn định, đồng thời loại bỏ được phần lớn sai lệch ngắn hạn. Kết quả này
chứng tỏ bộ lọc Kalman không chỉ thực hiện vai trò giảm nhiễu mà còn có khả
năng ước lượng trạng thái thật của hệ thống thông qua mô hình dự đoán - cập
nhật liên tục. Việc lọc này đặc biệt quan trọng trong bối cảnh dữ liệu thu từ
cảm biến gia tốc dùng cho nhận diện tư thế ngủ, bởi vì sai số đột biến dù chỉ
trong một khoảng ngắn cũng có thể dẫn đến phân loại sai tư thế trong mô hình
học máy.

Ngoài ra, vùng sai lệch này cũng cho thấy hạn chế của tín hiệu thô khi cảm biến
được gắn trên cơ thể người, nơi dao động nhỏ do hô hấp, chuyển động tự nhiên
hoặc thay đổi điểm đặt có thể gây ra nhiễu. Việc sử dụng Kalman giúp hiệu
chỉnh, đảm bảo giá trị đo được bám sát quỹ đạo thật của chuyển động. Một vấn đề
là bộ lọc Kalman có thể làm giảm giá trị biên tại các đỉnh. Tuy nhiên, vấn đề
này được nhận định là không ảnh hưởng nhiều đến toàn bộ bài toán phân loại tư
thế ngủ. Lý do là vì bộ đặc trưng không sử dụng trực tiếp các giá trị đỉnh này
mà là một cửa sổ mẫu và các thống kê trong cửa sổ đó.

\subsection{Phần mềm thu thập, lưu trữ}

Phần mềm trong nghiên cứu này không chỉ đơn thuần là công cụ trực quan hoá dữ
liệu cảm biến, mà còn được thiết kế như một mắt xích trọng yếu trong toàn bộ
quy trình từ thu thập, truyền tải, lưu trữ, cho đến huấn luyện và triển khai mô
hình học máy. Cách tiếp cận này đảm bảo rằng dữ liệu thu nhận từ môi trường
thực tế được xử lý nhất quán, có khả năng tái sử dụng và dễ dàng tích hợp với
các hệ thống khác.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/architecture_software.png}
    \caption{Kiến trúc tổng thể của hệ thống}
    \label{fig:architecture_software}
\end{figure}
Hình~\ref{fig:architecture_software} mô tả tổng quan các thành phần cần thiết trong luận văn và kết nối giữa chúng.
Để đưa ra kết quả phân loại tư thế ngủ dữ liệu từ cảm biến có thể có 2 hướng đi. Thứ nhất, dữ liệu từ cảm biến thông qua vi điều khiển đẩy lên ứng dụng di động
sau đó được lưu trữ hoặc được suy luận trên máy chủ đám mây rồi trả về kết quả tại ứng dụng di động.
Thứ hai. dữ liệu từ cảm biến sau khi được đọc từ vi điều khiển thì
được suy luận ngay tại biên và hiển thị kết quả thông qua các chỉ báo đèn led.
Cả 2 cách đều được nghiên cứu và triển khai trong luận văn này.

\subsubsection{Ứng dụng di dộng}
Được coi như một cổng kết nối trong điện toán đám mây
có nhiệm vụ gom các tín hiệu từ cảm biến gia tốc hoặc có thể mở
rộng đa cảm biến khác, hiển thị chúng theo thời gian thực và chuyển
lên máy chủ đám mây.
Dựa trên yêu cầu bài toán, xác định được các yêu cầu của phần mềm như
Bảng~\ref{tab:app_features}. Ngoài ra, các yêu cầu phi chức năng cũng được chú ý như là bảo mật thông tin, thời gian phản hồi hệ thống.
\begin{table}[H]
    \centering
    \caption{Các nhóm chức năng chính của ứng dụng}
    \label{tab:app_features}
    \begin{tabularx}{\textwidth}{|l|l|X|}
        \hline
        \textbf{Nhóm} & \textbf{Chức năng}             & \textbf{Mô tả}                                                                               \\
        \hline

        \multirow{3}{*}{Xác thực}
                      & Đăng ký                        & Người dùng đăng ký thông tin và xác thực qua email, số điện thoại.                           \\ \cline{2-3}
                      & Đăng nhập                      & Sử dụng tài khoản và mật khẩu đã đăng ký để truy cập hệ thống.                               \\ \cline{2-3}
                      & Quên mật khẩu                  & Hỗ trợ lấy lại tài khoản của người dùng.                                                     \\
        \hline

        \multirow{5}{*}{Ứng dụng}
                      & Kết nối Bluetooth              & Kết nối ứng dụng với phần cứng thông qua BLE.                                                \\ \cline{2-3}
                      & Chọn cảm biến                  & Lựa chọn cảm biến như gia tốc hoặc âm thanh.                                                 \\ \cline{2-3}
                      & Câu hỏi STOP-BANG, Epworth     & Trả lời bảng câu hỏi STOP-BANG và Epworth để đánh giá nguy cơ OSA; hiển thị lịch sử trả lời. \\ \cline{2-3}
                      & Theo dõi thông tin từ cảm biến & Hiển thị dữ liệu thời gian thực thông qua biểu đồ.                                           \\ \cline{2-3}
                      & Chatbot y tế                   & Chatbot sử dụng tập câu hỏi y học giấc ngủ (2000 câu) và công nghệ RAG.                      \\
        \hline
    \end{tabularx}
\end{table}

Ứng dụng di động được viết bằng ngôn ngữ DART trên nền tảng Flutter.
Vì sao lại chọn Dart mà không phải là các ngôn ngữ thuần túy như Java hay
Swift? Nói chung, chọn Dart trên nền tảng Flutter lý do chính là có thể
tạo ra hai phiên bản trên Android và IOS trên cùng một bộ mã chương trình.
Ngoài ra, việc khởi tạo dự án nhanh, cú pháp thân thiện với người lập trình
hơn, kèm cộng đồng đông đảo làm giảm đáng kể thời gian phát triển.

Để ứng dụng dễ dàng kiểm thử và nâng cấp,
BLoC được lựa chọn để quản lý các trạng thái của ứng dụng. Nó hoạt động dựa trên nguyên tắc nhận sự kiện đầu vào từ giao diện gồm trạng thái và dữ liệu đầu vào, xử lý trong khối BLOC như gọi lên máy chủ trung tâm
và trả lại dữ liệu. Qua đó, luồng dữ liệu trở nên rõ ràng. Cấu trúc tổng thể của kiến trúc
BLoC gồm ba lớp chính được mô tả trong Hình~\ref{flutter}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/flutter.png}
    \caption{Cấu trúc kiến trúc BLoC trong ứng dụng Flutter}
    \label{flutter}
\end{figure}

Mã nguồn của toàn bộ ứng dụng di động sẽ để dưới phần mục lục. Còn trong khuôn
khổ luận văn nay sẽ giải thích chức năng chính là kết nối phần cứng, hiển thị
và chuyển dữ liệu lên máy chủ trung tâm.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
            every node/.style={font=\footnotesize, align=center},
            process/.style={rectangle, draw, rounded corners,
                    minimum width=4cm, minimum height=1cm,
                    fill=blue!10, inner sep=5pt},
            arrow/.style={->, thick}
        ]
        \matrix[column sep=0mm, row sep=0.7cm] {
            \node[process] (init) {Yêu cầu cấp quyền Bluetooth từ thiết bị thật};                 \\
            \node[process] (finding) {Tìm kiểm các thiết bị BLE ngoại vi};                        \\
            \node[process] (connect) {Thiết lập kết nối với phần cứng qua tên Master\_2025\_BLE}; \\
            \node[process] (choosing) {Chọn đúng dịch vụ và đặc trưng theo UUID};                 \\
            \node[process] (notify) {Bắn tín hiệu theo dõi};
            \node[process] (present) {Hiển thị dữ liệu và đẩy lên máy chủ trung tâm};             \\
        };

        \foreach \i/\j in {init/finding, finding/connect, connect/choosing, choosing/notify, notify/present}
        \draw[arrow] (\i) -- (\j);
    \end{tikzpicture}
    \caption{Sơ đồ kết nối và nhận dữ liệu của ứng dụng di động}
    \label{fig:mobile_ble}
\end{figure}

Sau khi tìm hiểu, thư viện flutter\_blue\_plus được chọn để kết nối BLE từ ứng
dụng di động đến phần cứng \cite{flutter_blue_plus}. Nó hỗ trợ các phương thức
gồm quét, kết nối, đọc/ghi đặc tính và nhận thông báo từ thiết bị BLE trên
Android, iOS, macOS, Linux và web. Ngoài ra nó không có thêm phụ thuộc ngoài
Flutter, và được thiết kế cho vai trò BLE trung tâm (không hỗ trợ Bluetooth cổ
điển như HC-05). Đây là thư viện miễn phí cho cá nhân, tổ chức nhỏ, và phi lợi
nhuận; các công ty trên 50 nhân viên cần mua bản quyền để sử dụng thương mại.

\input{chapters/examples/ble_scan.tex}

Mã nguồn~\ref{lst:ble_scan} trình bày quy trình quét và kết nối thiết bị ngoại
vi BLE trong Flutter dựa trên thư viện flutter\_blue\_plus. Hàm onScanPressed()
mục đích quét thiết bị đang khả dụng thông qua dịch vụ mức pin có UUID là 180F.
Khi này BLoc nhận trạng thái quét, thực hiện quét và trả về danh sách mảng các
thiết bị bao gồm tên hiển thị, địa chỉ MAC. Hàm onStopPressed() dừng quá trình
quét, còn onConnectPressed() thiết lập kết nối với thiết bị được chọn và chuyển
đến màn hình điều khiển chi tiết.

\input{chapters/examples/flutter_ble}
Mã nguồn~\ref{flutterBle} trình bày cách ứng dụng hoạt động khi người dùng chọn
đúng BLE của phần cứng. Cụ thể, StreamBuilder được sử dụng để lắng nghe các
thay đổi của device.services, cho phép hệ thống phản ứng tức thời khi thiết bị
BLE truyền lên các dịch vụ khả dụng. Quá trình so khớp UUID giữa dịch vụ thực
tế đã cài đặt ở phần cứng và hằng số định nghĩa (ACCLEROMETER\_SERVICE,
ACCLEROMETER\_CHARACTION) trên ứng dụng di động cho phép xác thực logic nhằm
đảm bảo rằng ứng dụng chỉ giao tiếp với dịch vụ và đặc tính cảm biến hợp lệ.

Sau khi đã khớp các thành phần BLE, ứng dụng di động có thêm nút ấn để lấy
thông tin. Khi đó, ứng dụng di động sẽ gửi 1 yêu cầu theo dõi đến phần cứng.
Như đoạn mã~\ref{lst:ble_bmi270}, vi điều khiển lắng nghe được hành động theo
dõi sẽ lập tức gửi các gói tin lên lại ứng dụng di dộng theo cấu trúc đã xác
lập.

Đến đây, luận văn đã trình bày \textbf{hoàn thành quy trình kết nối và nhận dữ liệu từ phần cứng}.
Tiếp theo, luận văn sẽ mô tả rõ cách thức dữ liệu được đóng gói và chuyển lên phần máy chủ trung tâm.

Ngoài dữ liệu 3 trục x, y, z, nhóm xác định tập dữ liệu cần lưu thêm thời gian
tạo và giá trị ID của người đang dùng. Việc này đảm bảo việc minh bạch, dễ đối
chiếu và phân tích, mô phỏng lại giá trị cảm biến theo chuỗi thời gian. Mã
nguồn~\ref{format_ble} mô tả việc tối ưu hóa đẩy dữ liệu HTTP theo lô giúp giảm
tải phía máy chủ trung tâm. Điều này tăng tính mở rộng lên hàng trăm thiết bị
hoặc giá trị cảm biến khác đẩy lên cùng 1 thời điểm.

\input{chapters/examples/format_data_ble.tex}

Một điểm đáng lưu ý nữa, nhóm kết hợp cùng GS.TS. Dương Quý Sỹ phát triển thêm
tính năng \textbf{chatbot y học giấc ngủ} dựa trên kỹ thuật
\textbf{Retrieval-Augmented Generation (RAG)}. Chatbot này được xây dựng từ cơ
sở dữ liệu gồm hơn 2000 câu hỏi và câu trả lời chuyên sâu liên quan đến giấc
ngủ được biên tập bởi GS.TS Dương Quý Sỹ, bao gồm cả tài liệu lâm sàng, nghiên
cứu khoa học và các hướng dẫn thực hành. Người dùng có thể đặt câu hỏi tự nhiên
như “Tôi có nên lo nếu ngủ ngáy liên tục?” hoặc “STOP-BANG > 5 có ý nghĩa gì?”,
và chatbot sẽ phản hồi dựa trên kiến thức được truy xuất từ tài liệu nền và
được tổng hợp lại bằng mô hình ngôn ngữ.

Từ những phân tích nêu trên, luận văn đã chuẩn hóa được các bước cơ bản để từ
dữ liệu ở phần cứng đến lưu trữ trên máy chủ đám mây. Đây cũng chính là các
bước của hệ thống điện toán đám mây khi mọi dữ liệu, mô hình tính toán sẽ cùng
một nơi trên 1 hệ thống phần cứng mạnh mẽ.

\subsubsection{Máy chủ đám mây}

Để giảm thời gian phát triển, toàn bộ hệ thống máy chủ được triển
khai trển hạ tầng của Amazon Web Services (AWS) gồm 2 phần chính là máy chủ trung tâm và cơ sở dữ liệu.

\textbf{Máy chủ trung tâm}
có nhiệm vụ mở các kết nối (API) ra bên ngoài, nhận yêu cầu từ ứng dụng di động.
Ngôn ngữ Typescript (TS) trên nền tảng NodeJS được lựa chọn để xây dựng máy chủ trung tâm với các lý do: 1) TS cung cấp khả năng định nghĩ kiểu dữ liệu
cho biến, hàm. Các lỗi đó sẽ được phát hiện trong quá trình biên dịch ngay trước khi đến quá trình chạy (run time); 2) NodeJS có nhiều thư viện
hỗ trợ bảo mật, tương tác với các thành phần khác và khả năng khởi tạo nhanh dự án.
Về mặt cấu trúc mã nguồn, hệ thống được tổ chức theo mô hình phân lớp như thể hiện trong Hình~\ref{be_structure}.
\begin{table}[htbp]
    \centering
    \caption{Mô tả các thư mục chính trong cấu trúc mã nguồn máy chủ trung tâm}
    \label{tab:be_folder_structure}
    \begin{tabular}{p{3.2cm} p{10.5cm}}
        \toprule
        \textbf{Thư mục}      & \textbf{Chức năng và nội dung chính}                                                                         \\
        \midrule
        \texttt{mqtt\_broken} &
        Chứa mã nguồn khởi tạo và quản lý máy chủ MQTT, chịu trách nhiệm giao tiếp theo mô hình publish-subscribe với các thiết bị đầu cuối. \\

        \texttt{src/common}   &
        Bao gồm các mô-đun dùng chung như xác thực người dùng, quản lý kết nối cơ sở dữ liệu, và chuẩn hóa phản hồi lỗi hệ thống.            \\

        \texttt{src/config}   &
        Lưu trữ các thông số cấu hình nội bộ, bao gồm biến môi trường, thông tin kết nối và khóa truy cập nội bộ giữa các dịch vụ.           \\

        \texttt{src/migrate}  &
        Chứa lịch sử các lần thay đổi cấu trúc cơ sở dữ liệu nhằm đảm bảo khả năng truy vết, phục hồi và đồng bộ khi triển khai.             \\

        \texttt{src/modules}  &
        Tập hợp toàn bộ các mô-đun nghiệp vụ, nơi thực hiện các chức năng xử lý chính và điều phối hoạt động của hệ thống.                   \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.3\textwidth]{images/be_structure.png}
    \caption{Cấu trúc cây thư mục mã nguồn của máy chủ trung tâm}
    \label{be_structure}
\end{figure}

Kiến trúc trên không chỉ đảm bảo tính tách biệt giữa các tầng xử lý mà còn giúp
nâng cao khả năng bảo trì, kiểm thử và mở rộng trong tương lai.

\textbf{Cơ sở dữ liệu} có nhiệm vụ lưu trữ dữ liệu bao gồm dữ liệu về người dùng, cảm biến.
Sau khi tìm hiểu, nhóm chọn kiến trúc lưu trữ được thiết kế theo hướng lai,
kết hợp cả NoSQL (MongoDB) và SQL (Postgres), nhằm tận dụng thế mạnh riêng của từng loại hình.

Với đặc thù của dữ liệu cảm biến là mang tính phi cấu trúc, có tần suất cập
nhật gần như không và yêu cầu truy xuất theo chuỗi thời gian. Hệ thống lựa chọn
sử dụng \textbf{MongoDB} làm nền tảng lưu trữ chính cho nhóm dữ liệu này.
MongoDB thể hiện ưu thế vượt trội nhờ mô hình lưu trữ dạng tài liệu , cho phép
linh hoạt mở rộng cấu trúc dữ liệu mà không cần định nghĩa cột hàng cố định.
Bên cạnh đó, cơ chế \textit{indexing} tối ưu giúp tăng tốc độ truy vấn đối với
dữ liệu thời gian, đồng thời hỗ trợ các phép lọc, nhóm và tổng hợp hiệu quả
trong môi trường có khối lượng dữ liệu lớn.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/flow_http2.jpg}
    \caption{Lưu đồ thuật toán lưu trữ dữ liệu cảm biến}
    \label{flow_http}
\end{figure}

Ngược lại, \textbf{PostgreSQL} được triển khai nhằm quản lý các dữ liệu có cấu
trúc ổn định và đòi hỏi tính toàn vẹn quan hệ cao, bao gồm các thông tin định
danh người dùng, mật khẩu được mã hoá, kết quả bảng điểm STOP-BANG, thang điểm
buồn ngủ ban ngày Epworth, chỉ số BMI, cùng tiền sử bệnh nền. Cách tiếp cận này
không chỉ tăng cường khả năng kiểm soát logic nghiệp vụ ở tầng dữ liệu mà còn
là yêu cầu tiên quyết để hệ thống tuân thủ các tiêu chuẩn về \textbf{an toàn và
    bảo mật thông tin y tế}.

Lưu đồ thuật toán lưu trữ dữ liệu được thể hiện trong Hình~\ref{flow_http}, bao
gồm hai nhánh xử lý. \textit{(i)} Khi người dùng không có kết nối mạng, hệ
thống vẫn duy trì liên kết BLE và hiển thị tín hiệu thời gian thực; dữ liệu
được lưu tạm ở phía thiết bị thay vì đẩy lên cloud. \textit{(ii)} Khi người
dùng đã đăng nhập và có Internet, ứng dụng chuyển sang chế độ đồng bộ theo lô:
mỗi 1000 mẫu được gộp thành một gói để gửi lên máy chủ. Cơ chế này sẽ làm giảm
số lần yêu cầu từ ứng dụng lên máy chủ.

Do lý do độ dài trong khuôn khổ luận văn, luận văn không trình bày hết toàn bộ
các nghiệp vụ của máy chủ trung tâm. Phần mã nguồn sẽ được chú thích tại mục
lục.

\subsection{Học máy trong phân loại tư thế ngủ}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/hocmaytime.png}
    \caption{Phân bố khối lượng công việc với bài toán học máy phân loại tư thế ngủ trong luận văn}
    \label{hocmay_time}
\end{figure}

Tổng quan về các bước xây dựng hệ thống học máy cho bài toán phân loại tư thế
ngủ đã được trình bày tại Chương~\ref{chapter:1-introduction}. Sau khi đánh
giá, 4 mô hình học máy truyền thống là rừng ngẫu nhiên (Random forest - RF),
máy vec-tơ hỗ trợ (Support vector machine - SVM), hồi quy Logistic (Logistic
regression - LR), thuật toán tăng cường Gradient Boosting (GB) và một mô hình
mạng nơ-ron nhân tạo (Artificial Neural Network - ANN), được lựa chọn để đánh
giá.

Việc lựa chọn này dựa trên hai yếu tố là khả năng khái và độ phức tạp thuật
toán. Về khả năng khái quát, các mô hình được lựa chọn phản ánh những hướng
tiếp cận tiêu biểu trong học máy truyền thống, bao gồm cả mô hình tuyến tính,
phi tuyến và mô hình học sâu cơ bản. Cụ thể, RF và GB là hai đại diện tiêu biểu
của nhóm mô hình ensemble dựa trên cây quyết định, có khả năng mô hình hóa các
quan hệ phi tuyến phức tạp và khắc phục hiện tượng quá khớp cao. Hồi quy
logistic giúp giải thích trực quan mối quan hệ giữa các đặc trưng đầu. Máy
véc-tơ hỗ trợ được lựa chọn vì có khả năng tạo ranh giới phân lớp rõ ràng trong
không gian đặc trưng. Bên cạnh đó, Mạng nơ-ron nhân tạo được đưa vào nhằm khảo
sát khả năng trừu tượng hóa sâu của dữ liệu cảm biến, nơi mối quan hệ giữa đặc
trưng và nhãn phân loại có thể phi tuyến và phức tạp hơn so với các mô hình cổ
điển. Trong đó, mô hình ANN được thiết kế với hai lớp ẩn nhằm đánh giá sơ bộ
hiệu quả của mô hình học sâu trước khi mở rộng sang các kiến trúc phức tạp hơn
như mạng tích chập (Convolutional Neural Network - CNN), mạng hồi tiếp
(Recurrent Neural Network - RNN) hay mạng bộ nhớ dài ngắn hạn (Long Short-Term
Memory - LSTM).

\subsubsection{Hồi quy Logistic}

Đây là thuật toán học máy có giám sát được thiết kế cho các tác vụ phân loại dựa trên các đặc trưng đầu vào.
Về mặt cấu trúc, hồi quy Logistic làm việc dựa trên nguyên tắc của hàm sigmoid - một hàm phi tuyến
chuyển đầu vào của nó thành xác suất thuộc về một trong hai
lớp đối với bài toán phân loại nhị phân:

\begin{equation}
    \sigma(z) = \frac{1}{1 + e^{-z}}, \quad \text{với } z = \mathbf{w}^T \mathbf{x} + b
\end{equation}

Trong đó, $\mathbf{w}$ là vector trọng số, $\mathbf{x}$ là vector đặc trưng đầu
vào, và $b$ là hệ số điều chỉnh (bias). Khi xác suất này vượt quá một ngưỡng
nhất định (thông thường là $0.5$), mô hình sẽ gán nhãn cho $\mathbf{x}$ là
thuộc lớp dương. Ngược lại, nếu nhỏ hơn ngưỡng, mẫu được phân loại vào lớp âm.

Mặc dù đơn giản và dễ triển khai, hồi quy logistic nguyên thủy chỉ phù hợp với
các bài toán phân loại nhị phân. Để mở rộng cho bài toán phân loại đa lớp, có
thể sử dụng biến thể \textbf{Softmax Regression}, trong đó mô hình ước lượng
xác suất đầu ra theo phân phối softmax:

\begin{equation}
    P(y = j \mid \mathbf{x}) = \frac{e^{\mathbf{w}_j^\top \mathbf{x}}}{\sum_{k=1}^{K} e^{\mathbf{w}_k^\top \mathbf{x}}}
\end{equation}

Trong đó, $K$ là tổng số lớp và $\mathbf{w}_j$ là vector trọng số tương ứng với
lớp $j$. Cách tiếp cận này cho phép mô hình tính toán đồng thời xác suất cho
tất cả các lớp và lựa chọn lớp có xác suất cao nhất làm đầu ra.

Ngoài phương pháp softmax, một chiến lược mở rộng khác thường được sử dụng là
\textbf{One-vs-Rest (OvR)}. Trong chiến lược này, mô hình sẽ huấn luyện $K$ bộ
phân loại nhị phân độc lập, mỗi bộ phân biệt một lớp cụ thể với phần còn lại
của tập dữ liệu. Khi dự đoán, mẫu dữ liệu mới được đưa vào cả $K$ mô hình, và
lớp có xác suất dự đoán cao nhất sẽ được chọn làm kết quả cuối cùng.

Trong bài toán phân loại tư thế ngủ, LR được kì vọng sẽ tối ưu về mặt chi phí
tính toán và kích thước mô hình để phù hợp với các bài toán triển khai tại
biên.

\subsubsection{Máy vec-tơ hỗ trợ}

Đây là một thuật
toán học có giám sát, đặc biệt hiệu quả cho các bài toán phân loại nhị
phân với biên ranh giới rõ ràng \cite{cortes1995svm}. Ý tưởng chính của SVM là tìm kiếm một
\textbf{mặt siêu phẳng} trong không gian đặc trưng để phân
chia các điểm dữ liệu thành hai lớp sao cho biên phân cách giữa các lớp
là lớn nhất.

Trong không gian hai chiều, mặt siêu phẳng tương ứng với một đường thẳng; trong
không gian ba chiều, đó là một mặt phẳng. Trong không gian nhiều chiều hơn, nó
là một siêu mặt phẳng tổng quát. SVM chọn mặt siêu phẳng sao cho khoảng cách từ
nó đến các điểm dữ liệu gần nhất của mỗi lớp - gọi là \textbf{support vectors}
là tối đa.

Trong không gian hai chiều, khoảng cách từ một điểm có tọa độ $(x_0, y_0)$ đến
đường thẳng có phương trình:
\[
    w_1 x + w_2 y + b = 0
\]
được xác định bởi công thức:
\begin{equation}
    d = \frac{|w_1 x_0 + w_2 y_0 + b|}{\sqrt{w_1^2 + w_2^2}}
\end{equation}

Tương tự, trong không gian ba chiều, khoảng cách từ một điểm $(x_0, y_0, z_0)$
đến mặt phẳng có phương trình:
\[
    w_1 x + w_2 y + w_3 z + b = 0
\]
được tính bằng:
\begin{equation}
    d = \frac{|w_1 x_0 + w_2 y_0 + w_3 z_0 + b|}{\sqrt{w_1^2 + w_2^2 + w_3^2}}
\end{equation}

Dấu của biểu thức $(w_1 x_0 + w_2 y_0 + w_3 z_0 + b)$ cho biết điểm $(x_0, y_0,
    z_0)$ nằm về phía nào của mặt phẳng đang xét. Những điểm có giá trị dương nằm
về cùng một phía (phía dương), trong khi những điểm có giá trị âm nằm về phía
còn lại (phía âm). Các điểm nằm trên chính mặt phẳng này sẽ làm cho tử số bằng
không, tức là khoảng cách bằng 0.

Khái niệm này có thể được \textbf{tổng quát hóa lên không gian nhiều chiều}.
Giả sử ta có một điểm (vector) $\mathbf{x}_0 \in \mathbb{R}^d$ và một siêu mặt
phẳng có phương trình \cite{MLCoBan2017_SVM}:
\[
    \mathbf{w}^\top \mathbf{x} + b = 0
\]
thì khoảng cách vuông góc từ điểm $\mathbf{x}_0$ đến siêu mặt phẳng này được
cho bởi:
\begin{equation}
    d = \frac{|\mathbf{w}^\top \mathbf{x}_0 + b|}{\|\mathbf{w}\|_2}
\end{equation}

trong đó:
\[
    \|\mathbf{w}\|_2 = \sqrt{\sum_{i=1}^{d} w_i^2}
\]
với vector trọng số $\mathbf{w}$, và $d$ là số chiều của không gian.

Hình~\ref{svm} minh hoạ khái niệm mặt siêu phẳng và các máy hỗ trợ trong không
gian hai chiều.

Với mặt phẳng phân chia như trên, khoảng cách được tính là khoảng cách gần nhất
từ một điểm tới mặt phẳng đó (bất kể điểm thuộc hai lớp nào):

\[
    \text{margin} = \min_{n} \frac{y_n \left( \mathbf{w}^T \mathbf{x}_n + b \right)}{||\mathbf{w}||_2}
\]

Bài toán tối ưu trong SVM chính là bài toán tìm \(\mathbf{w}\) và \(b\) sao cho
\textit{margin} này đạt giá trị lớn nhất:

\[
    (\mathbf{w}, b) = \arg\max_{\mathbf{w},\, b}
    \left\{
    \min_{n}
    \frac{y_n \left( \mathbf{w}^T \mathbf{x}_n + b \right)}{||\mathbf{w}||_2}
    \right\}
\]

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{images/svm.png}
    \caption{Minh họa mặt siêu phẳng phân tách hai lớp trong SVM}
    \label{svm}
\end{figure}

Thêm vào đó, SVM có thể mở rộng cho các bài toán không tuyến tính thông qua
việc sử dụng các hàm kernel, chẳng hạn như \textbf{Gaussian RBF kernel} hoặc
\textbf{polynomial kernel}, giúp ánh xạ dữ liệu vào không gian mới nơi mà việc
phân tách tuyến tính trở nên khả thi.

Để mở rộng cho các bài toán phân loại đa lớp, có thể áp dụng hai kỹ
thuật phổ biến: \textbf{one-vs-one} và \textbf{one-vs-rest}, được minh
hoạ trong Hình~\ref{svm_ovso} và Hình~\ref{ovsr}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{images/svm_ovso.png}
    \caption{Chiến lược phân loại đa lớp bằng phương pháp One-vs-One}
    \label{svm_ovso}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{images/ovsr.png}
    \caption{Chiến lược phân loại đa lớp bằng phương pháp One-vs-Rest}
    \label{ovsr}
\end{figure}

\textbf{One-vs-One (OvO):} Trong phương pháp này, một mô hình SVM được
huấn luyện cho mỗi cặp lớp. Với $K$ lớp, tổng cộng $\frac{K(K-1)}{2}$
mô hình con được huấn luyện. Mỗi mô hình học cách phân biệt giữa hai
lớp cụ thể và bỏ qua các lớp còn lại. Trong quá trình dự đoán, một cơ
chế bỏ phiếu (voting) được sử dụng để xác định lớp cuối cùng.

\textbf{One-vs-Rest (OvR):} Phương pháp này huấn luyện một mô hình cho
mỗi lớp, trong đó mô hình học cách phân biệt giữa một lớp cụ thể và
phần còn lại. Với $K$ lớp, ta có $K$ mô hình. Trong quá trình suy luận,
mô hình đưa ra xác suất hoặc độ tin cậy, và lớp có giá trị cao nhất
sẽ được chọn.

Cả hai chiến lược OvO và OvR đều giúp mở rộng SVM từ mô hình phân loại nhị phân
thành phân loại đa lớp hiệu quả, nhưng mỗi phương pháp đều có ưu và nhược điểm
riêng về thời gian huấn luyện, độ phức tạp tính toán và hiệu năng phân loại.

\subsubsection{Rừng ngẫu nhiên}

Đây là một mô hình học có
giám sát thuộc nhóm thuật toán tổ hợp (ensemble learning),
được xây dựng dựa trên nền tảng của
\textbf{Cây quyết định (Decision Tree)} \cite{breiman2001random}.
Khác với việc sử dụng một cây quyết định duy nhất
truyền thống, rừng ngẫu nhiên xây dựng một tập hợp gồm nhiều cây
quyết định độc lập, mỗi cây học trên một phần khác nhau của dữ liệu và
không sử dụng toàn bộ tập thuộc tính. Dự đoán cuối cùng của mô hình
được xác định thông qua cơ chế biểu quyết hoặc trung bình hoá
(trong bài toán hồi quy).

Ý tưởng chính của rừng ngẫu nhiên nhằm giảm thiểu hiện tượng
\textbf{quá khớp (overfitting)} thường gặp trong câu quyết định đơn lẻ.
Khi xây dựng một cây quyết định mà không giới hạn độ sâu,
cây có xu hướng học thuộc hoàn toàn dữ liệu huấn luyện,
dẫn đến khả năng tổng quát kém trên tập kiểm thử.
RF khắc phục điều này bằng cách đưa vào hai cơ chế ngẫu nhiên chính:

\vspace{0.5em}
\noindent\textbf{1) Lấy mẫu bootstrap:} Mỗi cây được huấn luyện trên
một tập con của dữ liệu ban đầu, được chọn ngẫu nhiên có lặp lại
(bootstrap sampling). Như vậy, một phần dữ liệu được bỏ qua,
làm tăng tính đa dạng giữa các cây.

\vspace{0.5em}
\noindent\textbf{2) Lựa chọn ngẫu nhiên tập thuộc tính:} Tại mỗi nút
phân chia của cây, chỉ một tập con ngẫu nhiên của các thuộc tính được
xem xét để chọn điểm chia tốt nhất. Điều này làm giảm sự tương quan
giữa các cây trong rừng.

Ngoài ra, việc tổng hợp kết quả của nhiều cây giúp giảm phương sai, cải thiện
khả năng tổng quát hoá. Nhờ đó, RF đạt được sự ổn định kể cả với các bộ dữ liệu
có nhiễu hoặc mất cân bằng.

\subsubsection{Gradient boosting}

Đây là một phương pháp học
có giám sát cũng thuộc nhóm thuật toán tổ hợp (ensemble learning) \cite{chen2016xgboost}.
Khác với RG khi các cây được xây dựng song song và độc lập,
GB xây dựng mô hình theo từng bước lặp, mỗi cây tiếp
theo được huấn luyện để sửa lỗi còn lại từ mô hình trước đó. Cụ thể, tại mỗi
vòng lặp $t$, mô hình hiện tại $F_t(x)$ được cập nhật bằng cách cộng thêm một
cây mới $h_t(x)$ được huấn luyện để xấp xỉ gradient âm của hàm mất mát:

\begin{equation}
    F_{t+1}(x) = F_t(x) + \gamma h_t(x)
\end{equation}

Trong đó, $\gamma$ là hệ số học (learning rate), điều chỉnh mức đóng góp của
cây mới vào tổng thể mô hình.

Một trong những đặc điểm quan trọng của GB là khả năng tối ưu hoá trực tiếp một
hàm mất mát bất kỳ, chẳng hạn như hàm log-loss trong bài toán phân loại, hoặc
hàm bình phương sai số trong bài toán hồi quy. Nhờ đó, GB thường đạt độ chính
xác rất cao, đặc biệt trên các bài toán với dữ liệu có quan hệ phi tuyến và có
nhiều đặc trưng tương tác phức tạp.

Tuy nhiên, GB cũng có những hạn chế rõ rệt. Do các cây được xây dựng tuần tự
phụ thuộc lẫn nhau, GB thường mất nhiều thời gian huấn luyện hơn so với RF. Hơn
nữa, mô hình nhạy cảm với nhiễu và dữ liệu nhiễu sẽ dễ dàng bị mô hình học
theo, dẫn đến hiện tượng quá khớp hơn.

\subsubsection{Mạng nơ-ron nhân tạo}

Đây thuộc lớp
mô hình học sâu mô phỏng cấu trúc hoạt động của hệ thần kinh sinh học,
trong đó các nơ-ron nhân tạo (artificial neurons) được tổ chức thành nhiều
lớp (layers) và kết nối với nhau qua các trọng số (weights) \cite{jain1996}.

Trong nghiên cứu này, kiến trúc đơn giản nhất gồm 3 lớp: lớp đầu vào (input
layer), hai lớp ẩn (hidden layers) và lớp đầu ra (output layer), sẽ được sử
dụng.

Mỗi nơ-ron trong lớp ẩn thực hiện một tổ hợp tuyến tính giữa các đầu vào, sau
đó áp dụng một hàm kích hoạt phi tuyến như hàm ReLU (Rectified Linear Unit):

\begin{equation}
    f(x) = \max(0, x)
\end{equation}

Đầu ra của mạng được tính thông qua lan truyền tiến,
và mô hình được huấn luyện bằng cách tối thiểu hóa một hàm mất mát.

Ưu điểm chính của mạng nơ-ron là khả năng học các quan hệ phi tuyến
phức tạp và tự động trích xuất đặc trưng từ dữ liệu. Khác với các mô
hình tuyến tính như LR hoặc SVM, ANN có thể biểu diễn các ranh giới
phân lớp không tuyến tính và phù hợp với các bài toán đa tín hiệu cảm
biến, đa cấu trúc.

Tuy nhiên, trong khuôn khổ của nghiên cứu này, mục tiêu chính không chỉ là đạt
độ chính xác tối đa mà còn là đánh giá ảnh hưởng của các đặc trưng trên miền
thời gian và miền tần số đối với hiệu suất của mô hình học máy nên nhóm quyết
định chọn LR, SVM, RF, GB, NN để tiến hành thử nghiệm. Còn tương lai, nhóm sẽ
mở rộng với các thuật toán phức tạp hơn để đánh giá toàn diện hơn đối với bài
toán phân loại tư thế ngủ.

Đến đây, luận văn đã trình bày đầy đủ phương pháp xây dựng hệ thống, bao gồm cả phần cứng, phần mềm và các mô hình học máy được lựa chọn phù hợp với bài toán phân loại tư thế ngủ.
Phương pháp đề xuất được đánh giá một cách toàn diện, từ cơ sở lý thuyết đến triển khai thực tế, nhằm đảm bảo tính khả thi và hiệu quả trong ứng dụng.
